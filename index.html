
<html lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>💡MyEbook</title>
       <script src="https://cdn.tailwindcss.com"></script> 
    <script src="./Canvas_files/saved_resource"></script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap');
        /* General Setup */
        body {  
              font-family:  'cwTeXYen','Inter', sans-serif;
            background-color: #f7f7f7;
margin: 0;
    padding: 0;
  
         }
        /* Editor Area */
        #editor-wrapper { display: flex; flex-grow: 1; margin: 0;
    padding: 0;
    border: none;
    /* Also ensure it is positioned relative for context */
    position: relative;}
        #editor { height: 100%; width: 100%; border: 0px solid #e5e7eb; background-color: #ffffff; position: relative; overflow: hidden; touch-action: none; cursor: default;transform-origin: top left; }
        
        /* Drawing Canvas */
        #drawingCanvas { position: absolute; top: 0; left: 0; z-index: 15; pointer-events: none; }
        #myCanvas { position: absolute; top: 0; left: 0; z-index: 50; pointer-events: none; }        
        /* Draggable Elements (CSS from your original code) */
 
        .draggable-image, .floating-div {
            cursor: move;
           position: absolute;
            padding: 5px;
            box-sizing: border-box;
            z-index: 10; /* Draggable elements base layer */
            /*min-width: 10px;
            min-height: 10px;*?
            /*box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);*/
            transition: border-radius 0.1s;
             transition: all 0.3s ease-out;
        }

        /* Selected State */
        .draggable-image.selected, .floating-div.selected {
            outline: 2px dashed #3b82f6;
             /*transition: all 0.7s ease-out;*/
        }
        
        .floating-div.editing { outline: 2px solid #10b981; cursor: text; }
        .draggable-image.locked, .floating-div.locked { cursor: not-allowed; }
        .resizer { position: absolute; width: 12px; height: 12px; border-radius: 50%; bottom: -6px; right: -6px; cursor: nwse-resize; z-index: 10; }
        .resizer:hover { background: #3b82f6; border: 2px solid #ffffff; }

        /* Main Layout */
        #main-container { display: flex; height: calc(90vh - 50px); } 

        /* Page Management Sidebar */
        #page-manager { width: 250px; background-color: #ffffff; padding: 16px; border-right: 1px solid #e5e7eb; box-shadow: 2px 0 5px rgba(0,0,0,0.05); display: flex; flex-direction: column; }
        #page-list { list-style: none; padding: 0; margin: 0; overflow-y: auto; flex-grow: 1; }
        #page-list li { padding: 10px; cursor: pointer; border-radius: 6px; margin-bottom: 5px; border: 1px solid transparent; display: flex; justify-content: space-between; align-items: center; }
        #page-list li.active { background-color: #dbeafe; color: #1e40af; font-weight: bold; border-color: #93c5fd; }
        
        /* Typography */
        h1 { color: coral; text-shadow: -2px 0 black, 0 2px black, 2px 0 black, 0 -2px black; }
        h2 { color: #333; text-shadow: 0 0 3px cyan, 0 0 5px cyan; }
        h3 { color: coral; text-shadow: 2px 2px 4px #000000; }
        .fly-in-animated { transition: all 1.8s ease-out; }
   

        .picker-container {
            background-color: white;
            padding: 2rem;
            border-radius: 1rem;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            max-width: 400px;
            width: 90%;
            text-align: center;
	justify-content: center;align-items: center;
            position:absolute;
           top:0px;           left:calc(50vw - 200px);   
           z-index:50;
        }
        .result-display {
            font-size: 4rem;
            font-weight: 800;
            color: #1f2937;
            margin-top: 1rem;
            min-height: 4rem;
	justify-content: center;align-items: center;
        }
        /* Toolbar */
        #main-toolbar { padding: 10px; background-color: #eef; border-bottom: 1px solid #ccc; display: flex; gap: 10px; align-items: center; }
        #currentProjectDisplay { font-weight: bold; padding: 0 10px; background: #fff; border-radius: 4px; }


/* QUIZ  AREA   */ 
        #app-container {
            position: relative;
            width: 95vw;
            max-width: 900px;
            height: 90vh;
            max-height: 800px;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
            flex-direction: column;
            display: none; 
        }

        #gameCanvas {
pointer-events: auto;
            cursor: crosshair;
            touch-action: none;
        }

        /* 樣式針對 DIV ID quizData */
        #quizData {
            max-height: 200px;
            min-height: 100px;
            border: 1px solid #f97316; 
            white-space: pre-wrap;
            overflow-y: scroll;
        }
        
        #quizData::-webkit-scrollbar {
            width: 8px;
        }
        #quizData::-webkit-scrollbar-thumb {
            background-color: #f97316;
            border-radius: 4px;
        }
        #quizData::-webkit-scrollbar-track {
            background: #4b5563;
        }

        /* 診斷訊息的預格式化文字 */
        #diagnostic-display pre {
            word-wrap: break-word;
            white-space: pre-wrap;
        }
        /* Custom CSS for a clean, centered game look */
        #gameCanvas {

            border: 4px solid #1f2937;
            border-radius: 12px;
            box-shadow: 0 10px 20px -5px rgba(0, 0, 0, 0.2);
            background-color: #f9fafb;
            touch-action: none; /* Prevents default browser actions like scrolling/zooming */
        }
        /* --- 3D FLIP CSS --- */
        .flip-container {
            perspective: 1000px; /* Gives the scene depth */
            height: 120px; /* Fixed height for flip container */
            width: 100%;
            margin-bottom: 2rem;
        }
        .flipper {
            position: relative;
            transform-style: preserve-3d;
            transition: transform 0.8s; /* Smooth flip animation */
            width: 100%;
            height: 100%;
        }
        .flipper.is-flipped {
            transform: rotateY(180deg);
        }
        .front, .back {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            backface-visibility: hidden; /* CRITICAL: Hides the element when rotated away */
            border-radius: 0.5rem;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .front {
            background-color: #e5e7eb; /* Light gray background for the "?" */
            z-index: 2;
            transform: rotateY(0deg);
        }
        .back {
            background-color: #d1fae5; /* Light green background for the result */
            transform: rotateY(180deg); /* Start rotated, ready to flip into view */
        }

        /* Styling for the content inside the card faces */
        .card-content {
            font-size: 4rem;
            font-weight: 800;
            color: #1f2937;
        }
        /* --- END 3D FLIP CSS --- */
    </style>
</head>
<body onclick="window.dropmenu();window.expand();" onmousestart="window.dropmenu();window.expand()" >

     <div id="screen" class="p-0 bg-white shadow-lg rounded-xl" style="border:2px double gray "><!-- 全螢幕範圍開始 -->





<!-- 測驗區開始 -->
<!-- 彈出視窗 Modal 結構 (用於顯示錯誤或最終分數) -->
<div id="modalOverlay" class="fixed inset-0 bg-black bg-opacity-50 hidden justify-center items-center z-50">
    <div id="modalContent" class="bg-white p-6 rounded-xl shadow-2xl max-w-sm w-full text-center" style="margin-left:500px;margin-top:200px" >
        <h3 id="modalTitle" class="text-xl font-bold mb-4  "></h3>
        <p id="modalBody" class="text-xl font-medium text-gray-700 mb-6"></p>
        <button onclick="document.getElementById('modalOverlay').classList.add('hidden')" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700">關閉</button>
    </div>
</div>


<!-- 測驗區結束 -->


<!-- 切水果遊戲 開始-->
    <!-- 遊戲主容器 -->
    <div id="app-container" class="relative hidden w-full h-full p-4">
        <!-- 畫布區域 -->
        <div class="relative w-full h-full max-w-4xl max-h-[800px] mx-auto flex-grow">
            <canvas id="gameCanvas" class="relative z-0"></canvas>
            
            <!-- 遊戲狀態顯示區 -->
            <div class="absolute top-0 left-0 right-0 z-10 flex justify-between p-4 text-white">
                <div>
                    分數: <span id="game-score" class="text-green-400 font-bold text-xl">0</span>
                </div>
                <div>
                    生命: <span id="lives" class="text-red-400 font-bold text-xl">3</span>
                </div>
<button onclick="window.toggleGameTheme('none');" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700">關閉</button>
            </div>
            
            <!-- 當前問題顯示區 -->
            <div class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 z-10 p-3 bg-gray-800 bg-opacity-70 rounded-lg text-center shadow-lg">
                <p id="current-question" class="text-lg font-semibold text-white">
                    準備開始...
                </p>
            </div>
        </div>
    </div>

    <!-- 啟動/訊息/編輯器 Wrapper (常規顯示) -->
    <div id="launch-wrapper" class="absolute inset-0 flex items-center justify-center p-4">
        
        <!-- 訊息/結果/錯誤 彈窗 (預設在最前面) -->
        <div id="message-box" class="modal fixed inset-0 flex items-center justify-center z-50 bg-black bg-opacity-70">
            <div id="game-start-message" class="bg-gray-800 p-8 rounded-xl shadow-2xl max-w-md w-full text-center border-t-4 border-indigo-500">
                <h2 id="message-text" class="text-3xl font-extrabold mb-4 text-white">測驗斬擊大師</h2>
                <p id="quiz-message-detail" class="text-gray-300 mb-6">
                    這是一個基於 PSV（Pipe Separated Values）資料的遊戲。點擊「編輯資料」來載入您的測驗。
                </p>
                <button id="initial-start-button" class="px-6 py-3 bg-indigo-600 text-white font-bold rounded-lg shadow-lg hover:bg-indigo-700 transition duration-150">
                    編輯資料
                </button>
                <div class="mt-4 text-sm text-gray-400">
                    已載入問題數: <span id="total-questions-loaded">0</span>
                </div>
            </div>

            <!-- 編輯器模式 -->
            <div id="quiz-editor" class="hidden bg-gray-800 p-6 rounded-xl shadow-2xl max-w-3xl w-full text-left border-t-4 border-green-500">
                <h2 class="text-2xl font-bold mb-4 text-white">編輯測驗資料 (PSV 格式)</h2>
                <p class="text-sm text-gray-300 mb-3">格式: ID | 問題 | **正確選項索引 (1-4, 必須是乾淨數字)** | 選項1 | 選項2 | 選項3 | 選項4</p>
                <p id="errorMsg" class="hidden text-red-400 mb-3 font-semibold"></p>
                
                <textarea id="quizDataSource" class="w-full h-64 p-3 mb-4 bg-gray-700 text-green-300 rounded-lg focus:ring-2 focus:ring-green-500 text-sm" placeholder="範例：1 | 哪個是正確答案？ | 2 | 錯誤A | 正確B | 錯誤C | 錯誤D"></textarea>
                
                <div class="flex justify-between items-center">
                    <button onclick="window.QS_parseAndLoadQuiz(document.getElementById('quizDataSource').value)" class="px-6 py-3 bg-green-600 text-white font-bold rounded-lg shadow-lg hover:bg-green-700 transition duration-150">
                        載入並開始測驗
                    </button>
                    <button onclick="window.QS_toggleEditMode(false)" class="px-4 py-2 text-gray-300 hover:text-white transition duration-150">
                        返回主畫面
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- 隱藏的 DOM 元素，用於儲存和讀取資料 (即使編輯器未顯示，也必須存在) -->
    <div id="quizArea" class="hidden">
        <div id="quizData" contenteditable="true">
1 | 哪種水果是紅色的? | 1 | 蘋果 | 香蕉 | 葡萄 | 橘子
2 | 10 + 5 等於多少? | 3 | 12 | 14 | 15 | 16
3 | 地球繞著什麼轉? | 4 | 月亮 | 火星 | 金星 | 太陽
4 | 台灣的首都在哪裡? | 1 | 台北 | 台中 | 高雄 | 台南
        </div>
    </div>

<!-- 切水果遊戲 -->







<!-- 雙人遊戲開始  dual game-->

    <div class="flex flex-col items-center w-full max-w-5xl">

        <!-- DUAL GAME CONTAINER (Initially hidden) -->
        <div id="dualGameContainer" class="flex flex-col items-center w-full" style="display: none;">
            
            <!-- Scoreboard and Controls -->
            <div id="info-bar" class="flex justify-between w-full mb-4 text-lg font-bold text-gray-700 max-w-4xl">
                <div class="p-3 bg-blue-100 rounded-lg shadow-md flex items-center">
                    <span class="text-blue-700">P1 Score: <span id="p1-score">0</span></span>
                </div><button onclick="window.toggleGameTheme('none');" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700">☒</button>
                <div class="p-3 bg-red-100 rounded-lg shadow-md flex items-center">
                    <span class="text-red-700">P2 Score: <span id="p2-score">0</span></span>
                </div>
            </div>

            <!-- Canvas Container: ID is dualGameCanvas -->
            <canvas id="dualGameCanvas"></canvas>
            
            <p class="text-sm text-gray-500 mt-4 text-center">
                **TOUCH:** Swipe on your screen half to move. | **P1 Keys:** W/A/S/D | **P2 Keys:** Arrows
            </p>

            <!-- Dynamic Data Container (Hidden, required for parsing) -->

        </div>

    </div>

<!--雙人遊戲結束  dual game-->


    <!-- 抽號碼開始 -->
<div id="picker-wrapper" class="picker-container hidden" >
    <h2 class="text-2xl font-bold mb-6 text-orange-800">班級抽號機 </h2>
    
    <!-- FLIP CONTAINER WRAPPER -->
    <div id="flipContainer" class="flip-container">
        <div id="flipper" class="flipper">
            <!-- FRONT SIDE: Shows the initial question mark -->
            <div class="front">
                <div class="card-content">?</div>
            </div>
            <!-- BACK SIDE: Shows the drawn number -->
            <div class="back">
                <div id="resultDisplay" class="card-content"></div>
            </div>
        </div>
    </div>
    <!-- END FLIP CONTAINER WRAPPER -->
    
    <!-- 抽號碼按鈕 -->
    <button 
        id="pickBtn"
        onclick="window.pickNumber()" 
        class="w-full mb-4 px-6 py-3 text-lg font-semibold text-white bg-blue-600 rounded-xl hover:bg-blue-700 transition duration-150 shadow-lg shadow-blue-500/50"
    >
        抽號碼
    </button>
    
    <!-- 重置按鈕 -->
        <button onclick="document.getElementById('picker-wrapper').classList.add('hidden')" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700">關閉</button>
    <button 
        onclick="window.resetPicker()" 
        class="w-full px-6 py-2 text-md font-medium text-gray-700 bg-gray-200 rounded-xl hover:bg-gray-300 transition duration-150"
    >
        重置號碼池
    </button>

    <div class="mt-8 pt-4 border-t border-gray-200">
        <h2 class="text-lg font-semibold mb-2">已抽出的號碼 (<span id="countDisplay">0</span> / <input type="number" id="maxClassNumber" min="1" max="30" step="1" value="30" oninput="window.resetPicker();" >)</h2>
        <div id="pickedList" class="text-sm text-gray-600 flex flex-wrap justify-center gap-2">
            <!-- 已抽出的號碼將顯示在這裡 -->
        </div>
 
    </div>
</div>

<!-- 彈出視窗 Modal 結構 -->


    <!-- 抽號碼結束 -->



<!-- 分組計分板 -->
<div id="teamBoard" style="display:none;position:absolute;left:calc(50vw - 350px);top:40px;height:40px;width:700px;z-index:50;font-size:20px;background:lightyellow;border-radius:6px; border:4px solid lightgrey" >
<span  title="關閉" onclick="document.getElementById('teamBoard').style.display='none';"  style="color:gray;cursor:hand;font-size:26px;font-weight:bolder;margin-left:10px;font-size:20px;" >🗷</span>
<!-- 分組計分 -->
<b>Team</b>
<font color="dodgerblue" ><b>  1 </b></font>
<div style="margin:4px;display:inline;background:lightcyan;border-radius:6px;width:120px; border:1px solid lightgrey" >

<div style="display:inline; " onclick="document.getElementById('tem_1').value=Number(document.getElementById('tem_1').value)+1;">+</div>
<input type="text" id="tem_1" size="2" value="0" style="height:20px;width:30px;" >
<div style="display:inline; " onclick="document.getElementById('tem_1').value=Number(document.getElementById('tem_1').value)-1;">-</div></div>

<!-- 分組計分 -->
<font color="orange" ><b>  2 </b></font>
<div style="margin:4px;display:inline;background:yellow;border-radius:6px;width:120px; border:1px solid lightgrey" >

<div style="display:inline;color:gray" onclick="document.getElementById('tem_2').value=Number(document.getElementById('tem_2').value)+1;">+</div>
<input type="text" id="tem_2" size="2" value="0" style="height:20px;width:30px" >
<div style="margin:4px;display:inline;color:gray" onclick="document.getElementById('tem_2').value=Number(document.getElementById('tem_2').value)-1;">-</div></div>
<!-- 分組計分 -->
<font color="lime" ><b>   3 </b></font>
<div style="margin:4px;display:inline;background:lime;border-radius:6px;width:120px; border:1px solid lightgrey" >

<div style="display:inline; " onclick="document.getElementById('tem_3').value=Number(document.getElementById('tem_3').value)+1;">+</div>
<input type="text" id="tem_3" size="2" value="0" style="height:20px;width:30px" >
<div style="display:inline; " onclick="document.getElementById('tem_3').value=Number(document.getElementById('tem_3').value)-1;">-</div></div>
<!-- 分組計分 -->
<font color="lightseagreen" ><b>  4 </b></font>
<div style="margin:4px;display:inline;background:lightskyblue;border-radius:6px;width:120px; border:1px solid lightgrey" >

<div style="display:inline;color:gray" onclick="document.getElementById('tem_4').value=Number(document.getElementById('tem_4').value)+1;">+</div>
<input type="text" id="tem_4" size="2" value="0" style="height:20px;width:30px" >
<div style="display:inline;color:gray" onclick="document.getElementById('tem_4').value=Number(document.getElementById('tem_4').value)-1;">-</div></div>
<!-- 分組計分 -->
<font color="fuchsia" ><b>   5  </b></font>
<div style="margin:4px;display:inline;background:fuchsia;border-radius:6px;width:120px; border:1px solid lightgrey" >

<div style="display:inline; " onclick="document.getElementById('tem_5').value=Number(document.getElementById('tem_5').value)+1;">+</div>
<input type="text" id="tem_5" size="2" value="0" style="height:20px;width:30px" >
<div style="display:inline; " onclick="document.getElementById('tem_5').value=Number(document.getElementById('tem_5').value)-1;">-</div></div>
<!-- 分組計分 -->
<font color="red" ><b>  6 </b></font>
<div style="margin:4px;display:inline;background:tomato;border-radius:6px;width:120px; border:1px solid lightgrey" >

<div style="display:inline;color:gray" onclick="document.getElementById('tem_6').value=Number(document.getElementById('tem_6').value)+1;">+</div>
<input type="text" id="tem_6" size="2" value="0" style="height:20px;width:30px" >
<div style="display:inline;color:gray" onclick="document.getElementById('tem_6').value=Number(document.getElementById('tem_6').value)-1;">-</div></div>
  
</div>

<!-- side page controllers-->
<div style="position:absolute;top:50vh;left:98vw;width:15px;height:25px;font-size:20px;z-index:50" >
 <div style="display:inline;color:gray" onclick="goToPreviousPage();"  ontouchstart="goToPreviousPage();">🜂</div> <div style="display:inline;color:gray" onclick="goToNextPage();"  ontouchstart="goToNextPage();">🜄</div>   
</div>
 
<div style="position:absolute;top:50vh;left:0;width:15px;height:25px;font-size:20px;z-index:50" >
 <div style="display:inline;color:gray" onclick="goToPreviousPage();"  ontouchstart="goToPreviousPage();">🜂</div> <div style="display:inline;color:gray" onclick="goToNextPage();"  ontouchstart="goToNextPage();">🜄</div>   
</div>



<!--main toolbar area-->
    <div id="main-toolbar">

        <button onclick="document.getElementById('page-manager').style.display=(document.getElementById('page-manager').style.display=='none')?'':'none';document.getElementById('project-manager').style.display=(document.getElementById('project-manager').style.display=='none')?'':'none';">≡</button>
       <div id="project-manager" style="display:" >
        <span id="currentProjectDisplay">classroom_master_file</span> 
        <button onclick="window.saveProject()" title="Save to Cloud" >💾</button>
        <button onclick="window.renderAllProjectsList()" title=" Switch/Create Project" >📂</button>
        <button onclick="importProject()"  title="import" >📥</button>
              <input type="file" id="importFile" accept=".json" style="display: none;" onchange="handleFileImport(event)">           
         <button onclick="exportProject()" title="export"  >📤</button>
         <button onclick="document.all.codeArea.style.display='';document.getElementById('htmlPageCode').value=editor.innerHTML;" title="Coding"  >✍</button>
       </div>
        <div style="border-left: 1px solid #ccc; margin: 0 5px; padding-left: 10px;">
         <button onclick="document.getElementById('teamBoard').style.display=(document.getElementById('teamBoard').style.display=='none')?'':'none';" title="showScoreBoard"  >👨‍👨‍👧‍👧</button>
         </div>
        <div style="border-left: 1px solid #ccc; margin: 0 5px; padding-left: 10px;">
<script>
    /**
     * Sets the zoom level on the document body using CSS transform: scale().
     * @param {number|null} [zoomV=null] - Optional zoom percentage (e.g., 90, 100).
     */
    window.setZoom = function(zoomV = null) {
        let scaleFactor; // The unitless float (e.g., 0.9, 1.0)
        
        // 1. Determine the target zoom value
        if (zoomV !== null) {
            // Use the value passed from the buttons (e.g., 90, 100)
            scaleFactor = zoomV / 100; 
        } else {
            // Use the value from the range input (e.g., 5.0 to 20.0, representing 50% to 200%)
            // Assuming your range values (0.5 to 20) are meant to be multiplied by 10 to get a percentage.
            const rangeValue = parseFloat(document.getElementById('zoom').value);
            // Example: 10 * 10 = 100%. Scale factor = 1.0
            scaleFactor = rangeValue / 10; 
        }

        // 2. Apply the scaling and origin to the body
        const bodyStyle = document.getElementById('editor').style;

        // Set the transform for scaling
        bodyStyle.transform = `scale(${scaleFactor})`;
        
        // Ensure scaling originates from the top left to align with scroll management
        bodyStyle.transformOrigin = 'top left'; 
        
        // Optional: Resetting the zoom property since we prefer transform: scale
        bodyStyle.zoom = '100%'; 

        // Important: You'll likely need to adjust the scroll position here 
        // to implement the "panning" effect you mentioned earlier.
        // For now, this just handles the visual zoom.
// Use this only if the style is NOT set inline (less common for dynamic zooming)
const computedStyle = window.getComputedStyle(editor);
const transformValue = computedStyle.getPropertyValue('transform');

// transformValue will be a matrix string, e.g., "matrix(1.5, 0, 0, 1.5, 0, 0)"
// You'd need a different regex to parse the scale factor from the matrix string.
// Stick to setting and reading the inline style property (editor.style.transform) for simplicity.
    };
</script>



<div>
    🔍
<button 
    id="pan-toggle-btn" 
    onclick="togglePanMode()" 
    class="px-2 py-1 bg-blue-600 text-white text-xs font-semibold rounded-lg hover:bg-blue-700 transition duration-150 shadow-md">
    Toggle Pan Mode
</button>
    <input 
        type="range" 
        id="zoom" 
        min="5" 
        max="15" 
        step="1" 
        value="10" 
        title="Zoom Scale" 
        class="w-20" 
        oninput="setZoom();" 
    >
    
    <button 
        onclick="window.setZoom(90)" 
        class="px-1 py-1 bg-green-600 text-white text-xs font-semibold rounded-lg hover:bg-green-700 transition duration-150 shadow-md">
        90%
    </button>
    <button 
        onclick="window.setZoom(100)" 
        class="px-1 py-1 bg-green-600 text-white text-xs font-semibold rounded-lg hover:bg-green-700 transition duration-150 shadow-md">
        100%
    </button>
</div>
<!--
            <button onclick="window.toggleEditMode();window.toggleEditable();">Toggle Edit</button>
            <button onclick="document.execCommand('bold', false, null)">B</button>
            <button onclick="window.applyForeColor('#0000ff')">Blue Text</button>
-->
        </div>
        
        <div style="border-left: 1px solid #ccc; margin: 0 5px; padding-left: 10px;">
            <button id="toggleGameModeBtn" onclick="window.toggleGameMode();">▶️ 🎮 Game Mode</button>
<div id="tmBar" style="display:none ;position:absolute;z-index:50;top:80px;left:45vw;" onclick="this.style.display='none';" >
    TIME:<span id="gameTimerDisplay" class="text-xl font-mono text-gray-700 p-2 bg-green-400 rounded-lg border border-gray-300">1:00 </span>
</div>
            <span id="speechResult" style="margin-left: 20px;"></span>
 <button onclick="window.toggleGameTheme('quiz');">❓</button>
<button id="toggleQuizBtn" onclick="window.toggleGameTheme('slasher');window.QS_launchGame(document.getElementById('quizArea'),'slasher');window.QS_parseAndLoadQuiz(document.getElementById('quizArea'),'slasher');" title="切水果" >🌠</button>
<button id="startGameButton" title="雙打測驗" onclick="window.toggleGameTheme('dual');">🤼</button>
        </div>
    </div>

    <div id="main-container">
        
        <div id="page-manager" style="display:" >
         <button onclick="window.createNewPage()"class="px-1 py-1 bg-blue-500 text-white font-xssemibold rounded-lg hover:bg-blue-600 transition duration-150 shadow-md">新增頁面</button>
            <ul id="page-list">
                </ul>
        </div>
        
        <div id="editor-wrapper" id="editor-container" style="overflow: auto;"> 
            <div id="editor"  contenteditable="true" style="transform: scale(X); transform-origin: top left;">
<canvas id="drawingCanvas" ></canvas>
                Loading project data from Firestore...            
            </div> 

        </div>
    </div>
    
    <div id="project-list-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000;">
        <div style="background: white; width: 800px; margin: 50px auto; padding: 20px; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.2);">
            <h2 style="margin-top: 0;">專案選單</h2>
            
            &#128161;輸入專案名稱:<input type="text" id="new-project-id-input" placeholder="Enter new project ID or select below" style="width: 50%; padding: 10px; margin-bottom: 15px; box-sizing: border-box;border:2px dotted gray">
            <button onclick="window.switchProjectAndCloseList(document.getElementById('new-project-id-input').value)" style="padding: 8px 15px; margin-right: 10px;background-color:cyan;border-radius:8px;border:1px solid black">新增專案</button>
            <button onclick="document.getElementById('project-list-modal').style.display = 'none';background-color:pink;border-radius:8px;border:1px solid black">Cancel</button>

            <hr style="margin: 15px 0;">
            <div id="all-projects-list" style="max-height: 400px; overflow-y: auto;">
                </div>
        </div>
    </div>

    <div   id="codeArea" style="display:none;">
        <button onclick="document.all.codeArea.style.display='none'; " title="close"  >❎</button>
            <input type="text" id="fname" value="default_file.json">
          <button onclick="document.all.codeArea.style.display=''; editor.innerHTML=document.getElementById('htmlPageCode').value;" title="export"  ><b>✅</b></button>
        <div id="pagelist"></div>
        <div id="Navi"></div>
      <textarea id="htmlPageCode" cols="150" rows="10" style="display:;border:1px dashed green" > </textarea>
         
        <textarea  id="temp"   ></textarea>
        <img id="coverpic" src="">
         
    </div>










  <div id="toolbar"  style="position:;z-index:50;left:20px;top:88vh;justify-content: center;align-items: center;" class="flex flex-wrap items-center gap-2 p-3 bg-gray-50 rounded-lg border border-gray-200 mb-4">
 

















  <!-- Teacher Backstage Editing-->


    
            <button  title="切換編輯工具列" onclick="document.getElementById('styleControls').style.display=(document.getElementById('styleControls').style.display=='none')?'inline':'none';document.getElementById('MyTittle').style.display='';DesignMode=!DesignMode;this.innerText=(DesignMode)?'📝設計模式':'✔️白板模式';document.getElementById('toolbar').style.position=(document.getElementById('toolbar').style.position='absolute')?'':'absolute';"   style="display:inline;font-size:15px" class=" gap-2 p-2 rounded-lg border border-gray-200 ">✔️白板模式</button>




           <!-- Drawing Controls -->
 


<span  id="DWpentool" onclick="" style="position:relative;width:40px;font-size:20px" class="mx-2 text-gray-400 rounded-lg hover:bg-purple-600  shadow-md">✒️
            <span  id="DWpentool_menu" style="display:none;position:absolute;top:-10px;left:250px;z-index:30;width:900px;background:white;border-radius:16px;border:2px solid gray;padding:4px"    > 




     <div class="flex items-center space-x-2">
                    <button id="stopDrawingBtn" onclick="window.setDrawingMode('none');" class="p-2 rounded-full bg-gray-100 border transition hover:bg-gray-200" title="Eraser Tool">
	        🖱️
                    </button>
                    <button id="pen-tool" class="p-2 rounded-full bg-gray-100 border transition hover:bg-gray-200" title="Pen Tool">
                        <svg class="w-6 h-6 text-gray-800" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z"></path></svg>
                    </button>

                    <button id="eraser-tool" class="p-2 rounded-full bg-gray-100 border transition hover:bg-gray-200" title="Eraser Tool">
                        🧽
                    </button>

                    <label for="pen-color" class="flex items-center ring-2 ring-gray-300 rounded-full transition duration-200">
                        <input type="color" id="pen-color" value="#FF0000" class="w-8 h-8 rounded-full border-none p-0 cursor-pointer">
                    </label>
             <span onclick="window.setPenColor('black')" style="color:black;padding:1px;font-size:30px">■</span><span onclick="window.setPenColor('blue')" style="color:blue;padding:1px;font-size:30px">■</span><span onclick="window.setPenColor('green')" style="color:green;padding:1px;font-size:30px">■</span>
                
                <!-- Size and Action Buttons -->
                <div class="flex items-center space-x-3">
                    <label for="pen-size" class="text-gray-600 font-medium whitespace-nowrap">Size: <span id="size-display" class="font-bold text-green-600">5</span>px</label>
                    <input type="range" id="pen-size" min="1" max="50" value="5" class="w-24 md:w-32 cursor-pointer appearance-none bg-gray-200 rounded-lg h-2 [&::-webkit-slider-thumb]:appearance-none [&::-webkit-slider-thumb]:w-4 [&::-webkit-slider-thumb]:h-4 [&::-webkit-slider-thumb]:bg-green-600 [&::-webkit-slider-thumb]:rounded-full">
                </div>
                
                <div class="flex items-center space-x-3">
                    <button id="clear-canvas-button" class="bg-blue-200 hover:bg-red-600 text-black font-semibold py-2 px-3 rounded-lg text-xl transition shadow">
                        🗑
                    </button>
	</div >
</div > 





         </span><!--pentool_menu-->
</span>  <!--pentool-->






            <!-- Style Controls - Border Radius -->
            <div id="styleControls" style="display:none;" class="flex flex-wrap items-center gap-2 p-3 bg-gray-50 rounded-lg border border-gray-200 mb-4">


<span style="display:inline">
            <select id="addElementType" onchange="window.addNewTextElement(this.value)"  class="px-1 py-1 bg-blue-500 text-white font-xssemibold rounded-lg hover:bg-blue-600 transition duration-150 shadow-md cursor-pointer">
                <option value="" disabled selected class="bg-gray-700 text-white">插入文字</option>
                <option value="P" class="bg-white text-gray-800">一般文字</option>
                <option value="H1" class="bg-white text-gray-800">黑框字</option>
                <option value="H2" class="bg-white text-gray-800">光暈字</option>
                <option value="H3" class="bg-white text-gray-800">陰影字</option>
                <option value="Animateout" class="bg-white text-gray-800">動畫字</option>
                <option value="Hinter" class="bg-white text-gray-800">答案選項</option>
                <option value="DropMenu" class="bg-white text-gray-800">隱藏內文</option>
                <option value="Poke" class="bg-white text-gray-800">撲克牌</option>
                <option value="TTS" class="bg-white text-gray-800">報讀文字</option>
                <option value="VRS" class="bg-white text-gray-800">聽讀文字</option>
                <option value="Quiz" class="bg-white text-gray-800" >測驗題庫</option>
            </select></span>








<button id="textStyle" onclick="" style="border:2px solid black;width:30px;font-size:18px" > T </button> 

<div id="textStyle_menu" style="display:none;position:absolute;top:80vh;left:40px;padding:10px;background:white;border:2px solid gray;border-radius:16px;z-index:31;width:800px;height:60px;" >
<span  title="關閉" onclick="document.getElementById('textStyle_menu').style.display='none';"  style="color:gray;cursor:hand;font-size:26px;font-weight:bolder;margin-left:10px;font-size:20px;" >🗷</span>

 <button id="editToggleBtn"  title="啟用/停用-編輯文字區塊" onclick="window.toggleContentEditable();" disabled class="px-2 py-1 bg-teal-500 text-white font-semibold rounded-lg hover:bg-yellow-500 transition duration-150 shadow-md">編輯文字區塊</button>
                <button onclick="runTextCommand('bold')" title="粗體" class="px-2 py-1 text-gray-700 bg-white border border-gray-300 rounded-lg hover:bg-gray-100">B</button>
                <button onclick="runTextCommand('italic')" title="斜體" class="px-2 py-1 text-gray-700 bg-white border border-gray-300 rounded-lg hover:bg-gray-100">I</button>
                <button onclick="runTextCommand('underline')" title="底線" class="px-2 py-1 text-gray-700 bg-white border border-gray-300 rounded-lg hover:bg-gray-100">U</button>
                
                <!-- formatBlock dropdown removed -->
                
                <input type="color" id="fontColor" onchange="setFontColor()"  onblur="setFontColor()" title="文字色彩" value="#1f2937" class="h-5 w-10 border-none">
                
                <!-- Font Size Dropdown (functional) -->
                <select id="fontSize" onchange="setFontSize()" title="字體大小(1-7)"  style="border:1px solid lightgray;padding:2px;border-radius:6px">
                    <option value="1">Size 1</option>
                    <option value="2">Size 2</option>
                    <option value="3" selected>Size 3</option>
                    <option value="4">Size 4</option>
                    <option value="5">Size 5</option>
                    <option value="6">Size 6</option>
                    <option value="7">Size 7</option>
                </select>
                
		<select id="fontSelector" onchange="changeFont()" style="border:1px solid lightgray;padding:2px;border-radius:6px">
		  <option value="Arial">Arial</option>
		  <option value="Verdana">Verdana</option>
		  <option value="Times New Roman">Times New Roman</option>
		  <option value="Courier New">Courier New</option>
		  <option value="Comic Sans MS">Comic Sans MS</option>
		  <option value="Pacifico">Pacifico</option>
		  <option value="Microsoft JhengHei">微軟正黑體</option>
		  <option value="DFKai-SB">標楷體</option>
		  <option value="PMingLiU">新細明體</option>
		  <option value="cwTeXYen (Chinese Traditional)">圓體字體</option>

		</select>





                <button  title="插入超連結" onclick="window.insertLink()" title="Insert Link" class="px-2 py-2 text-gray-700 bg-white border border-gray-300 rounded-lg hover:bg-gray-100">🔗</button>
                <button  title="移除超連結" onclick="window.removeLink()" title="Remove Link" class="px-2 py-2 text-gray-700 bg-white border border-gray-300 rounded-lg hover:bg-gray-100">🚫</button>

</div>


  <!-- Text Formatting Controls (only for inline styles now) --> 




     
<!-- add dropmenu -->
            <button id="add"  title="插入" onclick=""   style="display:inline;font-size:15px" class=" gap-2 p-2 rounded-lg border border-gray-200 ">➕🖼️</button>		


<!-- add menu -->
<div id="add_menu" style="display:none;position:absolute;top:90vh;left:40px;width:98vw;z-index:30" class="flex flex-wrap items-center gap-2 p-3 bg-gray-50 rounded-lg border border-gray-200 mb-4 ">

<span  title="關閉" onclick="document.getElementById('add_menu').style.display='none';"  style="color:gray;cursor:hand;font-size:26px;font-weight:bolder;margin-left:10px;font-size:20px;z-index:30" >🗷</span>


<button  title="用網址貼上浮動圖片" onclick="window.addDivWithImageBackgroundElement()" class="px-2 py-1 bg-teal-100 text-white font-semibold rounded-lg hover:bg-teal-200 transition duration-150 shadow-md" style="background:darkblue;">用網址貼上(浮動圖片)</button>
<span style="display:inline" >網址:<input type="text" id="Xurl" value="" size="20" onchange="" style="border:dashed 1px lightgray"></span>
<span onclick="document.getElementById('Xurl').value='';" alt="套用網址套用網址"  style="display:inline;cursor:hand">❎</span>
<span onclick="window.updateBackground()"    class="hover:bg-teal-600 cursor-hand">✔️更新</span>


<button  title="用網址貼上浮動圖片" onclick="window.insertCode('iframe')" class="px-2 py-1 bg-red-500 text-white font-semibold rounded-lg hover:bg-teal-200 transition duration-150 shadow-md"  >用網址貼上YouTube</button>

<button  title="用網址貼上浮動圖片" onclick="window.insertCode('img');" class="px-2 py-1 bg-green-500 text-white font-semibold rounded-lg hover:bg-teal-200 transition duration-150 shadow-md"  >用網址貼上(固定圖片)</button>           
 
    <button  title="從圖庫插入" onclick="addDivWithImageBackgroundElement();document.all.picker.style.display='';"  style="background:cyan;border-radius:25%" >圖庫</button>
            <!-- NEW: Add Text Element Dropdown -->


<!-- add menu -->
</div>



<button id="layerControl" onclick="" style="position:" >💳圖層樣式</button>

<div id="layerControl_menu"  style="display:none;position:absolute;z-index:30;top:95vh;left:20px;padding:10px;width:100%px;background:lightgray;border:2px solid gray;border-radius:16px;color:black;font-size:12px;vertical-align:center;opacity:50" >

<span  title="關閉" onclick="document.getElementById('layerControl_menu').style.display='none';"  style="color:gray;cursor:hand;font-size:26px;font-weight:bolder;margin-left:10px;font-size:20px;" >🗷</span>
		背景:
<img src="" id="bgicon" alt="Background Preview" width="40" height="40" style="border:2px solid gray;display:inline" onclick="document.getElementById('add_menu').style.display=(document.getElementById('add_menu').style.display=='none')?'inline':'none';">
                底色:<input type="color" id="backgroundColor" onchange="window.setBackgroundColor()" title="底色" value="#ffffaa" class="h-5 w-10 border-none">
<span  title="透明" onclick="window.setBackgroundColor('t')"  style="color:red;cursor:hand;font-size:20px;" >🗷</span>
                
                圓角:
                <input type="range" id="borderRadius" oninput="window.setBorderRadius()" min="0" max="50" value="0" title="Border Radius" class="w-20">

                透明度:
                <input type="range" id="elementOpacity" min="0" max="100" value="100" title="Element Opacity" oninput="window.setElementOpacity(this.value)"  class="w-20">
<button onclick="window.flip();" title="flip" class="px-3 py-2 text-gray-700 bg-white border border-gray-300 rounded-lg hover:bg-gray-100">flip</button>
    <button onclick="window.turn(-15)" title="Turn Left 15 Degrees" class="px-3 py-2 text-gray-700 bg-white border border-gray-300 rounded-lg hover:bg-gray-100">↺ 15°</button>
 <span id="angl" ></span>
<input type="range" id="rotateAngle" oninput="window.setRotation(this.value);document.getElementById('angl').textContent=this.value" min="0" max="359" step="1" value="0" title="旋轉" class="w-20 h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
    <button onclick="window.turn(15)" title="Turn Right 15 Degrees" class="px-3 py-2 text-gray-700 bg-white border border-gray-300 rounded-lg hover:bg-gray-100">↻ 15°</button>           

<!--
    <button onclick="window.rotateElement(-5)" title="Turn Left 15 Degrees" class="px-3 py-2 text-gray-700 bg-white border border-gray-300 rounded-lg hover:bg-gray-100">↺ 15°</button>
           <button onclick="window.rotateElement(5)" title="Turn Right 15 Degrees" class="px-3 py-2 text-gray-700 bg-white border border-gray-300 rounded-lg hover:bg-gray-100">↻ 15°</button>
-->
</span>


    <label for="borderColor">框色:</label>

<input type="color" id="borderColor" onchange="window.applyBorderChanges()" title="框色" value="#ffffaa" class="h-5 w-10 border-none">
    <label for="borderWidth">粗細:</label>
    <select id="borderWidth" onchange="window.applyBorderChanges()">
        <option value="1px">1px</option>
        <option value="2px">2px</option>
        <option value="5px">5px</option>
        <option value="10px">10px</option>
    </select>

    <label for="borderStyle">樣式:</label>
    <select id="borderStyle" onchange="window.applyBorderChanges()">
        <option value="solid">____</option>
        <option value="dashed">------</option>
        <option value="dotted">..........</option>
        <option value="double">=====</option>
    </select>
| <button  title="頁面背景" onclick="window.dobg();" >設為頁面底色</button>| <button  title="頁面背景" onclick="window.dobg('bk');" >更換頁面底圖</button>
</div>





<span   id="idop"  onclick=""   class="flex flex-wrap text-s items-center hover:bg-yellow-100 cursor-hand  rounded-lg border border-gray-200 " style="position:relative;width:80px;height:40px;display:inline" >
		🗃️圖卡設定
            <span id="idop_menu" style="display:none;position:absolute;left:10px;top:-120px;width:640px;height:120px;font-size:18px;background:white;border:2px solid gray;z-index:30;padding:10px;border-radius:15px">
<span  title="關閉" onclick="document.getElementById('idop_menu').style.display='none';"  style="color:gray;cursor:hand;font-size:26px;font-weight:bolder;margin-left:10px;font-size:20px;" >🗷</span>
<span style="display:inline;font-color:blue;" >英文名稱:
<span onclick="window.applyMyInfo();"    class="hover:bg-teal-600 cursor-hand" style="cursor:hand;border:2px solid black;background:yellow" >✔️套用</span>
<input type="text" id="MyID" value="" size="16" color="blue" style=";border:dashed 1px lightgray;padding-left:2px"></span>
<span onclick="document.getElementById('MyID').value=document.getElementById('MyID').value+'-a';applyMyID();"   onmouseover="dropmenu('hintx')" style="position:relative" >❔<font id="hintx" style="display:none;position:absolute;top:-80px;left:0px;width:550px;height:100px;background:lightyellow;border:2px dashed brown" >會在「圖片閃示卡」功能中顯示輸入的名稱，例如:cat<BR>，如果和別的圖同名稱綴加"-a"的話，例如:cat-a，彼此接觸時會有配對反應</font></span>


<HR>
<span style="display:inline" >輸入說明:
<span onclick="window.applyMyInfo();"    class="hover:bg-teal-600 cursor-hand"  style="cursor:hand;border:2px solid black;background:yellow" >
✔️套用</span>

<textarea id="MyInfo"   cols="40"  style="border:dashed 1px lightgray;padding-left:2px"></textarea>
</span>

           </span></span>






            <span class="mx-2 text-gray-400">|</span>
<button onclick="window.undo()" class="px-4 py-2 bg-gray-100 text-white font-semibold rounded-lg hover:bg-green-600 transition duration-150 shadow-md" id="undoBtn" disabled title="復原上一步Undo (Ctrl+Z)">↩️</button>
            <button onclick="window.redo()" class="px-4 py-2 bg-gray-100 text-white font-semibold rounded-lg hover:bg-green-600 transition duration-150 shadow-md" id="redoBtn" disabled title="重作上一步Redo (Ctrl+Y)">↪️</button>
            
<span class="mx-2 text-gray-400">|</span>
<button onclick="window.duplicateActiveItem()" >再製</button>|<button onclick="window.pasteClone();" >貼上物件</button>
 




<select id="addAnimateType" onchange="window.toggleAnimate(this.value)"  class="px-1 py-1 bg-blue-500 text-white font-xssemibold rounded-lg hover:bg-blue-600 transition duration-150 shadow-md cursor-pointer" style="display:inline;width:">
                <option value="" disabled selected class="bg-gray-700 text-white">動畫</option>

                <option value="animate-spin"  class="bg-gray-700 text-white">旋轉</option>
                <option value="animate-bounce"  class="bg-gray-700 text-white">彈跳</option>

                <option value="animate-ping"  class="bg-gray-700 text-white">放大</option>
                <option value="animate-pulse"  class="bg-gray-700 text-white">閃爍</option>
                <option value="animate-none"  class="bg-gray-700 text-white">無</option>
                <option value="translate-y-full  transition-all duration-700 ease-out "  class="bg-gray-700 text-white">沖天</option>
                <option value="skewed-title"  class="bg-gray-700 text-white">立體字</option>
 
      <!-- 		//####-translate-x-full  translate-x-0 -translate-y-80 ,'-translate-y-80'
		//###animate-none .animate-ping animate-pulse animate-spin  animate-bounce animate-spin .animate-bounce
       -->
</select>






 <!-- 文字編輯區 -->
              </div>



<div style="display:inline;width:45px;height:45px;font-size:20px;z-index:50;border:2px dotted gray;padding:0px;line-height: 80%;"  >
  <span onclick="window.addNewTextElement('sticker','yellow');"  style="color:yellow; display:inline;margin:2px" >■</span>
 <span onclick="window.addNewTextElement('sticker','pink');"   style="color:pink; display:inline;margin:2px; " >■</span>
  <span onclick="window.addNewTextElement('sticker','cyan');"  style="color:cyan; display:inline;margin:2px; " >■</span>
 <span onclick="window.addNewTextElement('sticker','lightgreen');"   style="color:lightgreen; display:inline;margin:2px; " >■</span>
</div>  

            <!-- Layer, Lock, Delete Controls -->       
<button onclick="window.deleteSelectedItem()" title="刪除選取物件" class="px-2 py-1 bg-red-500 text-white font-semibold rounded-lg hover:bg-red-600 transition duration-150 shadow-md">❎</button>

            <button onclick="window.bringForward()" title="上移圖層" class="px-3 py-2 text-gray-700 bg-white border border-gray-300 rounded-lg hover:bg-gray-100">⇧</button>
            <button onclick="window.sendBackward()" title="下移圖層" class="px-3 py-2 text-gray-700 bg-white border border-gray-300 rounded-lg hover:bg-gray-100">⇩</button>
<!-- Page Navigator -->
            <button id="lockToggleBtn" onclick="window.toggleLock()"  title="固定或解鎖位置" class="px-2 py-2 bg-yellow-500 text-white font-semibold rounded-lg hover:bg-yellow-600 transition duration-150 shadow-md">🔏固定/浮動🔒</button>

 <div style="display:inline;color:gray;font-size:30px" onclick="window.goToPreviousPage();"  ontouchstart="window.goToPreviousPage();">⬅️</div> <div style="display:inline;color:gray;font-size:30px" onclick="window.goToNextPage();"  ontouchstart="window.goToNextPage();">➡️</div>   


 



  <button onclick="FullScreen()"><font size="6" title=="全螢幕">💻</font></button>
		<button onclick="window.PicNav()">	<font size="6" title=="閃示卡" >🖼️</font></button>       <button onclick="window.textSlider()"><font size="6" title=="動畫" >📽️</font></button>
<button onclick="window.pickNumber();" style="font-size:12px;border:2px solid gray;border-radius:12px;padding:2px"  id="pickBtn"> 🙋‍♂️</button>
<button onclick="document.getElementById('picker-wrapper').classList.remove('hidden');" style="font-size:12px;border:2px solid gray;border-radius:12px;padding:2px"  id="rstBtn"> ⚙</button><button onclick="window.insertDice();" style="font-size:25px" > 🎲</button>
<button onclick="alert('wtf');alert(document.getElementById('htmlPageCode').value);window.restore();"  title=="還原頁面" style="font-size:25px" >♻</button>
<button onclick="window.dartMode();"  id="dartModeBtn" title="遊戲模式" style="font-size:20px" >🎯on</button>





<div id="voiceGameControls" class="flex flex-col items-center gap-1 p-1 font-xs bg-yellow-50 rounded-lg shadow-inner"  >
    <button id="voiceButton" onclick="window.startRandomVoiceGame();document.getElementById('speechResult').style.display='';" 
            title="語音辨識Start Random Voice Recognition Game" 
            class="px-4 py-2 bg-yellow-500 text-white font-semibold rounded-lg hover:bg-yellow-600 transition duration-150 shadow-md">
        🎙️  ▶️
    </button>
    <div id="OLDspeechResult" class="text-sm font-medium text-gray-500"     ontouchstart="this.style.display='none';" onclick="this.style.display='none';"   style="position:absolute;z-index:50;top:40px;left:100px;width:90%;height:80px;background:white;border-radius:16px;border:2px gray solid;padding:10px;font-size:30px;opacity:0.9;display:none">
        Click to start recognizing words by item ID.
    </div>
</div>

<div id="gameModeControls" class="flex flex-wrap items-center gap-2">

    <button id="toggleGameModeBtn" onclick="window.toggleGameMode();speakText('get'+window.randomItem());" 
            title="Start Continuous Background Animation" 
            class="px-4 py-2 bg-green-500 text-white font-semibold rounded-lg hover:bg-green-600 transition duration-150 shadow-md">
        ▶️ 🎮
    </button>
<button onclick="window.animateAllRandomly(parseFloat(document.getElementById('goToTime').value))" 
            title="Animate all items to random locations" 
            class="px-4 py-2 bg-purple-500 text-white font-semibold rounded-lg hover:bg-purple-600 transition duration-150 shadow-md">
       💢散開
    </button>
</div>



<span class="mx-2 text-gray-400" onclick="document.getElementById('movementControls').style.display=(document.getElementById('movementControls').style.display=='none')?'':'none';" >🕹️</span>

<div id="movementControls"  style="position:absolute;z-index:30;width:90%;height:30px;top:80vh;left:10px;display:none;background:white;border-radius:16px" >
<span  title="關閉" onclick="document.getElementById('movementControls').style.display='none';"  style="color:gray;cursor:hand;font-size:26px;font-weight:bolder;margin-left:10px;font-size:30px;" >🗷</span>


<button onclick="window.moveSteps(-100)" title="Move backward 10 Steps" class="px-4 py-2 bg-pink-500 text-white font-semibold rounded-lg hover:bg-pink-600 transition duration-150 shadow-md">🚶‍⬅️</button>
    <button onclick="window.moveSteps(100)" title="Move Forward 10 Steps" class="px-4 py-2 bg-pink-500 text-white font-semibold rounded-lg hover:bg-pink-600 transition duration-150 shadow-md">🕺➡️</button>    
    <button onclick="window.turn(-15)" title="Turn Left 15 Degrees" class="px-3 py-2 text-gray-700 bg-white border border-gray-300 rounded-lg hover:bg-gray-100">↺ 15°</button>
    <button onclick="window.turn(15)" title="Turn Right 15 Degrees" class="px-3 py-2 text-gray-700 bg-white border border-gray-300 rounded-lg hover:bg-gray-100">↻ 15°</button>
    
    <button onclick="window.pointInDirection(0)" title="Point Up" class="px-3 py-2 text-gray-700 bg-white border border-gray-300 rounded-lg hover:bg-gray-100">🕛</button>
<button onclick="window.pointInDirection(90)" title="Point Right/Forward" class="px-3 py-2 text-gray-700 bg-white border border-gray-300 rounded-lg hover:bg-gray-100">🕒</button>


<span class="mx-2 text-gray-400">|</span>


 
    
    <button onclick="window.goTo(document.getElementById('goToTarget').value);" title="Go To Custom Position" class="px-4 py-2 bg-indigo-500 text-white font-semibold rounded-lg hover:bg-indigo-600 transition duration-150 shadow-md">Go To</button>
    <button onclick="window.goTo('center')" title="Go To Center" class="px-3 py-2 bg-indigo-500 text-white font-semibold rounded-lg hover:bg-indigo-600 transition duration-150 shadow-md">Center</button>
 
<span class="mx-2 text-gray-400">|</span>



<span class="mx-2 text-gray-400">🎮</span>
 java go to
    <input type="text" id="goToTarget" placeholder="X,Y or Element ID" class="w-32 p-2 border border-gray-300 rounded-lg text-sm">
    
    <input type="number" id="goToTime" value="1" min="0.1" step="0.1" title="Time (seconds)" class="w-16 p-2 border border-gray-300 rounded-lg text-sm text-center">
    
    <button onclick="window.glideTo(document.getElementById('goToTarget').value, parseFloat(document.getElementById('goToTime').value))" 
            title="Animate Go To Custom Position" 
            class="px-4 py-2 bg-indigo-500 text-white font-semibold rounded-lg hover:bg-indigo-600 transition duration-150 shadow-md">
        Slide To
    </button>
    
    <button onclick="window.glideTo('center', parseFloat(document.getElementById('goToTime').value))" 
            title="Animate Go To Center" 
            class="px-3 py-2 bg-indigo-500 text-white font-semibold rounded-lg hover:bg-indigo-600 transition duration-150 shadow-md">
        Center
    </button>
 


</div><!-- end movementControl menu-->












            <!-- Final Action -->
           

        </div>


 












    <script type="module">
        // Import Firebase v12 SDKs. Including getDocs, collection, and deleteDoc.
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.3/firebase-app.js";
        import { getFirestore, doc, setDoc,getDoc, onSnapshot, collection, getDocs, deleteDoc } from "https://www.gstatic.com/firebasejs/10.12.3/firebase-firestore.js";
//import { getFirestore, collection, getDocs, setDoc, deleteDoc } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore.js";
        // --- 1. FIREBASE CONFIGURATION ---
        const firebaseConfig = {
            apiKey: "AIzaSyA-psoCWI_u2iYoLXznb6kH_g3KTw00Qow",
            authDomain: "myebook-183ee.firebaseapp.com",
            projectId: "myebook-183ee",
            storageBucket: "myebook-183ee.firebasestorage.app",
            messagingSenderId: "531804725153",
            appId: "1:531804725153:web:469ed0e5ded02f72fcb5e0",
        };

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        
        // Firestore Constants
        const PROJECTS_COLLECTION = 'editor_projects'; 
        
        // --- 2. GLOBAL STATE ---
        const editor = document.getElementById('editor');
        const storageKey = 'canvasEditorProject'; 
        
        // Multi-Project Variable (DEFAULT ID)
        let currentProjectDocumentId = 'classroom_master_file'; 
        //let currentProjectDocumentId = 'NewProjcet';         
        // Core Project Data
        let projectData = []; 
        let currentPageId = null;
        
        // Existing Global Variables from your code
        let DesignMode = false;
        let gameTarget = "";
        let gameMode = false;
        let score = 0;
        let quizCount = 0;
        let checkMode = true; 
        let gameTimerInterval = null;
        const GAME_DURATION_SECONDS = 60;
        let recognition = null; 
        let requiredWord = '';
        let counter = 0; 
        let activeItem = null; // CRITICAL: This needs to be set by your drag/drop handlers
        let oldX = 0, oldY = 0; // Assuming these are used by drag/drop
 
       // --- Globals ---
         const editToggleBtn = document.getElementById('editToggleBtn');
        const lockToggleBtn = document.getElementById('lockToggleBtn');

	let isPanModeActive = false;
	 
	 

	// Get the element that acts as the scroll container (usually the body)
	const scrollContainer = document.body;


// --- NEW: Gesture State Variables ---
        let touchStartX = 0;
        let touchStartY = 0;
        //let isSwiping = false;
        const SWIPE_THRESHOLD = 80; // 判斷為有效滑動的最小水平距離 (pixels)
 // --- End of Gesture State Variables ---



// ADD THESE CRITICAL DRAG/RESIZE VARIABLES:
let isDragging = false; 
let isResizing = false;
let isSwiping = false; // Used in handleStart
let startX = 0;
let startY = 0;
let startLeft = 0;
let startTop = 0;
let startWidth = 0;
let startHeight = 0;
const lastClickPos = { x: 100, y: 100 }; // Used in handleStart

// ====================================================================
// GLOBAL/MODULE VARIABLES (PLACE AT THE TOP OF YOUR SCRIPT)
// ====================================================================

// --- Editor State ---
let initialX, initialY, initialWidth, initialHeight;

let isInitialLoad = true; // CRITICAL for Firebase stability

// --- Drawing & Canvas State ---

 let context = null;
let fillColorInput = null;
let penColorInput = null;
let lineWidthInput = null;
let currentDrawMode = 'stroke'; // 'stroke', 'fill', or 'stroke-fill'
let currentTool = null; // 'pen', 'line', 'rect', 'circle', 'arrow', 'eraser'
let isDrawing = false;
let drawStartX, drawStartY;

// Temporary canvas for drawing shapes (avoids flashing)
const tempCanvas = document.createElement('canvas');
const  tempCtx = tempCanvas.getContext('2d');
tempCanvas.id = 'tempCanvas';

let gameTheme=0;
        // --- 3. FIREBASE/PROJECT DATA MANAGEMENT ---
        
        /** Real-time Listener: Loads initial data and keeps projectData synced. */
 // Ensure this variable is defined outside the function, at the module scope
 
 isInitialLoad = true; // Define this globally or in the module scope

function startRealtimeProjectListener() {
    document.getElementById('currentProjectDisplay').textContent = currentProjectDocumentId;

    const projectRef = doc(db, PROJECTS_COLLECTION, currentProjectDocumentId);
    
    const projectListenerUnsubscribe = onSnapshot(projectRef, (docSnapshot) => {
        
        // --- 1. HANDLE DATA RECEIVED (SUCCESS PATH) ---
        if (docSnapshot.exists() && docSnapshot.data().pages) {
            const serverData = docSnapshot.data();
            const newProjectData = serverData.pages;

            // Protection: If the data structure is corrupt, stop here but keep the old data.
            if (!Array.isArray(newProjectData)) {
                console.warn("Server data structure is corrupt (pages is not an Array). Ignoring update.");
                return; 
            }
            
            projectData = newProjectData;
            
            // Logic to handle an empty project data array
            if (projectData.length === 0) {
                 // CRITICAL: Only initialize a blank project if it's the first time loading.
                 // This assumes a user wouldn't idle for 5 minutes and THEN load an empty project.
                 if (isInitialLoad) { 
                     initializeBlankProject();
                 } else {
                     // If it becomes empty later, assume the user cleared it, 
                     // but DON'T initialize a new one automatically during a sync.
                     // The user needs to manually add the first page.
                     console.log("Project list is empty after initial load. Awaiting user action.");
                 }
            }
            
            // Logic to switch page if the current one was deleted (always safe)
            const currentExists = projectData.some(p => p.id === currentPageId);
            if (!currentExists && projectData.length > 0) {
                currentPageId = projectData[0].id;
            }
            
            loadPageData(currentPageId);
            renderPageList();
            
            // Set flag to false after first successful data fetch
            isInitialLoad = false; 
            console.log("Project data synced from Firestore.");

        // --- 2. HANDLE DOCUMENT NOT FOUND (ERROR PATH) ---
        } else if (!docSnapshot.exists()) {
            
            if (isInitialLoad) {
                console.log(`Document '${currentProjectDocumentId}' not found. Initializing blank project.`);
                initializeBlankProject();
                isInitialLoad = false;
            } else {
                 // CRITICAL: The document disappeared AFTER a successful load.
                 // This is the common sign-out/session-expiry issue. DO NOT clear data.
                 console.warn("Document disappeared after initial load. Stopping action to protect local state.");
            }
        }
    }, (error) => {
        // --- 3. HANDLE LISTENER FAILURE (CONNECTION ERROR PATH) ---
        console.error("Firestore listener error (Connection Loss): ", error);
        // This runs on actual connection failure. Using local storage as backup is correct here.
        loadProjectFromLocalStorage(); 
    });
}













         window.exportProject=function() {
            saveCurrentPageData(); // Ensure the current page is saved before export
            const jsonContent = JSON.stringify(projectData, null, 2);
            const blob = new Blob([jsonContent], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            //a.download = 'editor-project.json';
            a.download = document.getElementById('fname').value;
            a.click();
            URL.revokeObjectURL(url);
        }

        window.importProject=function() {
            document.getElementById('importFile').click();
        }

       window.handleFileImport=function(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importedData = JSON.parse(e.target.result);
                    if (typeof importedData !== 'object' || importedData === null) {
                        throw new Error("Invalid format");
                    }
                    projectData = importedData;

  
                    currentPageId = Object.keys(projectData)[0] || null;
                    saveProject(); // Save the newly imported project to localStorage
                    renderPageList();
                    if (currentPageId) {
                        loadPageData(currentPageId);
                    }
                } catch (error) {
                    alert("Error: Could not import file. Please ensure it's a valid project JSON.");
                    console.error("Import failed:", error);
                }
            };
            
            reader.readAsText(file);
            event.target.value = ''; // Reset file input
        }














        /** Saves the current projectData array to Firestore. */
        window.saveProject = async function() {
            saveCurrentPageData();
            
            if (projectData.length === 0) return;

            const dataToSave = {
                pages: projectData,
            };

            try {
                const projectRef = doc(db, PROJECTS_COLLECTION, currentProjectDocumentId);
                await setDoc(projectRef, dataToSave);
                console.log("Project successfully saved to Firestore!");
	showModal(storageKey + '-' + currentProjectDocumentId,'已儲存:');
	//alert('儲存完成');
                localStorage.setItem(storageKey + '-' + currentProjectDocumentId, JSON.stringify(projectData)); 

            } catch (error) {
                console.error("Error writing document to Firestore: ", error);
	showModal('寫入錯誤','error');
            }
        }
        
        // --- Multi-Project Listing & Management Functions ---

        /** Fetches all document IDs and renders the list in the modal. */
        window.OLDrenderAllProjectsList = async function() {
            const listContainer = document.getElementById('all-projects-list');
            listContainer.innerHTML = 'Loading saved projects...';
            
            // Pre-fill the input field with the current ID
            document.getElementById('new-project-id-input').value = currentProjectDocumentId;

            try {
                const querySnapshot = await getDocs(collection(db, PROJECTS_COLLECTION));
                
                let html = '<ul style="list-style:none; padding:0;">';
                
                if (querySnapshot.empty) {
                    html += '<li style="padding: 10px; color: gray;">No saved projects found.</li>';
                } else {
                    querySnapshot.forEach((doc) => {
                        const projectId = doc.id;
                        const isActive = projectId === currentProjectDocumentId;
                        const status = isActive ? ' (ACTIVE)' : '';
                        
                        html += `<li style="display: flex; justify-content: space-between; align-items: center; padding: 10px; margin-bottom: 5px; border: 1px solid #ddd; border-radius: 4px; background: ${isActive ? '#e6f3ff' : '#fff'};">
                                    <span 
                                        onclick="window.switchProjectAndCloseList('${projectId}')" 
                                        style="cursor:pointer; flex-grow: 1; color: ${isActive ? '#007bff' : '#333'}; font-weight: ${isActive ? 'bold' : 'normal'};"
                                    >
                                        ${projectId}${status}
                                    </span>
                                    
                                    <button 
                                        onclick="window.deleteProject('${projectId}')" 
                                        style="margin-left: 10px; background: #f87171; color: white; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer;"
                                        title="Permanently delete this project"
                                    >
                                        🗑️ Delete
                                    </button>
                                </li>`;
                    });
                }
                html += '</ul>';
                
                listContainer.innerHTML = html;
                
                // Show the modal
                document.getElementById('project-list-modal').style.display = 'block';

            } catch (error) {
                listContainer.innerHTML = 'Error loading projects: Check console for details.';
                console.error("Error fetching project list:", error);
            }
        }



// --- Multi-Project Listing & Management Functions ---

/** Fetches all document IDs and renders the list in the modal, including management buttons. */
window.renderAllProjectsList = async function() {
    const listContainer = document.getElementById('all-projects-list');
    listContainer.innerHTML = 'Loading saved projects...';
    
    // Pre-fill the input field with the current ID
    document.getElementById('new-project-id-input').value = currentProjectDocumentId;

    try {
        const querySnapshot = await getDocs(collection(db, PROJECTS_COLLECTION));
        
        let html = '<ul style="list-style:none; padding:0;">';
        
        if (querySnapshot.empty) {
            html += '<li style="padding: 10px; color: gray;">No saved projects found.</li>';
        } else {
            querySnapshot.forEach((doc) => {
                const projectId = doc.id;
                const isActive = projectId === currentProjectDocumentId;
                const status = isActive ? ' (ACTIVE)' : '';
                
                html += `<li style="display: flex; justify-content: space-between; align-items: center; padding: 10px; margin-bottom: 5px; border: 1px solid #ddd; border-radius: 4px; background: ${isActive ? '#e6f3ff' : '#fff'};">
                            <span 
                                onclick="window.switchProjectAndCloseList('${projectId}')" 
                                style="cursor:pointer; flex-grow: 1; color: ${isActive ? '#007bff' : '#333'}; font-weight: ${isActive ? 'bold' : 'normal'};"
                            >
                                ${projectId}${status}
                            </span>
                            
                            <button 
                                onclick="window.renameProject('${projectId}')" 
                                style="margin-left: 5px; background: #ffc107; color: #333; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer; font-weight: bold;"
                                title="Rename this project"
                            >
                                ✏️ Rename
                            </button>
                            
                            <button 
                                onclick="window.duplicateProject('${projectId}')" 
                                style="margin-left: 5px; background: #17a2b8; color: white; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer; font-weight: bold;"
                                title="Create a copy of this project"
                            >
                                ➕ Duplicate
                            </button>

                            <button 
                                onclick="window.deleteProject('${projectId}')" 
                                style="margin-left: 5px; background: #f87171; color: white; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer; font-weight: bold;"
                                title="Permanently delete this project"
                            >
                                🗑️ Delete
                            </button>
                        </li>`;
            });
        }
        html += '</ul>';
        
        listContainer.innerHTML = html;
        
        // Show the modal
        document.getElementById('project-list-modal').style.display = 'block';

    } catch (error) {
        listContainer.innerHTML = 'Error loading projects: Check console for details.';
        console.error("Error fetching project list:", error);
    }
}


/** Renames an existing project document by duplicating it to a new ID and deleting the old one. */
window.renameProject = async function(oldProjectId) {
    if (!oldProjectId) return;

    // 1. Get New Project ID from User
    const newProjectId = prompt(`Rename Project "${oldProjectId}" to:`, oldProjectId + '_renamed');
    
    if (!newProjectId || newProjectId === oldProjectId) {
        if (newProjectId) alert("Rename canceled: The new name must be different from the old name.");
        return; // User cancelled or name is the same
    }

    try {
        // --- STEP 1: READ data from old document ---
        const oldProjectRef = doc(db, PROJECTS_COLLECTION, oldProjectId);
        const oldProjectSnapshot = await getDoc(oldProjectRef); // Assuming getDoc is available from your setup
        
        if (!oldProjectSnapshot.exists()) {
            alert(`Error: Project "${oldProjectId}" not found in Firestore.`);
            return;
        }

        const projectDataToMove = oldProjectSnapshot.data();

        // --- STEP 2: WRITE data to new document (the rename) ---
        const newProjectRef = doc(db, PROJECTS_COLLECTION, newProjectId);
        await setDoc(newProjectRef, projectDataToMove);
        console.log(`Project successfully duplicated to new name: "${newProjectId}"`);

        // --- STEP 3: DELETE old document ---
        await deleteDoc(oldProjectRef);
        console.log(`Original project "${oldProjectId}" successfully deleted.`);

        // --- STEP 4: UPDATE local state if necessary ---
        if (oldProjectId === currentProjectDocumentId) {
            // If the active project was renamed, switch to the new ID
            window.switchProject(newProjectId);
        }
        
        // --- STEP 5: REFRESH the list ---
        window.renderAllProjectsList();
        
        showModal('專案已更名', `Project **${oldProjectId}** successfully renamed to **${newProjectId}**.`);

    } catch (error) {
        alert("Error renaming project. See console for details.");
        console.error("Error renaming document:", error);
    }
};

/** Duplicates an existing project document to a new ID. */
window.duplicateProject = async function(originalProjectId) {
    if (!originalProjectId) return;

    // 1. Get New Project ID from User
    const newProjectId = prompt(`Duplicate Project "${originalProjectId}" as:`, originalProjectId + '_copy');

    if (!newProjectId || newProjectId === originalProjectId) {
        if (newProjectId) alert("Duplication canceled: The new name must be different from the original name.");
        return; // User cancelled or name is the same
    }

    try {
        // --- STEP 1: READ data from original document ---
        const originalProjectRef = doc(db, PROJECTS_COLLECTION, originalProjectId);
        const originalProjectSnapshot = await getDoc(originalProjectRef); // Assuming getDoc is available
        
        if (!originalProjectSnapshot.exists()) {
            alert(`Error: Project "${originalProjectId}" not found in Firestore.`);
            return;
        }

        const projectDataToCopy = originalProjectSnapshot.data();

        // --- STEP 2: WRITE data to new document ---
        const newProjectRef = doc(db, PROJECTS_COLLECTION, newProjectId);
        await setDoc(newProjectRef, projectDataToCopy);
        console.log(`Project successfully duplicated: "${newProjectId}"`);

        // --- STEP 3: REFRESH the list ---
        window.renderAllProjectsList();
        
        showModal('專案已複製', `Project **${originalProjectId}** successfully duplicated as **${newProjectId}**.`);

    } catch (error) {
        alert("Error duplicating project. See console for details.");
        console.error("Error duplicating document:", error);
    }
};









        /** Executes the project switch and closes the list modal. */
        window.switchProjectAndCloseList = function(rawNewProjectId) {
            const newProjectId = rawNewProjectId ? rawNewProjectId.trim().replace(/[^a-zA-Z0-9_-]/g, '_') : null;

            if (newProjectId && newProjectId !== currentProjectDocumentId) {
                window.switchProject(newProjectId);
            } else if (newProjectId === currentProjectDocumentId) {
                // If the user clicked the active project, just close the modal.
            }
            document.getElementById('project-list-modal').style.display = 'none';
        }

        /** Switches the project, saves old data, and loads new data. */
        window.switchProject = function(newProjectId) {
            if (!newProjectId) return;
            
            // 1. Save the project we are leaving
            window.saveProject(); 

            // 2. Change the global ID
            currentProjectDocumentId = newProjectId;
            
            // 3. Reset internal state and re-load
            projectData = []; 
            currentPageId = null; 
            renderPageList(); 
            startRealtimeProjectListener(); 
            
            console.log(`Switched to project: ${newProjectId}`);
        }
        
        /** Deletes a specific project document from Firestore. (NEW) */
        window.deleteProject = async function(projectIdToDelete) {
            if (!projectIdToDelete) return;

            const confirmation = confirm(`Are you absolutely sure you want to delete the project: "${projectIdToDelete}"? This action cannot be undone and will permanently free up storage space.`);

            if (confirmation) {
                try {
                    const projectRef = doc(db, PROJECTS_COLLECTION, projectIdToDelete);
                    await deleteDoc(projectRef);
                    
                    console.log(`Project "${projectIdToDelete}" successfully deleted from Firestore.`);
                    
                    // 1. If the active project was deleted, switch to the default project
                    if (projectIdToDelete === currentProjectDocumentId) {
                        // Switch to a known default to prevent errors
                        window.switchProject('classroom_master_file'); 
                    }
                    
                    // 2. Refresh the project list in the modal
                    window.renderAllProjectsList(); 

                } catch (error) {
                    alert("Error deleting project. See console for details.");
                    console.error("Error deleting document: ", error);
                }
            }
        }
        








        // --- Page Management Functions (Existing) ---

        window.loadProjectFromLocalStorage=function() {
             const savedProject = localStorage.getItem(storageKey + '-' + currentProjectDocumentId);
             if (savedProject) {
                 projectData = JSON.parse(savedProject);
                 currentPageId = projectData[0].id;
                 loadPageData(currentPageId);
                 renderPageList();
             } else {
                 initializeBlankProject();
             }
        }

        function initializeBlankProject() {
             projectData = [{
                 id: 'page-1',
                 name: 'Home Page',
                 html: `<div style="text-align: center; padding: 20px;" class="floating-div"><h2>TOPIC  ${currentProjectDocumentId}!</h2><p>Let's learn.</p></div>`,
                 drawingData: null
             }];
             currentPageId = 'page-1';
             loadPageData(currentPageId);
             renderPageList();
              window.saveProject(); 
        }

// 💡 NEW Recommended approach: Save the blank project only if the document truly didn't exist
// This should be done only once:
async function ensureProjectExists() {
    const projectRef = doc(db, PROJECTS_COLLECTION, currentProjectDocumentId);
    const docSnapshot = await getDoc(projectRef); // You need to import getDoc for this

    if (!docSnapshot.exists()) {
        initializeBlankProject();
        // Now, save it immediately once:
        window.saveProject(); 
    }
    // Now start the listener AFTER you've ensured the doc exists
    startRealtimeProjectListener(); 
}

        function getCurrentPage() {
            return projectData.find(p => p.id === currentPageId);
        }

        window.switchPage = function(pageId) {
            if (pageId === currentPageId) return;

            saveCurrentPageData(); 
            currentPageId = pageId;
            loadPageData(pageId);
            renderPageList();
        }

        window.createNewPage = function() {
            const pageName = prompt("Enter new page name:", "New Page");
            if (!pageName) return;

            const newPageId = `page-${Date.now()}`;
            const newPage = {
                id: newPageId,
                name: pageName,
                html: `<div style="text-align: center; padding: 20px;" class="floating-div"><h1>${pageName}</h1><p>Let's learn!</p></div><div id="draggable-image" style="width:200px;height:200px;background-image(url('https://classroomclipart.com/image/content7/60315/thumb.gif');background-size:contain;z-index:10" ></div> `,
                drawingData: null
            };

            saveCurrentPageData(); 
            projectData.push(newPage); 
            
            switchPage(newPageId); 
            window.saveProject(); 
        }

        function saveCurrentPageData() {
            const page = getCurrentPage();
            if (!page) return;
// 2. Add the drawingCanvas if it's missing (it should be persistent)

            page.html = editor.innerHTML;
        }

function loadPageData(pageId) {
    const page = projectData.find(p => p.id === pageId);
    if (!page) return;
    
// 1. CLEAR THE EDITOR (This is correct for resetting page content)
    editor.innerHTML = page.html || '';
    
    // 2. CREATE, STYLE, APPEND, AND INITIALIZE CANVAS
    // We KNOW the canvas is gone because we just wiped editor.innerHTML.
    // So, we must create a new one every time.
    const canvasElement = document.createElement('canvas');
    canvasElement.id = 'drawingCanvas';

    // Set all necessary CSS properties
    canvasElement.style.position = 'absolute';
    canvasElement.style.top = '0';
    canvasElement.style.left = '0';
    canvasElement.style.width = '100%'; // Ensure it fills the editor area
    canvasElement.style.height = '100%'; 
    canvasElement.style.zIndex = '50';
    canvasElement.style.backgroundColor = 'transparent'; // Change to transparent after testing!
    
    // Add the element to the DOM
    editor.appendChild(canvasElement);
    
    // 3. Initialize drawing controls immediately with the valid object
    window.initDrawingCanvas(canvasElement);

    // 4. Initialize drag/resize elements for the HTML just loaded
    window.initElements();
}


function renderPageList() {
    // CRITICAL: Use the module's existing projectData variable
    const pages = projectData; 
    const pageListElement = document.getElementById('page-list'); 
    
    // Check for element existence and data integrity
    if (!pageListElement || !Array.isArray(pages) || pages.length === 0) {
        if(pageListElement) pageListElement.innerHTML = ''; // Clear if the element exists
        return;
    }

    pageListElement.innerHTML = ''; // Clear the existing list

    pages.forEach((page, index) => {
        const listItem = document.createElement('li');
        listItem.id = `list-item-${page.id}`;
        // Use an active class for styling
        if (page.id === currentPageId) {
            listItem.classList.add('active');
        }
        
        // --- Page Name Span ---
        const nameSpan = document.createElement('span');
        nameSpan.textContent = page.name;
        nameSpan.style.cssText = 'cursor: pointer; flex-grow: 1;';
        nameSpan.onclick = () => window.switchPage(page.id);
        
        // --- Control Container ---
        const controlContainer = document.createElement('div');
        controlContainer.style.cssText = 'display: flex; gap: 5px;';

        // Up Button
        const upButton = document.createElement('button');
        upButton.textContent = '⬆️';
        upButton.title = 'Move Up';
        upButton.onclick = (e) => { e.stopPropagation(); window.movePage(page.id, -1); };
        if (index === 0) upButton.disabled = true;

        // Down Button
        const downButton = document.createElement('button');
        downButton.textContent = '⬇️';
        downButton.title = 'Move Down';
        downButton.onclick = (e) => { e.stopPropagation(); window.movePage(page.id, 1); };
        if (index === pages.length - 1) downButton.disabled = true;
        
        // Delete Button
        const deleteButton = document.createElement('button');
        deleteButton.textContent = '🗑️';
        deleteButton.title = 'Delete Page';
        deleteButton.style.color = 'red';
        deleteButton.onclick = (e) => { e.stopPropagation(); window.deletePage(page.id); };


        // Rename Button
        const RnButton = document.createElement('button');
        RnButton.textContent = 'R';
        RnButton.title = 'Rename Page';
        RnButton.style.color = 'red';
        //RnButton.onclick = (e) => { e.stopPropagation(); window.renamePage(page.id,prompt('輸入新名稱', page.name)); };
RnButton.onclick = (e) => { 
    e.stopPropagation(); 
    // Execute the prompt when the button is clicked!
    const newName = prompt('輸入新名稱', page.name); 
    if (newName !== null) { // Check if the user didn't cancel
        window.renamePage(page.id, newName); 
    }
};


        // --- Assemble and Append ---
        //controlContainer.append(upButton, downButton, deleteButton);
        controlContainer.append(upButton, downButton, deleteButton, RnButton);
        listItem.append(nameSpan, controlContainer);
        
        listItem.style.cssText = 'display: flex; justify-content: space-between; align-items: center; padding: 5px;';
        
            pageListElement.appendChild(listItem);
    });
}
 






        

 
window.renamePage = function(pageId, newName) {
    // CRITICAL FIX: Use projectData
    const pageToRename = projectData.find(p => p.id === pageId);

    if (pageToRename) {
        pageToRename.name = newName.trim() || `Page ${pageId.split('-')[1]}`;
        renderPageList();
        window.saveProject(); 
    }
}

 
window.deletePage = function(pageId) {
    if (!confirm("Are you sure you want to delete this page?")) {
        return; 
    }
    
    // CRITICAL FIX: Use projectData instead of the undefined 'pages'
    projectData = projectData.filter(p => p.id !== pageId);

    // 2. Handle current page selection
    if (projectData.length === 0) {
        // Since all pages are gone, re-initialize a blank project
        initializeBlankProject(); 
    } else if (currentPageId === pageId) {
        // If current page was deleted, switch to the first remaining page
        window.switchPage(projectData[0].id);
    }
    
    // 3. Re-render and save
    renderPageList();
    window.saveProject(); // Ensure data is persisted
}

 
window.movePage = function(pageId, direction) {
    // CRITICAL FIX: Use projectData
    const oldIndex = projectData.findIndex(p => p.id === pageId);

    if (oldIndex === -1) return;
    const newIndex = oldIndex + direction;
    if (newIndex < 0 || newIndex >= projectData.length) return;

    // 1. Remove and get the page
    const [pageToMove] = projectData.splice(oldIndex, 1);
    
    // 2. Insert at the new position
    projectData.splice(newIndex, 0, pageToMove);

    // 3. Re-render and save
    renderPageList();
    window.saveProject(); 
}

 

        window.toggleEditMode = function() {
            DesignMode = !DesignMode; 
            const isEditable = editor.getAttribute('contenteditable') === 'true';
            editor.setAttribute('contenteditable', !isEditable);
        }


        window.applyForeColor = function(color) {
             document.execCommand('styleWithCSS', false, true); 
             document.execCommand('foreColor', false, color); 
             document.execCommand('styleWithCSS', false, false);
        }
        window.rgbToHex=function(rgb) {
            // 從 'rgb(r, g, b)' 或 'rgba(r, g, b, a)' 字串中提取 r, g, b
            const parts = rgb.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d*\.?\d*))?\)$/);
            if (!parts) return '#ffffff'; // 如果格式不符，返回白色
            
            const r = parseInt(parts[1]);
            const g = parseInt(parts[2]);
            const b = parseInt(parts[3]);
            
            // 將 RGB 轉換為十六進制
            const toHex = (c) => {
                const hex = c.toString(16);
                return hex.length === 1 ? "0" + hex : hex;
            };

            return "#" + toHex(r) + toHex(g) + toHex(b);
        }


              //############################ INSERT ELEMENT      Dynamic Element ####################

        // --- Dynamic Element Creation ---



window.addDivWithImageBackgroundElement = function() {
     const imageUrl = document.getElementById('Xurl').value;
 
     if (!imageUrl) return;

    const imgDiv = document.createElement('div');
    
    // 1. Assign a unique ID (Required for saving and selection)
    imgDiv.id = `img-${Date.now()}`; 
    
    imgDiv.className = 'draggable-image';
    
    // Set positioning explicitly (CRITICAL for draggable)
    imgDiv.style.position = 'absolute'; 
    imgDiv.style.left = `${lastClickPos.x}px`;
    imgDiv.style.top = `${lastClickPos.y}px`;
    
    imgDiv.style.width = '150px';
    imgDiv.style.height = '150px';
    imgDiv.style.backgroundImage = `url('${imageUrl}')`;
    imgDiv.style.backgroundSize = 'cover';
    imgDiv.style.backgroundPosition = 'center';
    imgDiv.style.backgroundRepeat = 'no-repeat';
    imgDiv.style.borderRadius = '0px'; 
    
    editor.appendChild(imgDiv);
    
    // 2. Initialize ALL necessary properties and handlers
    window.initElement(imgDiv); // Adds resizer, z-index
    window.initElementForMovement(imgDiv); // Adds data-degree for rotation
    
    window.saveProject();
    window.showModal('Image element added.', 'Success');
}




 window.insertCode=function(htmlString) {

  
  const selection = window.getSelection();  
             const url = prompt("Enter the URL for the link (e.g., https://www.google.com):"); 
	     const myH= Number(activeItem.style.height.replace('px',''))*0.8;
    
    if (selection.rangeCount > 0) {
        const range = selection.getRangeAt(0);

            //const htmlString="<a href=\""+url+"\" target=\"_blank\" >"+range+"</a>";
	    
        // Create a temporary div to parse the HTML string into DOM nodes
        const tempDiv = document.createElement('span');
 
        if(htmlString=='iframe'){

	   tempDiv.innerHTML=`<iframe src="${url}" style="height:${myH}px;width:100%" ></iframe>`;
	}else if(htmlString=='img'){

	   tempDiv.innerHTML=`<image src="${url}" style="height:auto;width:200px;display:inline" ondblclick="window.dealme(this);" alt="按兩下調整尺寸" ></image>`;
        }else{
        tempDiv.innerHTML = htmlString;
        }

        const fragment = document.createDocumentFragment();
        while (tempDiv.firstChild) {
            fragment.appendChild(tempDiv.firstChild);
        }

        range.deleteContents(); // Optional: remove selected text
        range.insertNode(fragment);

        // Optionally, collapse the selection after insertion
        selection.collapseToEnd();
     
  } else {
    // If no selection, append to the end
    contentEditableElement.appendChild(document.createTextNode(htmlString));
  }
}

         window.addNewTextElement=function(type,mycolor) {
            if (!type) return;
	 
            let defaultContent = "";
            let tagName = type.toLowerCase();
		let randomNumber = Math.random();
		randomNumber =Math.floor(randomNumber*1000);            
            // Reset the dropdown after selection  
            document.getElementById('addElementType').value = ""; 

            if (type === 'P') {
                defaultContent = "<p>按兩下後在此打字</p>";
            } else if (type === 'H1') {
                defaultContent = "<h1>按兩下後在此打字</h1>";
            } else if (type === 'H2') {
                defaultContent = "<h2>按兩下後在此打字</h2>";
            } else if (type === 'H3') {
                defaultContent = "<h3>按兩下後在此打字</h3>";
            } else if (type === 'sticker') {
                defaultContent = `<div id="hinder${randomNumber}" style="padding-left:40px;color:blue;font-size:30px">memo </div><div class="resizer"></div>`;

            } else if (type === 'Animateout') {

                defaultContent = "<h3>按兩下後在此打字</h3>";
		window.addTextElementAnimated();
                return;
            } else if (type === 'Hinter') {
               defaultContent = `<div id="hinder${randomNumber}"   ontouchstart="dropmenu('hinder${randomNumber}_menu')"  onclick="dropmenu('hinder${randomNumber}_menu')" style="position:relative;background-size:contain;padding-left:40px;color:blue;font-size:30px;display:inline"><b>按兩下後在此打字，白板模式中按一下顯示V或X<BR>作為答案結果(進設計模式下可刪除)</b><span id="hinder${randomNumber}_menu" style="display:none;position:absolute;top:-10px;left:-20px;background:;border:1px solid gray;border-radius:25px;padding:4px;width:100%px;height:50px;background-size:contain" ><font color="black" size="6" >✔️❌</font></span> </div>`;

            } else if (type === 'DropMenu') {
                defaultContent = `<h1 id="hinder${randomNumber}"   ontouchstart="dropmenu()"  onclick="dropmenu()" style="position:relative;background-size:contain"><b>按兩下後在此打字</b><span id="hinder${randomNumber}_menu" style="display:none;position:absolute;top:50px;left:10px;background:white;border:2px solid gray;border-radius:25px;padding:4px;width:100%;background-size:contain" ><font color="black" size="6"  ontouchstart="this.style.display='none';" >說明:</font></span></h1> `;
            } else if (type === 'Poke') {
                defaultContent = `<div id="hinder${randomNumber}"   ontouchstart="showCard(this)"  onclick="showCard(this)" style="border-radius:16px;background-size:contain;background-repeat:no-repeat;background-position-y: center;border:10px solid white;box-shadow:4px 4px 2px gray"> <img id="coverpic" src="https://opengameart.org/sites/default/files/styles/medium/public/card%20back%20red.png" style="display:none;"></div> `;

            } else if (type === 'TTS') {
                defaultContent = `<div  id=\"TTS"+randomNumber+"\"   class="TTS" ontouchstart="speakText(this.textContent)"  onclick="speakText(this.textContent)" style="background-size:contain" >按兩下在此打字電腦報讀語音</div>`;
            } else if (type === 'VRS') {
	 
                defaultContent = `<div  id="template" class="VRS" onclick="javascripot:window.randomItem();this.textContent=this.textContent.substring(0,this.textContent.lastIndexOf('(')) +'(' + document.getElementById('temp').value+ ')' + this.textContent.substring(this.textContent.lastIndexOf(')')+1,this.textContent.length);startVoiceRecognition(this.textContent);"     style="background-size:contain" > ( ) is my favorite.</div>`;
           } else if (type === 'Quiz') {
            window.createQuizFloatingDiv(mycolor);
            return;
 

            } else {
                return;
            }

            const textDiv = document.createElement('div');
            textDiv.className = 'floating-div';  // fly-in-animated transition-all duration-700 ease-out
            textDiv.style.left = `${lastClickPos.x}px`;
            textDiv.style.top = `${lastClickPos.y}px`;
            textDiv.setAttribute('contenteditable', 'false');
            textDiv.style.backgroundSize = 'contain';
            textDiv.style.backgroundColor=`${mycolor}`;
            textDiv.style.borderRadius = '0px'; // Initialize with 0 radius
            textDiv.style.padding = '5px';
            textDiv.style.minWidth = '10px'; // Give headings some space
            //textDiv.style.fontSize = '30pt';  
            textDiv.innerHTML = defaultContent;
            
            editor.appendChild(textDiv);
            window.initElement(textDiv);
        }



       //插入動畫文字
         window.addTextElementAnimated=function() {
            const textDiv = document.createElement('div');
            // Start text elements VISIBLE, but include the animation utility class
            textDiv.className = 'floating-div fly-in-animated transition-all duration-700 ease-out opacity-100';
            textDiv.style.left = `${lastClickPos.x}px`;
            textDiv.style.top = `${lastClickPos.y}px`;
            textDiv.setAttribute('contenteditable', 'false'); 
            textDiv.style.backgroundColor = '#ffffaa';
            textDiv.style.borderRadius = '12px';
            textDiv.innerHTML = "Click the 'Toggle Animation' button to fly me in/out, then use the Gemini AI Tools!";
            editor.appendChild(textDiv);
            window.initElement(textDiv);
        }


 // --- FLY-IN ANIMATION LOGIC ---
      window.toggleFlyIn=function(element) {

            if (!element || !element.classList.contains('fly-in-animated')) {
                //showModal('Please select a text element to animate.', 'Info');
                return;
            }
            
            if (element.classList.contains('locked')) {
                window.showModal("Item is locked and cannot be animated.", 'Info');
                //return;
            }
            if (element.classList.contains('editing')) {
                window.showModal("Item is editing and cannot be animated.", 'Info');
                //return;
            }

            const isHidden = element.classList.contains('opacity-0');
        if (DesignMode==false) {
            if (isHidden) {
                element.classList.add('opacity-100', 'translate-x-0');
                element.classList.remove('opacity-0', '-translate-x-full');
		window.speakText(element.innerText);
		flag=false;
            } else {

                 element.classList.add('opacity-0', '-translate-x-full');
                 element.classList.remove('opacity-100', 'translate-x-0');
            }
		

         }else{
                
 		 const items = document.querySelectorAll('.fly-in-animated');
		items.forEach(item => {
		//showModal('item number'+items.length,'end phase');
					item.classList.remove('opacity-0', '-translate-x-full');
					item.style.display='';
					item.classList.remove('opacity-100', '-translate-x-0');
		});
	}



        }

 window.textSlider=function(){

 //const playlist=[];
  const sliders = editor.querySelectorAll('.fly-in-animated');

  sliders.forEach((slider,i)=>{
 
   //if(sliders[i].classList.contains('fly-in-animated')){
         //playlist.push(sliders[i]);
         //playlist.reverse();
   //}
  });



        window.showModal(counter,'slider number');

       //playlist[i].classList.add('activeItem');
        window.toggleFlyIn(sliders[counter]);
	 counter +=1;

        if (counter==sliders.length || counter>sliders.length){            
		counter=0;
	}
}



//回傳隨機圖片名稱
   window.randomItem=function(){
	 //alert('wtf');
	  let seeds = document.getElementById('editor').querySelectorAll('.draggable-image');
	   
	let seedx=Math.floor(Math.random()*seeds.length);
		gameTarget=seeds[seedx].id;
		document.getElementById('temp').value=gameTarget;
		quizCount +=1;
                           window.showModal(gameTarget,'get')
		return gameTarget

        }


//-----------------------加入動畫
     window.toggleAnimate=function(animate){
           activeItem.classList.remove('.animate-ping', '.animate-pulse', '.animate-spin',  '.animate-bounce','.translate-y-full');
             if(activeItem.classList.contains(animate)){
	 activeItem.classList.remove(animate);
           }else{
	activeItem.classList.add(animate);
          }
         
	 //####-translate-x-full  translate-x-0 -translate-y-80 ,'-translate-y-80'
	 //###animate-none .animate-ping animate-pulse animate-spin  animate-bounce animate-spin .animate-bounce


        }








     //套用id名稱，隱藏資訊        到選取的圖層
       window.applyMyInfo=function() {
            const myID = document.getElementById('MyID').value;
		
                activeItem.setAttribute("id",myID);

                if (activeItem.getElementsByTagName("span")){
		       if(activeItem.getElementsByTagName("span")[0]){
		           activeItem.getElementsByTagName("span")[0].innerText=document.getElementById('MyInfo').value;
		       }else{

		           const mytag = document.createElement('span');
			   mytag.style.display="none";
			   mytag.innerText=document.getElementById('MyInfo').value;
                           activeItem.appendChild(mytag);

                       }
		 } 
 
		 	
	}

 
 window.duplicateActiveItem=function() {
    // 檢查是否有選中的元素 (activeItem 應該是您用來儲存當前選中元素的變數)
    if (!activeItem) {
        console.warn("No item selected for duplication.");
        return;
    }

    // 1. 執行深層複製 (Deep Clone)
    //    傳入 true 確保複製所有子節點、屬性和樣式
    const newItem = activeItem.cloneNode(true);
        document.getElementById('temp').value=activeItem.outerHTML;
    // 2. 清除不需要的屬性或 ID
    //    確保每個元素都有唯一的 ID (如果您的設計需要 ID)
    if (newItem.id) {
        // 假設您有一個 generateUniqueId() 函數來創建新的 ID
        // newItem.id = generateUniqueId(); 
    }
    
    // 3. 調整新元素的位置 (避免與原元素完全重疊)
    //    複製後的元素樣式和位置通常會被複製過來，我們微調 left 和 top
    const currentLeft = parseInt(activeItem.style.left) || 0;
    const currentTop = parseInt(activeItem.style.top) || 0;

    const offset = 10; // 偏移量，讓複製的元素在右下方可見
    
    newItem.style.left = (currentLeft + offset) + 'px';
    newItem.style.top = (currentTop + offset) + 'px';
 
 
    // 4. 將新元素插入 DOM
   // const editor = document.getElementById('editor');
    editor.appendChild(newItem);

    // 5. 重新初始化 (關鍵步驟)
    //    新複製的元素沒有拖曳事件，需要重新綁定
    window.initElements();
    
    // 6. 設置新元素為當前選中項
    setActiveItem(newItem); // 假設您有一個 setActiveItem 函數來處理選中狀態
   showModal('已再製','')
    console.log("Item duplicated successfully.");    

}



 window.pasteClone=function(){
       
    const editor = document.getElementById('editor');
    const tempdiv=document.createElement('div');
    tempdiv.innerHTML=document.getElementById('temp').value;
    editor.appendChild(tempdiv);

    // 5. 重新初始化 (關鍵步驟)
    //    新複製的元素沒有拖曳事件，需要重新綁定
    window.initElements();
}






 window.expand=function(){
 if (""!=event.srcElement.id) {	   

		let ch=event.srcElement.id + "_0"; 
        	//var target=document.all[ch] 

		let target=document.getElementById(ch);
  
		if (null!=target){target.style.display =(target.style.display=="none" ) ? "" : "none";} 
		

 }
           //alert(window.randomItem());

 if (event.srcElement.getElementsByTagName("span") && event.srcElement.classList.contains('draggable-image')){
       const imgpool=event.srcElement.querySelectorAll("img");
	if(DesignMode){
	activeItem.getElementsByTagName("span")[0].style.display='';
		event.srcElement.setAttribute('contentEditable','true');
		//showModal(imgpool.length,'');
		
	        if(imgpool){
		 imgpool.forEach(sw=>{
			sw.style.display='';
		         });
                }
	}else{
            //if(event.srcElement.classList.contains('dice')){
	       activeItem.getElementsByTagName("span")[0].style.display='none';
		activeItem.setAttribute('contentEditable','false');

	        if(imgpool){
		 if(imgpool.length>3){activeItem.style.transform = 'translateY(-250px)';}		
		 imgpool.forEach(sw=>{
			sw.style.display='none';
		         });
                }

	
		window.swapImg(activeItem);
		//}

	}//end if design mode

		

      }//end if span exits

		
}




 window.dropmenu=function(target){
        	 
         if(target){		 
	 const targetx=document.getElementById(target);
                   if (null!=targetx && DesignMode==false){targetx.style.display =(targetx.style.display=="none" ) ? "" : "none";}
       }else{

                         if (""!=event.srcElement.id) {
                                   let ch=event.srcElement.id + "_menu"; 
		const mytarget=document.getElementById(ch);

		   if (null!=mytarget){
			mytarget.style.display =(mytarget.style.display=="none" ) ? "" : "none";
			
			if(mytarget.innerText=='' && mytarget.classList.contains('floating-div')){showCard(event.srcElement,mytarget);}//==========需要再加條件
		   }

                      }
	}
		 


}



//撲克牌模式===🃏
  let cardflag=false;
 window.showCard=function(mytarget){
   cardflag=!cardflag
      let coverpic=document.getElementById('coverpic').src; 
      let mybk=document.getElementById(window.randomItem()).style.backgroundImage;
      let act=Math.floor(Math.random()*10);

  if(cardflag==false){
       mytarget.style.cssText=`  font-size:30px;color:blue;display: flex;align-items: center;justify-content: center;width:120px;height:160px;background-size:contain;background-repeat:no-repeat;background-position-y:center;background-color:;border:10px white solid;border-radius:15px;box-shadow:4px 4px 6px gray`;
       mytarget.style.backgroundImage=`url('${coverpic}')`;
       let bnr=document.createElement('span');
        if(act>5){
           window.showModal('Say ','Do');
       }else{
           window.showModal('Act ','Do');      
       }
  }else{
  mytarget.style.cssText=`width:120px;height:160px;background-size:contain;background-repeat:no-repeat;background-position-y:center;background-color:;border:10px white solid;border-radius:15px;box-shadow:4px 4px 6px gray`;
  mytarget.style.backgroundImage=document.getElementById(window.randomItem()).style.backgroundImage;
   //mytarget.inneText='';
  window.startVoiceRecognition(gameTarget);

  }
 
}




window.swapImg=function(targetElement){


		const imgpool=targetElement.querySelectorAll("img");
		//showModal(imgpool.length,'total images');

		if(imgpool.length==1){
			const swapimg=imgpool[0].src;
			targetElement.style.backgroundImage=`url('${swapimg}')`;

		}else{
 	               //targetElement.style.transform ='rotate(45deg)';
			


 	           setTimeout(() => {
			
			let x=Math.floor(Math.random()*imgpool.length);
			const swapimg=imgpool[x].src;	
			targetElement.style.backgroundImage=`url('${swapimg}')`;

	                //activeItem.style.transform = 'translateY(-80px)';
	                targetElement.style.transform = 'rotate(45deg)';


 	      setTimeout(() =>{ targetElement.style.transform = 'rotate(90deg)';}, 100);
	            }, 100);
			 targetElement.style.transform = 'rotate(360 deg)';
			//activeItem.style.transform = 'translateY(-20px)';

				
		}		
			//const bg=`background-image:url('${swapimg}'); background-size: cover;`;
}


//---paste as file without uploading免上傳的本機圖片貼上 
   window.handlePaste=function(event) {
        //if (!isEditing) return; 


        const items = event.clipboardData.items;
        let imagePasted = false;

        for (let i = 0; i < items.length; i++) {
            // Look for an image item (kind === 'file' is crucial for image data)
            if (items[i].type.indexOf('image') !== -1 && items[i].kind === 'file') {
                event.preventDefault(); // Stop the default paste action
                imagePasted = true;
                const file = items[i].getAsFile();

                if (file) {
 
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        const base64Image = e.target.result;

           const imgDiv = document.createElement('div');
            imgDiv.className = 'draggable-image';
            imgDiv.style.left =  `${lastClickPos.x}px`;;
            imgDiv.style.top =  `${lastClickPos.y}px`;;
            imgDiv.style.maxWidth = '100%';
            imgDiv.style.width = '150px';
            imgDiv.style.height = '150px';
            imgDiv.style.backgroundImage = `url('${base64Image}')`;
            imgDiv.style.backgroundSize = 'cover';
            imgDiv.style.backgroundPosition = 'center';
            imgDiv.style.backgroundRepeat = 'no-repeat';
            imgDiv.style.borderRadius = '0px'; // Initialize with 0 radius
            editor.appendChild(imgDiv);
            window.initElement(imgDiv); 

                        // Create an IMG element
                        const img = document.createElement('img');
                         img.src = base64Image;
                         
                        // Add the draggable class and initial positioning
                        //img.className = 'draggable-content'; 

                        //editor.insertNode(img); // Insert into the editor~~~~Not working

  //--selection pasting
  const selection = window.getSelection();

    if (selection.rangeCount > 0 && activeItem.classList.contains('editing')) {
        const range = selection.getRangeAt(0);
             const htmlString=`<img src='${base64Image}' style="display:inline;width:150px;height:auto" alt="按兩下調整尺寸" ondblclick="dealme(this);" >`;	    
        // Create a temporary div to parse the HTML string into DOM nodes
        const tempDiv = document.createElement('span');
        tempDiv.innerHTML = htmlString;
        const fragment = document.createDocumentFragment();
        while (tempDiv.firstChild) {
            fragment.appendChild(tempDiv.firstChild);
        }

        range.deleteContents(); // Optional: remove selected text
        range.insertNode(fragment);

        // Optionally, collapse the selection after insertion
        selection.collapseToEnd();
     
  } else {
    // If no selection, append to the end
    contentEditableElement.appendChild(document.createTextNode(htmlString));
  }
//--selection pasting



                    };
                    reader.readAsDataURL(file);
                    break; 
                }
            }
        }
    }




 window.insertDice=function(){

	 const dicecode=`<div class="draggable-image dice" style="background-image: url('https://www.emojiall.com/images/120/samsung/2685.png'); background-size: cover; z-index: 10; left: 439px; top: 161px; width: 76px; height: 72px; border-radius: 8px;padding:0px;margin:0px;box-shadow:2px 2px  gray" id="" contenteditable="true" data-listener-added_4520328c="true"><span style="" contenteditable="true">AAAA<img src="https://www.emojiall.com/images/120/samsung/2681.png" style="height: auto; width: 200px;" ondblclick="window.dealme(this);" alt="按兩下調整尺寸"><img src="https://www.emojiall.com/images/120/samsung/2682.png" style="height: auto; width: 200px;" ondblclick="window.dealme(this);" alt="按兩下調整尺寸"><img src="https://www.emojiall.com/images/120/samsung/2683.png" style="height: auto; width: 200px;" ondblclick="window.dealme(this);" alt="按兩下調整尺寸"><img src="https://www.emojiall.com/images/120/samsung/2684.png" style="height: auto; width: 200px;" ondblclick="window.dealme(this);" alt="按兩下調整尺寸"><img src="https://www.emojiall.com/images/120/samsung/2685.png" style="height: auto; width: 200px;" ondblclick="dealme(this);" alt="按兩下調整尺寸"></span><img src="https://www.emojiall.com/images/120/samsung/2680.png" style="width: 200px;" alt="按兩下調整尺寸"><div class="resizer"></div></div>`;

	document.getElementById('temp').value=dicecode;
	window.pasteClone();

}

 window.dealme=function(ele){
 	const p = prompt("輸入尺寸如60(\%)");
 
 	const w=ele.style.width.substring(0,ele.style.width.length-2);
 

	ele.style.width=p*(w/100)+'px';
 
}




        // #########################  Styling Functions (Scoped to activeItem) ################################3

        /**
         * Generic runner for simple text formatting commands (bold, italic, underline).
         */
      window.runTextCommand=function(command) {
            // Check if active item is a text div AND is editable
            if (!activeItem || activeItem.getAttribute('contenteditable') !== 'true' || !activeItem.classList.contains('floating-div')) {
                console.error(`Cannot run command '${command}': Select a text item and click 'Edit Text' first.`);
                return;
            }
            activeItem.focus();
            document.execCommand(command, false, null);
        }

        // formatBlock function removed as the feature is now handled by the addNewTextElement dropdown

       window.setFontColor=function() {
             if (!activeItem || activeItem.getAttribute('contenteditable') !== 'true' || !activeItem.classList.contains('floating-div')) return;
            activeItem.focus(); 
            document.execCommand('foreColor', false, document.getElementById('fontColor').value);
        }

     window.setFontSize=function() {
            // Font size command works with index values 1-7
            if (!activeItem || activeItem.getAttribute('contenteditable') !== 'true' || !activeItem.classList.contains('floating-div')) return;
            const sizeValue = document.getElementById('fontSize').value;
            activeItem.focus(); 
            document.execCommand('fontSize', false, sizeValue);
        }

   window.changeFont=function() {
    const fontName = document.getElementById('fontSelector').value;
    document.execCommand('fontName', false, fontName);
  }

      window.setBackgroundColor=function(cmd) {
            // Background color can be applied to both text and image elements

            if (!activeItem || (!activeItem.classList.contains('floating-div') && !activeItem.classList.contains('draggable-image'))) return;
	if(cmd=='t'){activeItem.style.backgroundColor ='';}else{
            const color = document.getElementById('backgroundColor').value;
            activeItem.style.backgroundColor = color;}

        }

     window.dobg=function(url) {
            const color = document.getElementById('backgroundColor').value;
	
           if(document.getElementById('main')){
                document.getElementById('main').style.backgroundColor = color;
	let urlx=document.getElementById('main').style.backgroundImage;
                if(url){ document.getElementById('main').style.backgroundImage='url('+prompt('貼上底圖網址',urlx)+')';}
           }else{
 
                const bg=document.createElement('div');
                bg.style.cssText=`width:100%;height:100%;background-size: contain;backgroundColo:${color}`;
	let urlx='';
                if(url){ document.getElementById('main').style.backgroundImage='url('+prompt('貼上底圖網址')+')';}
                //if(url !==null){ document.getElementById('main').style.backgroundImage=`url('${urlx}')`;}
                bg.id='main';
	editor.appendChild(bg);
 
           }
        }



         window.applyBorderChanges=function() {

           //const borderColor = document.getElementById('backgroundColor').value;
           const borderColor = document.getElementById('borderColor').value;
           const borderWidth = document.getElementById('borderWidth').value;
            const borderStyle = document.getElementById('borderStyle').value;

            activeItem.style.borderColor = borderColor;
            activeItem.style.borderWidth = borderWidth;
           activeItem.style.borderStyle = borderStyle;
        }

        // Apply initial changes on page load
       // document.addEventListener('DOMContentLoaded', applyBorderChanges);




        // --- MODIFIED: Opacity Control Function ---
        window.setElementOpacity= function(value) {
            if (!activeItem) return;
            
            // 1. 執行 Opacity 變更
            const opacityValue = value / 100;
            activeItem.style.opacity = opacityValue;
            
            // 2. 清除前一個計時器
            if (opacityTimer) {
                clearTimeout(opacityTimer);
            }
            
            // 3. 設定一個新的計時器，在 500ms 後儲存歷史狀態
            // 這稱為 "Debounce"，能防止連續滑動時產生過多的歷史紀錄
            opacityTimer = setTimeout(() => {
                pushHistoryState();
            }, 500);
        }

        

        /**
         * Sets the border radius of the active item (for both text and image divs).
         */
        window.setBorderRadius= function() {
            if (!activeItem) return;

            // Check if the item is a text element OR a draggable image
            const isStylable = activeItem.classList.contains('floating-div') || activeItem.classList.contains('draggable-image');
            
            if (isStylable) {
                const radius = document.getElementById('borderRadius').value;
                activeItem.style.borderRadius = `${radius}px`;
            }
        }



 window.insertLink=function() {
  const selection = window.getSelection();  

    
    if (selection.rangeCount > 0) {
        const range = selection.getRangeAt(0);
            const url = prompt("Enter the URL for the link (e.g., https://www.google.com):"); 
            const htmlString="<a href=\""+url+"\" target=\"_blank\" ><b>"+range+"</b></a>";
	    
        // Create a temporary div to parse the HTML string into DOM nodes
        const tempDiv = document.createElement('span');
        tempDiv.innerHTML = htmlString;
        const fragment = document.createDocumentFragment();
        while (tempDiv.firstChild) {
            fragment.appendChild(tempDiv.firstChild);
        }

        range.deleteContents(); // Optional: remove selected text
        range.insertNode(fragment);

        // Optionally, collapse the selection after insertion
        selection.collapseToEnd();
     
  } else {
    // If no selection, append to the end
    contentEditableElement.appendChild(document.createTextNode(htmlString));
  }
}





         window.removeLink=function() {
            if (!activeItem || activeItem.getAttribute('contenteditable') !== 'true' || !activeItem.classList.contains('floating-div')) {
                console.error("Please select a text item and click 'Edit Text' first.");
                return;
            }
            activeItem.focus();
            document.execCommand('unlink', false, null);
        }



        // --- 5. YOUR EXISTING MODULE CODE (INTEGRATED PLACEHOLDERS) ---
        // ------------------------------------------------------------------
        // *** CRITICAL STEP: REPLACE THESE PLACEHOLDERS WITH YOUR FULL CODE ***
        // ------------------------------------------------------------------

// Add these empty definitions near your other window.functions

 window.updateLockButtonState=function() {
             if (activeItem && activeItem.classList.contains('locked')) {
                lockToggleBtn.textContent = '🔒off';
            } else {
                lockToggleBtn.textContent = '🔏on';
            }
 }
window.updateEditButtonState=function() { 

           if (!editToggleBtn) return;

            const isTextElement = activeItem && activeItem.classList.contains('floating-div');
            const isEditing = activeItem && activeItem.getAttribute('contenteditable') === 'true';

            if (isTextElement) {
                editToggleBtn.disabled = activeItem.classList.contains('locked');
                editToggleBtn.textContent = isEditing ? '停止編輯' : '編輯文字';
            } else {
                editToggleBtn.disabled = true;
                editToggleBtn.textContent = '編輯文字';
            }

 }

window.selectItem = function(item) {
    if (activeItem && activeItem !== item) {
        activeItem.classList.remove('selected');
        // IMPORTANT: Also disable contenteditable on the previously selected item
        if (activeItem.getAttribute('contenteditable') === 'true') {
            activeItem.setAttribute('contenteditable', 'false');
            activeItem.classList.remove('editing');
        }
    }
    activeItem = item;
    activeItem.classList.add('selected');
    window.updateLockButtonState();
    window.updateEditButtonState();
}


        // ########################## Element Controls #########################
        window.bringForward= function() {
            if (!activeItem || activeItem.id === 'editor') return;
            // Max z-index for normal elements is 14 (canvas is 15)
            const currentZIndex = parseInt(activeItem.style.zIndex) || 10;
            activeItem.style.zIndex = Math.min(14, currentZIndex + 1);
        }

      window.sendBackward= function() {
            if (!activeItem || activeItem.id === 'editor') return;
            const currentZIndex = parseInt(activeItem.style.zIndex) || 10;
            activeItem.style.zIndex = Math.max(10, currentZIndex - 1);
        }

     window.deleteSelectedItem= function() {
            if (activeItem) {
                activeItem.remove();
                activeItem = null;
                updateLockButtonState();
                updateEditButtonState();
            }
        }






         window.toggleContentEditable=function() {
	//showModal(activeItem.outerHTML);
            if (!activeItem || !activeItem.classList.contains('floating-div')) {
                console.error("Cannot edit: No text item selected.");
                return;
            }

            if (activeItem.classList.contains('locked')) {
               // console.warn("Item is locked and cannot be edited.");
                //return;
            }

            const isEditable = activeItem.getAttribute('contenteditable') === 'true';

            if (isEditable) {
                // Stop editing
                activeItem.setAttribute('contenteditable', 'false');
                activeItem.classList.remove('editing'); 
                activeItem.blur();
	        pushHistoryState(); 
            } else {
                // Start editing
                activeItem.setAttribute('contenteditable', 'true');
                activeItem.classList.add('editing');
                activeItem.focus();
            }
            updateEditButtonState();
        }

window.resetSlides = function() {
    // 1. Select all elements that use the sliding animation
    const sliders = document.querySelectorAll('#editor .fly-in-animated'); 
    // Using document.querySelectorAll is safer than editor.querySelectorAll 
    // if the editor content is briefly cleared or swapped.
    
    if (sliders.length === 0) {
        // Safe exit if no elements are found
        return;
    }

    sliders.forEach(slider => {
        // Ensure the element exists before attempting to manipulate its classes
        if (slider && slider.classList) {
            
            // Remove the final, visible state classes (opacity: 100, translate-x: 0)
            slider.classList.remove('opacity-100', 'translate-x-0');
            
            // Add the initial, hidden state classes (opacity: 0, translate-x: -full)
            // This prepares the element to "fly in" when the page is viewed again.
            slider.classList.add('opacity-0', '-translate-x-full');
            
            // Optional: Force a reflow/re-paint if needed to ensure the slide hides immediately
            void slider.offsetWidth; 
        }
    });
    console.log("Slide animations reset for new page load.");
}



window.handleStart=function(e){ 

            isSwiping = false; // <-- 新增: 拖曳開始時取消滑動狀態
 	    if (currentTool !== null) return; // Prevent interaction with elements when a drawing tool is active
            //if (isDrawingEnabled) return;
            const clientX = e.clientX || e.touches[0].clientX;
            const clientY = e.clientY || e.touches[0].clientY;

            // Calculate position relative to editor for new elements
            const editorRect = editor.getBoundingClientRect();
            lastClickPos.x = clientX - editorRect.left;
            lastClickPos.y = clientY - editorRect.top;
            
            const targetElement = e.target.closest('.draggable-image, .floating-div, .resizer');

            // Handle clearing selection if clicking on the main editor area
            if (e.target.id === 'editor' || (e.target.tagName === 'DIV' && e.target.id !== 'drawingCanvas' && !targetElement)) {
                if (activeItem) {
                    activeItem.classList.remove('selected');
                    if (activeItem.getAttribute('contenteditable') === 'true') {
                        activeItem.setAttribute('contenteditable', 'false');
                        activeItem.classList.remove('editing');
                    }
                }
                activeItem = null;
                updateLockButtonState();
                updateEditButtonState();
                return;
            }

            if (targetElement) {
                const movableElement = targetElement.closest('.draggable-image, .floating-div');
                
                if (movableElement) {
                    selectItem(movableElement); 
                    
                    const isLocked = movableElement.classList.contains('locked');
                    const isEditable = movableElement.getAttribute('contenteditable') === 'true'; 
                    
                    // Block drag/resize if locked OR currently being edited
                    if (isLocked || isEditable) { 
                        return; 
                    }

                    // Allow Resizing
                    if (e.target.classList.contains('resizer')) {
                        isResizing = true;
                        isDragging = false;
                        startX = clientX;
                        startY = clientY;
                        startWidth = activeItem.offsetWidth;
                        startHeight = activeItem.offsetHeight;
                        e.preventDefault();
                    } 
                    // Allow Dragging
                    else { 
                        isDragging = true;
                        isResizing = false;
                        startX = clientX;
                        startY = clientY;
                        startLeft = activeItem.offsetLeft;
                        startTop = activeItem.offsetTop;
                        e.preventDefault();

                    }
                }
                e.stopPropagation();
            }
        }
window.handleMove=function(e){ 
 
            if (!activeItem || activeItem.classList.contains('locked') || activeItem.getAttribute('contenteditable') === 'true' || (!isDragging && !isResizing)) return;

            const clientX = e.clientX || e.touches[0].clientX;
            const clientY = e.clientY || e.touches[0].clientY;

            if (isResizing) {
                const newWidth = startWidth + (clientX - startX);
                const newHeight = startHeight + (clientY - startY);
                activeItem.style.width = `${Math.max(50, newWidth)}px`;
                activeItem.style.height = `${Math.max(50, newHeight)}px`;
            } else if (isDragging) {
                const newLeft = startLeft + (clientX - startX);
                const newTop = startTop + (clientY - startY);
                activeItem.style.left = `${newLeft}px`;
                activeItem.style.top = `${newTop}px`;
	  window.checkOverlap(activeItem); 
             //======================================  一碰到就有反應 

            }
            e.preventDefault();
        }

 window.handleEnd=function() { 
    if (isDragging || isResizing) {
       // pushHistoryState(); // <-- 新增: 拖曳/縮放結束
    }
    isDragging = false; 
    isResizing = false; 

}



   
// MOUSE EVENTS: The main actions should fire globally
window.addEventListener('mousemove', handleMove);
window.addEventListener('mouseup', handleEnd);

// TOUCH EVENTS: The main actions should fire globally
window.addEventListener('touchmove', handleMove);
window.addEventListener('touchend', handleEnd);
window.addEventListener('touchcancel', handleEnd);

// The start events MUST remain on the editor/document to detect the start of a drag/resize
editor.addEventListener('mousedown', handleStart);
editor.addEventListener('touchstart', handleStart);

 editor.addEventListener('dblclick',toggleContentEditable);


//-----OLD listener

        editor.addEventListener('mousedown', handleStart);
        editor.addEventListener('mousemove', handleMove);
        editor.addEventListener('mouseup', handleEnd);
        editor.addEventListener('mouseleave', handleEnd);
//-----OLD listener 


/**
 * Toggles the 'locked' class on the active element and updates the UI button.
 */
window.toggleLock = function() {
    if (!activeItem) {
        window.showModal('No item selected to lock/unlock.', 'Error');
        return;
    }
           if(activeItem.classList.contains('locked')){
                    activeItem.classList.remove('opacity-50', 'animate-bounce');
          }
    // Toggle the 'locked' class
    activeItem.classList.toggle('locked');

    // Update the button and save the project state
    window.updateLockButtonState();
    window.saveProject();
    
    window.showModal(
        activeItem.classList.contains('locked') ? 'Element Locked 🔏' : 'Element Unlocked🔒 ', 
        'Success'
    );
}

// Ensure the button state function is working correctly (you had this as a placeholder)
window.updateLockButtonState = function() {
    if (!lockToggleBtn) return;
    
    if (activeItem && activeItem.classList.contains('locked')) {
        lockToggleBtn.textContent = '  🔏';
        // Disable editing/resizing features if needed
    } else {
        lockToggleBtn.textContent = ' 🔒';
        // Enable editing/resizing features
    }
}


/**
 * Rotates the active element by the given degree value.
 * @param {number} degrees - The amount to rotate by (e.g., 90 for a quarter turn).
 */
window.rotateElement = function(degrees) {
    if (!activeItem) {
        window.showModal('No item selected to rotate.', 'Error');
        return;
    }
    
    // 1. Read current degree value from the data attribute (initElementForMovement sets this)
    let currentDegree = parseInt(activeItem.getAttribute('data-degree') || 0);

    // 2. Calculate the new degree
    let newDegree = currentDegree + degrees;
    
    // Normalize rotation (optional, but keeps numbers manageable)
    newDegree = newDegree % 360; 
    if (newDegree < 0) newDegree += 360;

    // 3. Apply the rotation style and update the data attribute
    activeItem.style.transform = `rotate(${newDegree}deg)`;
    activeItem.setAttribute('data-degree', newDegree);
    
    // 4. Save the project
    window.saveProject();
    
    window.showModal(`Rotated to ${newDegree}°`, 'Info');
}



/**
 * Helper function to select an item and update the UI controls.
 */
 window.selectItem=function(element) {
    // ... (Existing code for selecting, deselecting, and setting activeItem) ...

    activeItem = element;
    activeItem.classList.add('selected');
    window.updateLockButtonState(); 
    window.updateEditButtonState();

    // --- PROPERTY SYNC START ---


    // 1. 同步 Border Radius
    // Use getComputedStyle for robustness, but activeItem.style is faster if set inline.
    document.getElementById('borderRadius').value = parseInt(activeItem.style.borderRadius) || 0; 
    document.getElementById('borderWidth').value = parseInt(activeItem.style.borderWidth) || 0; 
    document.getElementById('borderColor').value = activeItem.style.borderColor;
    document.getElementById('borderStyle').value = activeItem.style.borderStyle;
    // 2. 同步 Opacity 滑桿的值
    // Check both inline style and computed style for better accuracy
    const currentOpacity = parseFloat(activeItem.style.opacity || getComputedStyle(activeItem).opacity) || 1.0;
    // UI slider usually goes from 0-100, so multiply by 100
    document.getElementById('elementOpacity').value = Math.round(currentOpacity * 100);

    // 3. 同步 Background Color
    // Use getComputedStyle to retrieve the computed color (often RGB)
    let bgColor = activeItem.style.backgroundColor || getComputedStyle(activeItem).backgroundColor;
    document.getElementById('backgroundColor').value = bgColor ? 
        window.rgbToHex(bgColor) : '#ffffff';


    // 4. NEW/REVISED: 同步 Background Image URL
    let fullUrl = activeItem.style.backgroundImage || getComputedStyle(activeItem).backgroundImage;
    let imageUrl = '';
    
    // Check if a background image URL exists and extract it safely
    if (fullUrl && fullUrl !== 'none') {
        // Regex to extract the URL from 'url("...")' or 'url(...)'
        // The URL is typically captured in the second group ($2)
        const match = fullUrl.match(/url\(['"]?(.*?)['"]?\)/);
        
        if (match && match[1]) {
            imageUrl = match[1];
        }
    }

    const xurlInput = document.getElementById('Xurl');
    const bgiconImg = document.getElementById('bgicon');
    
    // Set the input field value
    xurlInput.value = imageUrl;

    // Set the preview icon
    if (imageUrl) {
        bgiconImg.src = imageUrl;
    } else {
        // If no background image, set the preview icon to your default SVG placeholder
        bgiconImg.src = 'data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23ffffff%22%20d%3D%22M287%2069.9%20146.2%20205.9%205.4%2069.9c-2.3-2.3-5.3-3.5-8.5-3.5h-10.7c-3.2%200-6.2%201.2-8.5%203.5-4.7%204.7-4.7%2012.3%200%2017l148.6%20148.6c4.7%204.7%2012.3%204.7%2017%200l148.6-148.6c4.7-4.7%204.7-12.3%200-17z%22%2F%3E%3C%2Fsvg%3E';
    }
    
             //@@@@@@@@@@@@取得 ID名稱或內文
	    document.getElementById('MyID').value=activeItem.id;
                if (activeItem.getElementsByTagName("span")){
		    if(activeItem.getElementsByTagName("span")[0]){
		     document.getElementById('MyInfo').value=activeItem.getElementsByTagName("span")[0].innerText;
		    }else{document.getElementById('MyInfo').value='';}
		 } 
		      

		if(gameMode==true){
                   if(activeItem.id==gameTarget){
		           window.speakText("correct");
		          score +=1;
                          if(document.getElementById('gameInfo')){
			    let mytext=	document.getElementById('gameInfo').innerText;
				myinfo=mytext.split('*');
				document.getElementById('gameInfo').innerHTML=myinfo[0]+'*<b>'+window.randomItem()+'</b>*'+myinfo[2];
                                window.speakText(document.getElementById('gameInfo').innerText);				
			  }else{
                           window.speakText('find '+window.randomItem());
			  }

                       }else{
			showModal(gameTarget,'error');
			// window.speakText("No,it's "+gameTarget); 
			score -=1;
                       }
		}
}




// ---  Gesture Handling Functions ---

     window.handleGestureStart=function(e) {
            // 只有在 'Select/Move' 模式下，且沒有選中任何元素時，才啟用滑動
            if (currentTool !== null || (activeItem !== null && !activeItem.classList.contains('locked'))) return;
            // if (currentTool !== null || activeItem !== null) return;          
            // 確保只處理單點觸摸或滑鼠點擊
            const clientX = e.clientX || e.touches[0].clientX;
            const clientY = e.clientY || e.touches[0].clientY;

            touchStartX = clientX;
            touchStartY = clientY;
            isSwiping = true;
        }

        window.handleGestureMove=function(e) {
            if (!isSwiping) return;

            const clientX = e.clientX || e.touches[0].clientX;
            const clientY = e.clientY || e.touches[0].clientY;

            const diffX = clientX - touchStartX;
            const diffY = clientY - touchStartY;
            
            // 優先考慮水平滑動，並防止頁面垂直滾動被鎖定
            if (Math.abs(diffX) > 300 || Math.abs(diffY) > 300) {
                // 如果水平移動明顯大於垂直移動，則阻止瀏覽器預設行為
                if (Math.abs(diffX) > Math.abs(diffY)) {
                    e.preventDefault(); 
                }
            }
        }

      window.handleGestureEnd=function(e) {
            if (!isSwiping) return;
            
            const clientX = e.clientX || e.changedTouches[0].clientX;
            // 不需要 finalY，因為我們只關心水平移動
            
            const diffX = clientX - touchStartX;
            isSwiping = false;

            // 檢查是否超過滑動閾值
            if (Math.abs(diffX) > SWIPE_THRESHOLD) {
                if (diffX >300) {
                    // 向右滑動 (X 增加) -> 切換到下一頁
                    window.goToNextPage();
                } else {
                    // 向左滑動 (X 減少) -> 切換到上一頁
                    window.goToPreviousPage();
                }
            }
        }



// --- NEW: Page Navigation Functions ---



         window.switchPage=function(pageId) {
            if (pageId === currentPageId) return; // Don't reload if it's the same page

            // 1. Save current page's state
             saveCurrentPageData();

            // 2. Set new current page
            currentPageId = pageId;

            // 3. Load new page's content
            loadPageData(pageId);
            
            // 4. Update UI
            renderPageList();
		//tempHTML=====htmlPageCode
		document.getElementById('htmlPageCode').value=document.getElementById('editor').innerHTML;
                //alert(tempHTML);=============換頁後產生暫存頁以供復原
        }


 window.goToPreviousPage = function() {
     window.resetSlides();
    // Get the index of the current page object
    const currentIndex = projectData.findIndex(p => p.id === currentPageId); 
    
    if (currentIndex > 0) {
        window.switchPage(projectData[currentIndex - 1].id);
    } else {
        window.showModal('已是第一頁', '頁數');
    }
}

window.goToNextPage = function() {
     window.resetSlides();
    // Get the index of the current page object
    const currentIndex = projectData.findIndex(p => p.id === currentPageId);
    
    if (currentIndex !== -1 && currentIndex < projectData.length - 1) {
        window.switchPage(projectData[currentIndex + 1].id);
    } else {
        window.showModal('已是最後一頁', '頁數');
    }
}
        // --- End of Page Navigation Functions ---



window.pushHistoryState=function() {
    // For now, we will save the project to persist the change immediately.
    // In a full implementation, this would push the current editor.innerHTML
    // onto an undo stack.
    window.saveProject();
    console.log("Element position/size saved to history (and Firestore).");
}




        //---------------------------------------Scratch-like Movement 
        window.initElements= function() {
            const elements = editor.querySelectorAll('.draggable-image, .floating-div');
            elements.forEach(el => initElement(el));
             editor.querySelectorAll('.draggable-image, .floating-div').forEach(window.initElementForMovement);
        }



/**
 * Displays a self-removing floating notification without Tailwind CSS.
 * @param {string} message - The message content.
 * @param {string} type - The type ('Info', 'Success', 'Error') to determine color.
 */
window.showModal = function(message, type = 'Info',target) {
    const modal = document.createElement('div');
    
    // 1. Determine background color based on type
    let bgColor;
    if (type === 'Error') {
        bgColor = '#dc2626'; // Red-600 equivalent
    } else if (type === 'Success') {
        bgColor = '#16a34a'; // Green-600 equivalent
    } else {
        bgColor = '#3b82f6'; // Blue-500 equivalent (Info)
    }

    // 2. Apply fixed positioning, styling, and color
    modal.style.cssText = `
        position: fixed;
        top: 40px; /* Adjusted to 40px for better placement */
        right: 20px;
        padding: 12px 20px;
        border-radius: 8px;
        color: white;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        z-index: 9999;
        background-color: ${bgColor};
        opacity: 1; /* Start visible */
        transition: opacity 0.5s ease-out, transform 0.5s ease-out;
        transform: translateY(0);
        font-family: sans-serif;
    `;
    
    modal.textContent = `${type}: ${message}`;
    document.body.appendChild(modal);

    // 3. Set timeout to start fade-out transition after 3 seconds
    setTimeout(() => {
        // Start the transition (fade out and move up)
        modal.style.opacity = '0';
        modal.style.transform = 'translateY(-20px)';
        
        // 4. Remove the element from the DOM after the transition is complete (0.5s)
        setTimeout(() => modal.remove(), 500);
    }, 3000); // Wait 3 seconds before starting the fade-out
};


       //=====================================復原HTML檔案

        window.restore=function(command) {

	   if(command){
	    const mypages=document.getElementById('htmlPageCode').value;

	    tempHTML=mypages;
		window.showModal('temp HTML loades','Info');
           		 const pageName = document.getElementById('fname').value;
	   }

             const canvasElement = document.getElementById('drawingCanvas');
 	  
            document.getElementById('editor').innerHTML = document.getElementById('htmlPageCode').value;
	
	  
            editor.prepend(canvasElement);

             clearCanvas();
   
            window.initElements();
            window.updateEditButtonState();
            window.updateLockButtonState();

	 }














/**
 * Checks if the active item is overlapping with the target item (gameTarget).
 * This is where the game scoring logic usually lives.
 * NOTE: The full game logic is inside selectItem, but this is the movement check.
 */
 window.checkOverlap=function(movedElement) {
    // If you are not in game mode, exit immediately
    if (gameMode !== true) return; 

    // Find the target element (assuming it has the ID stored in gameTarget)
    const targetElement = document.getElementById(gameTarget);
    if (!targetElement) return;

    // A simple bounding box check (replace with your detailed logic later)
    const movedRect = movedElement.getBoundingClientRect();
    const targetRect = targetElement.getBoundingClientRect();

    if (
        movedRect.left < targetRect.right &&
        movedRect.right > targetRect.left &&
        movedRect.top < targetRect.bottom &&
        movedRect.bottom > targetRect.top
    ) {
        // You might add a visual feedback here, e.g., targetElement.classList.add('highlight-overlap');
        // The actual scoring should probably only happen on click/drop, but a visual check is helpful.
        console.log(`Overlap detected with ${gameTarget}!`);
                        if(!otherItem.classList.contains('locked') && checkMode==true){
                            window.handleOverlap(otherItem);//--------------------------------------
		 targetElement.classList.add('highlight-overlap');	
	     }


    } else {
         targetElement.classList.remove('highlight-overlap');
    }
}



/**
 * Sets the rotation of the active item based on an ABSOLUTE angle
 * provided by the range slider.
 * * @param {string|number} newAngle - The absolute angle (0 to 359).
 */
window.setRotation = function(newAngle) {
    if (!activeItem) return;
    
    // Ensure the input is treated as an integer (from the slider)
    const angle = parseInt(newAngle);

    // If you need the rotation to only apply to the visual element, 
    // you only need the last three lines.
    
    // 1. Update the MOVEMENT axis (for movement logic)
    activeItem.setAttribute('data-degree', angle); 
    
    // 2. Update the VISUAL rotation
    activeItem.setAttribute('data-visual-degree', angle); 
    
    // 3. Apply the visual rotation
    activeItem.style.transform = `rotate(${angle}deg)`;
}


// --- NEW: Element Direction and Movement Functions ---

/**
 * Extends the existing initElement function to ensure a degree attribute exists.
 * @param {HTMLElement} el The element to initialize.
 */
window.zzzzzzzzzzinitElementForMovement =function(el) {
    // Call your existing initialization logic first
    // For example: initElement(el); 

    if (!el.hasAttribute('data-degree')) {
        el.setAttribute('data-degree', '0'); // Start facing 0 degrees (Up/North by default)
    }
    // Apply initial rotation based on the attribute
    el.style.transform = `rotate(${el.getAttribute('data-degree')}deg)`;
}

//------##################        Game MoveMent   ###################################################----------

/**
 * Sets the direction (movement axis) of the active item without changing its visual rotation.
 * @param {number} degrees The absolute degree to face (e.g., 90 for East, 180 for South).
 */
 window.pointInDirection=function(degrees) {
    if (!activeItem) return;

    // Normalize degrees and update the movement axis attribute only.
    const normalizedDegrees = degrees % 360; 
    activeItem.setAttribute('data-degree', normalizedDegrees);
    
    // NO CSS rotation is applied here.
}

/**
 * Changes the direction (rotation) of the active item by a relative amount.
 * This function now explicitly handles the VISUAL rotation.
 * @param {number} changeDegrees The amount to turn.
 */
 window.turn=function(changeDegrees) {
    if (!activeItem) return;

    // A. Update the MOVEMENT axis (data-degree)
    let currentMovementDegree = parseInt(activeItem.getAttribute('data-degree')) || 0;
    let newMovementDegree = currentMovementDegree + changeDegrees;
    // Set the new axis for 'move forward'
    activeItem.setAttribute('data-degree', newMovementDegree); 
    
    // B. Update the VISUAL rotation (data-visual-degree)
    let currentVisualDegree = parseInt(activeItem.getAttribute('data-visual-degree')) || 0;
    let newVisualDegree = currentVisualDegree + changeDegrees;
    
    // Store the new visual rotation
    activeItem.setAttribute('data-visual-degree', newVisualDegree); 
    
    // Apply the visual rotation
    activeItem.style.transform = `rotate(${newVisualDegree}deg)`;
}

 window.moveSteps=function(steps) {
    if (!activeItem) return;

    const currentX = activeItem.offsetLeft;
    const currentY = activeItem.offsetTop;
    
    // CRITICAL: This uses the data-degree (the movement axis)
    const degree = parseInt(activeItem.getAttribute('data-degree')) || 0; 

    // Convert degrees to radians (90 is subtracted because 0 deg movement axis should face right/East)
    const radians = (degree - 90) * (Math.PI / 180); 

    // Calculate new position
    const newX = currentX + (steps * Math.cos(radians));
    const newY = currentY + (steps * Math.sin(radians));

    // Update the element's position
    activeItem.style.left = `${newX}px`;
    activeItem.style.top = `${newY}px`;
}




 window.initElementForMovement=function(el) {
    // Call your existing initialization logic first
    // For example: initElement(el); 
    
    // --- 1. MOVEMENT DEGREE (Axis for 'move forward') ---
    if (!el.hasAttribute('data-degree')) {
        // Always default the movement axis to 90 (Right/East) for new/legacy items
        el.setAttribute('data-degree', '90'); 
    }

    // --- 2. VISUAL DEGREE (The saved CSS rotation) ---
    
    // A. Check if the element already has a CSS rotation saved from the JSON/HTML
    let visualDegreeMatch = el.style.transform.match(/rotate\(([-+]?\d+)deg\)/);
    let initialVisualDegree = 0;
    
    if (visualDegreeMatch) {
        // If rotation is found in the CSS style, use it.
        initialVisualDegree = parseInt(visualDegreeMatch[1]);
    } else if (el.hasAttribute('data-visual-degree')) {
        // If no rotation in CSS but the attribute exists (a newly saved file), use the attribute.
        initialVisualDegree = parseInt(el.getAttribute('data-visual-degree'));
    }

    // B. Check the `data-visual-degree` attribute state (for untouched legacy files)
    if (!el.hasAttribute('data-visual-degree')) {
        // If the element is from an OLD, UNTOUCHED file (no attributes),
        // we set the visual degree to 0. This PREVENTS the 90-degree default rotation.
        el.setAttribute('data-visual-degree', '0'); 
        
        // CRITICAL: We also need to apply the initial visual state.
        // For old files with no rotation, the CSS transform is missing.
        // We set it to 0 to prevent the browser from assuming a default of 90.
        el.style.transform = `rotate(0deg)`;
        
    } else {
        // For new files or files that have been rotated and saved, ensure the visual degree
        // attribute matches the rotation applied from the saved HTML content's style.
        el.setAttribute('data-visual-degree', initialVisualDegree); 
        el.style.transform = `rotate(${initialVisualDegree}deg)`;
    }
}


/**
 * Moves the active item to a target position over a specified duration using an animation loop. (   animateGoToPosition)
 * @param {string} targetValue The target: 'x,y' string or 'center' or Element ID.
 * @param {number} durationSeconds The time (in seconds) the animation should take (e.g., 2 for 2 seconds).
 */
 window.glideTo=function(targetValue, durationSeconds) {
    if (!activeItem) {
        window.showModal('Please select an item to move first.', 'Warning');
        return;
    }

    // --- 1. Calculate Target Position (Same as before) ---
    let targetX, targetY;
    
    if (targetValue.includes(',')) {
        // Case 1: X,Y coordinate
        const parts = targetValue.split(',').map(n => parseInt(n.trim()));
        if (parts.length === 2 && !isNaN(parts[0]) && !isNaN(parts[1])) {
            targetX = parts[0];
            targetY = parts[1];
        } else {
            window.showModal('Invalid coordinate format. Use "X,Y" (e.g., 100, 50).', 'Error');
            return;
        }
    } else if (targetValue === 'center') {
        // Case 2: Center
        const editor = document.getElementById('editor');
        targetX = (editor.offsetWidth / 2) - (activeItem.offsetWidth / 2);
        targetY = (editor.offsetHeight / 2) - (activeItem.offsetHeight / 2);
    } else {
        // Case 3: Element ID
        const targetElement = document.getElementById(targetValue);
        if (!targetElement) {
            window.showModal(`Target element "${targetValue}" not found.`, 'Error');
            return;
        }
        targetX = targetElement.offsetLeft;
        targetY = targetElement.offsetTop;
    }

    // --- 2. Initialize Animation Variables ---
    const startX = activeItem.offsetLeft;
    const startY = activeItem.offsetTop;
    const durationMs = durationSeconds * 1000;
    let startTime;
    
    // Check if movement is even necessary
    if (startX === targetX && startY === targetY) return;

    // --- 3. The Animation Loop ---
     window.step=function(timestamp) {
        if (!startTime) {
            startTime = timestamp;
        }

        // Calculate time elapsed since start
        const elapsed = timestamp - startTime;

        // Calculate progress (0.0 to 1.0)
        let progress = elapsed / durationMs;

        // Clamp progress to a maximum of 1.0
        if (progress > 1) {
            progress = 1;
        }

        // Linear Interpolation (Lerp)
        // new_value = start_value + (end_value - start_value) * progress
        const currentX = startX + (targetX - startX) * progress;
        const currentY = startY + (targetY - startY) * progress;

        // Apply new position
        activeItem.style.left = `${currentX}px`;
        activeItem.style.top = `${currentY}px`;

        // If animation is not finished, request the next frame
        if (progress < 1) {
            window.requestAnimationFrame(step);
        }
    }

    // Start the animation
    window.requestAnimationFrame(step);
}





/**
 * Moves the activeItem to a specific (X, Y) position or the position of another selected element. ( goToPositionOrElement(targetValue) )
 * @param {string} targetValue The target: either 'x,y' string (e.g., '100,50') or the ID/index of another element.
 */
 window.goTo=function(targetValue) {
    if (!activeItem) {
        window.showModal('Please select an item to move first.', 'Warning');
        return;
    }

    let targetX, targetY;

    if (targetValue.includes(',')) {
        // Case 1: Target is an X,Y coordinate (e.g., '100,50')
        const parts = targetValue.split(',').map(n => parseInt(n.trim()));
        if (parts.length === 2 && !isNaN(parts[0]) && !isNaN(parts[1])) {
            targetX = parts[0];
            targetY = parts[1];
        } else {
            window.showModal('Invalid coordinate format. Use "X,Y" (e.g., 100, 50).', 'Error');
            return;
        }
    } else {
        // Case 2: Target is another element (e.g., an item ID or the special 'center' value)
        if (targetValue === 'center') {
            const editor = document.getElementById('editor');
            // Calculate the center of the editor minus half the size of the active item
            targetX = (editor.offsetWidth / 2) - (activeItem.offsetWidth / 2);
            targetY = (editor.offsetHeight / 2) - (activeItem.offsetHeight / 2);
        } else {
            // Target is another element's ID (or another unique identifier, if you use them)
            const targetElement = document.getElementById(targetValue);
            
            if (!targetElement) {
                // Try to find the element by class/name if ID wasn't set.
                // NOTE: Using a simple querySelectorAll may not be reliable in your complex setup.
                // A reliable way is to ensure all floating/draggable items have unique IDs.
                window.showModal(`Target element "${targetValue}" not found.`, 'Error');
                return;
            }

            // Get the target element's position
            targetX = targetElement.offsetLeft;
            targetY = targetElement.offsetTop;
        }
    }
    
    // Apply the movement
    activeItem.style.left = `${targetX}px`;
    activeItem.style.top = `${targetY}px`;
}


//-----------####################### End GameMovement#########################################-----------

//---------########################      Speech Game    ###################################------------------

/**
 * Starts the speech recognition process for the given word.
 * @param {string} word The word the user is expected to say.
 */
// Global variable to store the currently spoken word the user is aiming for


// NOTE: Assuming these variables are declared in the global or outer scope:
// let recognition = null;
// let requiredWord = '';

 window.startVoiceRecognition=function(word) {

    if (!('webkitSpeechRecognition' in window)) {
        window.showModal('Your browser does not support Web Speech Recognition.', 'Error');
        return;
    }

    // 1. CRITICAL SCOPE FIX: Declare the flag locally so the nested event handlers can use it.
    let resultProcessed = false; 

    // 2. Setup the recognition object
    recognition = new webkitSpeechRecognition();
    recognition.lang = 'en-US'; 
    recognition.interimResults = false;
    recognition.maxAlternatives = 1;
    
    // --- COMPARISON & DISPLAY LOGIC ---
    
    // 3. Display Word: Store the original word (e.g., "RED-APPLE") for the user prompt.
    const displayWord = word; 

    // 4. Comparison Data: Clean and store the final comparison string in the shared 'requiredWord' variable.
    // This removes punctuation and sets it to lowercase for the robust check.
    const tempRequiredWord = word.toLowerCase(); 
    requiredWord = tempRequiredWord
        .trim()
        .replace(/[.,\/#!$%\^&\*;:{}=\-_`~()]/g, "") 
        .replace(/\s{2,}/g, " "); 
    // requiredWord is now ready for comparison.

    // Update UI to show what's required and listening state
    document.getElementById('speechResult').textContent = `Say: "${displayWord}"`;
    document.getElementById('speechResult').className = 'text-lg font-bold text-blue-600';
    document.getElementById('speechResult').style.display = '';
    document.getElementById('voiceButton').textContent = '🗣️ Listening... Say it now!';
    document.getElementById('voiceButton').disabled = true;

    // --- ON RESULT HANDLER ---
    recognition.onresult = function(event) {
         resultProcessed = true; // Flag indicates a result was received
        
        const rawTranscript = event.results[0][0].transcript;
        
        // Clean the SPOKEN transcript for comparison
        const cleanedTranscript = rawTranscript
            .toLowerCase()
            .trim()
            .replace(/[.,\/#!$%\^&\*;:{}=\-_`~()]/g, "")
            .replace(/\s{2,}/g, " ");
        
        // Compare the aggressively cleaned strings
        // NOTE: The comparison uses the global/shared 'requiredWord'
        let isCorrect = (cleanedTranscript === requiredWord); 
        
        // Display result
       // document.getElementById('speechResult').textContent = `You said: "${cleanedTranscript}" `;
        
        if (isCorrect) {
            document.getElementById('speechResult').className = 'text-lg font-bold text-green-600';
      document.getElementById('speechResult').textContent = `✅ Correct!You said: "${cleanedTranscript}" `;
            window.showModal(`✅ Correct! You said: ${cleanedTranscript}`, 'Success');
	window.speakText(` Correct! You said: ${cleanedTranscript}`);
        } else {
            document.getElementById('speechResult').className = 'text-lg font-bold text-red-600';
      document.getElementById('speechResult').textContent = `❌ Incorrect. You said: "${cleanedTranscript}" `;
            //showModal(`❌ Incorrect. You said: ${cleanedTranscript}. Try again.`, 'Error');
                 window.speakText(` Incorrect. You said: ${cleanedTranscript}. Try again.`);
        }
    };

    // --- ON END HANDLER (Crucial for state reset) ---
    recognition.onend = function() {
        // Reset button state
        document.getElementById('voiceButton').textContent = '🎙️ ▶️ ';
        document.getElementById('voiceButton').disabled = false;
        
        // Check the flag: If resultProcessed is false, no speech was successfully captured.
        if (!resultProcessed) {
             document.getElementById('speechResult').textContent = '...No speech detected or mic timed out. Try again.';
             document.getElementById('speechResult').className = 'text-lg font-bold text-gray-500';
        }
    };

     recognition.start();
}


 
/**
 * Asynchronously requests microphone access to force device selection.
 * This should be called before starting the Web Speech Recognition.
 * @returns {Promise<boolean>} True if access was granted and a stream opened.
 */
 window.ensureMicrophoneControl=async function() {
    try {
        // 1. Request access to the audio device only.
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        
        // 2. Access granted! Stop the stream immediately to release the device, 
        // but the browser/OS has now settled on the correct microphone.
        stream.getTracks().forEach(track => track.stop());
        
        return true;
    } catch (error) {
        // If the user denies permission, or no mic is found/working.
        console.error("Microphone access failed:", error);
        if (error.name === "NotAllowedError" || error.name === "PermissionDeniedError") {
            window.popBox("Microphone permission was denied. Please check your browser's site settings.", 'Error');
        } else {
            window.popBox("Could not access a microphone device. Please check your connections.", 'Error');
        }
        return false;
    }
}


/**
 * Finds all draggable images and starts the random recognition game.
 */
 window.startRandomVoiceGame= async function() {

// 💥 STEP 1: Ensure microphone access is secured 💥
    const micReady = await window.ensureMicrophoneControl();
    if (!micReady) {
        // Stop the function if access failed
       window.popBox('Mic is not ready','error');
        return; 
    }



    // 1. Find all potential target elements (draggable images and floating divs)
   // const possibleTargets = Array.from(document.getElementById('editor').querySelectorAll('.draggable-image, .floating-div'));
    const possibleTargets = Array.from(document.getElementById('editor').querySelectorAll('.draggable-image'));
    // 2. Filter elements that have a proper ID (which we'll use as the word)
    const candidates = possibleTargets.filter(el => el.id && el.id.trim() !== '');

    if (candidates.length === 0) {
        window.showModal('Please ensure your items have unique IDs (e.g., id="APPLE") to be part of the game.', 'Warning');
        document.getElementById('speechResult').textContent = 'No labeled items found.';
        return;
    }

    // 3. Select one candidate randomly
    const randomIndex = Math.floor(Math.random() * candidates.length);
    const selectedElement = candidates[randomIndex];
    
    // Use the ID as the word to be spoken
    const wordToSay = selectedElement.id;

    // Optional: Visually highlight the element that was chosen
    highlightElement(selectedElement);

    // 4. Start recognition for that word
    window.startVoiceRecognition(wordToSay);
}

/**
 * Simple function to highlight the target element.
 */
 window.highlightElement=function(el) {
    // Remove previous highlights
    document.getElementById('editor').querySelectorAll('.highlight-target').forEach(item => {
        item.classList.remove('highlight-target');
        item.style.border = 'none'; // Clear inline style if necessary
    });

    // Apply new highlight
    el.classList.add('highlight-target');
    el.style.border = '5px solid orange'; // Visible border highlight
    setTimeout(() => {
        el.style.border = 'none'; // Remove highlight after a moment
    }, 2000); 
}
//---------------##########################   End Speech Game     ################################################ 

         //頁面的題本傳到共用的測驗數據區供其他遊戲取用
  	 let quizSource=null;
 window.toggleGameTheme = function(theme, command) {
	//alert('old---textarea---'+document.querySelector('#quizData').innerText);
 	// alert('editor-----'+editor.querySelector('#quizArea').querySelector('#quizData').innerText);
        quizSource=editor.querySelector('#quizArea').querySelector('#quizData');
	//alert('source----'+quizSource.innerText);

         document.getElementById('quizData').innerText=quizSource.innerText;
	//alert('new---textarea---'+document.getElementById('quizData').innerText);
 
 
        if (!theme){ return;}
                launchWrapper.style.display = 'none';
               appContainer.style.display = 'flex';
              dualGameContainer.style.display = 'none';

        if (theme== 'none') {
                launchWrapper.style.display = 'none';
               appContainer.style.display = 'none';
              dualGameContainer.style.display = 'none';

            return;
         }

        if (theme === 'flasher') {
              launchWrapper.style.display = '';
              appContainer.style.display = 'none';

              //dualGameContainer.style.display = 'none';
              //dualGameContainer.style.display = 'flex';
        }
        if (theme === 'dual') {
              launchWrapper.style.display = 'none';
              appContainer.style.display = 'none';

              //dualGameContainer.style.display = 'none';
               dualGameContainer.style.display = 'flex';
        }     
        if (theme === 'quiz') { 
	       window.parsePsvAndLoadQuiz(editor.querySelector('#quizArea'));
                launchWrapper.style.display = 'none';
               appContainer.style.display = 'none';
              dualGameContainer.style.display = 'none';
		//return;
        }       
    }







//---------------##########################  測驗狀態管理     ################################################### 
    // 測驗狀態管理
    let quizData = [];
    let currentQuestionIndex = 0;
    //let score = 0;
    let isAnswered = false;
    let timerInterval = null; 
    let incorrectAnswers = []; 

 	//let quizDataElementX=document.getElementById('quizArea').querySelector('#quizData');

 

    window.createQuizFloatingDiv = function(color) {
        const textDiv = document.createElement('div');
        textDiv.className = 'floating-div quiz-instance'; 
        textDiv.style.left = `${lastClickPos.x}px`;
        textDiv.style.top = `${lastClickPos.y}px`;
        textDiv.setAttribute('contenteditable', 'false'); 
        textDiv.style.backgroundColor = color;
        textDiv.style.borderRadius = '16px'; 
        textDiv.style.padding = '5px';
        textDiv.style.minWidth = '300px'; 
        textDiv.style.cursor = 'grab'; 

        textDiv.innerHTML = window.getQuizUIHTML();
        
        editor.appendChild(textDiv);
        
        window.toggleEditMode(textDiv.querySelector('#quizArea'), true); 
        window.initElement(textDiv); 
    };

    window.initElement = function(element) {
        element.addEventListener('mousedown', (e) => {
            const isInteractive = e.target.closest('#quizData') || e.target.closest('.option-button') || e.target.closest('button');
            if (isInteractive) {
                element.style.cursor = 'default';
                return;
            } else {
                 element.style.cursor = 'grab';
            }
            // ... 您的拖動邏輯 ...
        });
    };













    /**
     * @brief 核心 UI 結構
     */
    window.getQuizUIHTML = function() {
        const htmlArray = [
            '<div id="quizArea" class="quiz-container flex flex-col items-center justify-center">',
             //'<div style="position:absolute;top:40px;left:-40px;width:40px;height:40px;z-index:10;border-radius:25px;" onclick="document.getElementById('quizArea').style.displaly=(document.getElementById('quizArea').style.displaly='none')?'':'none'" >?</div>',
            // --- 編輯數據模式 (Edit View) ---
            '<div id="edit_view" class="w-full" style="display: none;">',
            //'<h2 class="text-2xl font-bold mb-4 text-gray-800">編輯測驗數據 (支援試算表貼上)</h2>',
            // 修正：答案索引提示為 1-4
            '<p class="text-sm text-gray-600 mb-3 text-left font-bold">每行需要 7 個欄位: 題號|問題(含圖片)|正確答案索引(1-4)|選項A|選項B|選項C|選項D</p>',
            
            // 新增按鈕群組
            '<div class="flex space-x-2 mb-3">',
            '<button onclick="window.insertImageTag(this.closest(\'#quizArea\'))" class="flex-1 px-2 py-2 text-white bg-orange-500 rounded-lg hover:bg-orange-600 transition duration-150">🖼️ 插入圖片標籤</button>',
            '<button onclick="window.copyPsvToClipboard();document.getElementById(\'quizDataSource\').value=document.getElementById(\'quizData\').value" class="flex-1 px-2 py-2 text-white bg-green-600 rounded-lg hover:bg-green-700 transition duration-150">📋 複製測驗數據</button>',
            '</div>',

            '<div ',
            'id="quizData" ',
            'contenteditable="true" ',
            'onpaste="window.handlePastedData(event)"', 
            'class="w-full border border-gray-300 p-2 rounded-lg mb-4 focus:ring-blue-500 focus:border-blue-500"',
            'style="min-height: 200px; cursor: text; text-align: left;"',
            '>',
            // 預設數據使用垂直線分隔，以供參考，答案索引已改為 1 (代表選項 A)
            "1|哪個是正確的交通號誌？<img src='https://placehold.co/200x50/DDDDDD/000000?text=Question+Image' style='max-height: 50px; display: inline-block; border-radius: 4px; vertical-align: middle;'>|1|A: 停止標誌|B: 減速標誌|C: 讓路標誌|D: 禁止通行" +
            "<br>2|光速約為每秒多少公里？|1|300000|150000|500000|90000" +
            "<br>3|這是 Base64 編碼的圖片嗎？<img src='data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPSc1MCcgaGVpZ2h0PSc1MCc+PHJlY3Qgd2lkdGg9JzUwJyBoZWlnaHQ9JzUwJyBmaWxsPSdjY2MnLz48L3N2Zz4=' style='max-height: 50px; display: inline-block; border-radius: 4px; vertical-align: middle;'>|2|是|否|也許|不知道",
            '</div>',
            
            "    <button onclick=\"window.parsePsvAndLoadQuiz(this.closest('#quizArea'))\" class=\"w-full px-4 py-2 text-white bg-blue-600 rounded-lg hover:bg-blue-700\">載入並開始測驗</button>",
             " <button onclick=\"window.QS_launchGame(this.closest('#quizArea'));window.QS_parseAndLoadQuiz(this.closest('#quizArea'));\" class=\"w-full px-4 py-2 text-md font-semibold text-white bg-red-600 rounded-xl hover:bg-yellow-700 transition duration-150\">切水果</button>",           
            '<p id="errorMsg" class="text-red-500 mt-3 hidden">數據格式錯誤。</p>',
            '</div>',

            // --- 測驗顯示模式 (Quiz View) ---
            '<div id="quiz_view" class="w-full" style="display: none;">',
            //'<h3 class="text-3xl font-bold mb-4 text-blue-600">互動式測驗</h3>',


            '<div class="text-left mb-6">',
            '<span class="text-2xl font-extrabold mb-4 text-red-600" id="timerDisplay" style="display:inline">15s</span>',
            '<p class="text-gray-600 mb-2">問題 <span id="currentQIndex" class="font-bold">0</span> / <span id="totalQuestions" class="font-bold">0</span></p>',
            '<div class="w-full bg-gray-200 rounded-full h-2.5"><div id="progress" class="bg-blue-600 h-2.5 rounded-full" style="width: 0%"></div></div>',
            '</div>',

            '<div class="bg-blue-50 p-6 rounded-lg mb-6 shadow-md min-h-[150px] flex flex-col justify-center text-left">',
            '<div class="flex justify-between items-start mb-2">',
            '<p class="text-xl font-medium text-gray-800" id="questionText">點擊「編輯數據」按鈕載入測驗</p>',
            " <button onclick=\"window.speakQuestion(this.closest('#quizArea'))\" class=\"text-2xl ml-3 text-blue-500 hover:text-blue-700 transition\">🔊</button>",

            '</div>',
            '</div>',

            '<div id="optionsContainer" class="space-y-3"></div>',
            
            '<div class="mt-6 flex justify-between space-x-4">',
            " <button id=\"editButton\" onclick=\"window.toggleEditMode(this.closest('#quizArea'), true)\" class=\"px-4 py-2 text-md font-semibold text-white bg-gray-600 rounded-xl hover:bg-gray-700 transition duration-150\">編輯數據</button>",
            " <button id=\"nextButton\" onclick=\"window.nextQuestion(this.closest('#quizArea'))\" class=\"hidden px-6 py-3 text-lg font-semibold text-white bg-green-600 rounded-xl hover:bg-green-700 transition duration-150 shadow-lg shadow-green-500/50\">下一題</button>",
            '</div>',
            '</div>',
            '</div>'
        ];
        return htmlArray.join('\n');
    };
    
    // =========================================================================
    // IMAGE INSERT FUNCTION (FIXED with Selection API)
    // =========================================================================
    
    /**
     * @brief 提示用戶輸入圖片 URL 並插入標準化的 <img> 標籤到光標位置。
     * 使用 Selection API 確保精確插入和替換選區。
     */
    window.insertImageTag = function(quizArea) {
         const quizDataElement = quizArea.querySelector('#quizData');
        if (!quizDataElement) return;

        quizDataElement.focus(); // 確保元素獲得焦點

        const selection = window.getSelection();
        
        if (selection.rangeCount === 0 || !quizDataElement.contains(selection.anchorNode)) {
            // 如果沒有選區或選區不在 quizData 內，將光標設置到內容末尾
            const range = document.createRange();
            range.selectNodeContents(quizDataElement);
            range.collapse(false); // 塌陷到末尾
            selection.removeAllRanges();
            selection.addRange(range);
        }
        
        // 此時 selection 內一定有一個有效的 range
        const range = selection.getRangeAt(0);

        const url = prompt("請輸入圖片的 URL 地址 (例如: https://placehold.co/50x50):");
        if (!url) {
            window.popBox('圖片 URL 為空，已取消操作。', '取消');
            return;
        }

        const alt = prompt("請輸入圖片的簡短描述 (Alt Text):", "圖例");
        
        // 創建一個帶有 inline style 的標準化 <img ...> 標籤
        const imgHtml = `<img src='${url}' alt='${alt}' style='max-height: 50px; display: inline-block; border-radius: 4px; vertical-align: middle;'>`;

        // 1. 創建臨時 div 來解析 HTML 字符串
        const tempDiv = document.createElement('span');
        tempDiv.innerHTML = imgHtml;
        const fragment = document.createDocumentFragment();
        while (tempDiv.firstChild) {
            fragment.appendChild(tempDiv.firstChild);
        }

        // 2. 刪除選區內容 (這將替換任何選中的文本或元素)
        range.deleteContents(); 
        
        // 3. 插入新的節點
        range.insertNode(fragment);

        // 4. 將光標移動到插入內容之後
        selection.collapseToEnd();

        window.showModal('圖片標籤已成功插入到光標位置。', '圖片插入成功');
    };
    
    // =========================================================================
    // PASTE HANDLING FUNCTION
    // =========================================================================

    window.handlePastedData = function(event) {
        event.preventDefault();

        const text = event.clipboardData.getData('text/plain');
        const targetElement = event.target;

        let processedText = text.replace(/\t/g, '|');
        processedText = processedText.replace(/(\r\n|\n|\r)/g, '<br>');

        // 這裡我們仍然使用 innerHTML/execCommand 配合定位，因為貼上大量數據時效率更高
        targetElement.innerHTML = ''; 
        targetElement.focus();        
        document.execCommand('insertHTML', false, processedText);
        
        const selection = window.getSelection();
        const range = document.createRange();
        range.selectNodeContents(targetElement);
        range.collapse(false);
        selection.removeAllRanges();
        selection.addRange(range);

        window.showModal('試算表數據已貼上並轉換為 | 垂直線分隔格式。', '貼上成功');
    };

    // =========================================================================
    // QUIZ LOGIC (FIXED INDEXING)
    // =========================================================================

    window.speakQuestion = function(quizArea) {
        if ('speechSynthesis' in window) {
            const questionTextElement = quizArea.querySelector('#questionText');
            if (!questionTextElement) return;

            const textToSpeak = window.convertHtmlToText(questionTextElement.innerHTML);
            
            if (!textToSpeak) return;

            window.speechSynthesis.cancel(); 

            const utterance = new SpeechSynthesisUtterance(textToSpeak);
            
            const voices = window.speechSynthesis.getVoices();
            const zhVoice = voices.find(voice => voice.lang === 'zh-TW' || voice.lang === 'zh-CN');
            if (zhVoice) {
                utterance.voice = zhVoice;
            } else {
                utterance.lang = 'zh-TW'; 
            }
            
            utterance.rate = 1.0; 
            utterance.pitch = 1.0;

            window.speechSynthesis.speak(utterance);
        } else {
            window.popBox("您的瀏覽器不支持語音合成 (TTS) 功能。", "TTS 錯誤");
        }
    };

    window.popBox = function(content, title = '通知') {
        const modalTitle = document.getElementById('modalTitle');
        const modalBody = document.getElementById('modalBody');
        const modalOverlay = document.getElementById('modalOverlay');

        if (modalTitle) modalTitle.textContent = title;
        if (modalBody) modalBody.innerHTML = content;
        if (modalOverlay) modalOverlay.classList.remove('hidden');
    };

    window.toggleEditMode = function(quizArea, showEdit) {
        if (!quizArea) return;
        window.stopTimer(); 
        window.speechSynthesis.cancel(); 

        const editView = quizArea.querySelector('#edit_view');
        const quizView = quizArea.querySelector('#quiz_view');
        
        if (showEdit) {
            if (editView) editView.style.display = 'block';
            if (quizView) quizView.style.display = 'none';
        } else {
            if (editView) editView.style.display = 'none';
            if (quizView) quizView.style.display = 'block';
            window.renderQuestion(quizArea); 
        }
    };
    
    window.stopTimer = function() {
        if (timerInterval) {
            clearInterval(timerInterval);
            timerInterval = null;
        }
    };

    window.handleTimeout = function(quizArea) {
        window.stopTimer();
        window.speechSynthesis.cancel(); 
        const q = quizData[currentQuestionIndex];
        
        if (q && !isAnswered) { 
            isAnswered = true;
            
            incorrectAnswers.push({
                question: q.question, 
                correctAnswer: q.options[q.correctIndex] 
            });

            const correctText = q.options[q.correctIndex];
            const questionTextElement = quizArea.querySelector('#questionText');
            if (questionTextElement) questionTextElement.innerHTML = '時間到！這題的正確答案是：' + correctText;
            
            const optionsContainer = quizArea.querySelector('#optionsContainer');
            if (optionsContainer) {
                optionsContainer.querySelectorAll('button').forEach(btn => {
                    btn.disabled = true;
                    btn.classList.remove('hover:bg-blue-100');
                });
            }

            const nextButton = quizArea.querySelector('#nextButton');
            if (nextButton) nextButton.classList.remove('hidden');

            window.popBox('時間到！這題的答案是：' + window.convertHtmlToText(correctText), '自動跳過');
        }
    };
       
    window.startTimer = function(quizArea) {
        window.stopTimer(); 
        let timeLeft = 15;
        const timerDisplay = quizArea.querySelector('#timerDisplay');
        if (timerDisplay) timerDisplay.textContent = `${timeLeft}s`;

        timerInterval = setInterval(() => {
            timeLeft--;
            if (timerDisplay) timerDisplay.textContent = `${timeLeft}s`;

            if (timeLeft <= 0) {
                window.handleTimeout(quizArea);
            }
        }, 1000);
    };

                         let lines='';
			 
    window.parsePsvAndLoadQuiz = function(quizArea) {
         const quizDataElement = quizArea.querySelector('#quizData');
        const errorMsgElement = quizArea.querySelector('#errorMsg');
        document.getElementById('quizData').value=quizDataElement.innerHTML;
//alert('parsing:'+quizDataElement.innerHTML);
document.getElementById('quizArea').querySelector('#quizData').innerText=quizDataElement.innerText.trim();
//alert('DOM Xtextarea value:'+document.getElementById('quizArea').querySelector('#quizData').innerText);
        const rawHtmlText = quizDataElement.innerHTML.trim(); 
        let cleanedText = rawHtmlText.replace(/<br\s*\/?>/gi, '\n'); 
        cleanedText = cleanedText.replace(/<\/?(p|div|span)[^>]*>/gi, '\n');
        cleanedText = cleanedText.replace(/\s*\n\s*/g, '\n').trim();

          lines = cleanedText.split('\n').filter(line => line.trim() !== '');
 
        let validQuestions = [];
        let parsingError = false;
        let errorLine = -1;

        lines.forEach((line, index) => {
            const parts = line.split('|').map(part => part.trim()); 

            if (parts.length !== 7) { 
                errorLine = index + 1; 
                parsingError = true; 
                return; 
            }

            // 修正：從 1-based 索引開始解析 (1 到 4)
            const correctIndex1Based = parseInt(parts[2].trim()); 

            if (isNaN(correctIndex1Based) || correctIndex1Based < 1 || correctIndex1Based > 4) {
                 errorLine = index + 1; 
                 parsingError = true; 
                 return;
            }
            
            // 轉換為 0-based 索引供內部使用 (0 到 3)
            const correctIndex0Based = correctIndex1Based - 1; 

            validQuestions.push({
                id: parseInt(parts[0].trim()),
                question: parts[1].trim(),
                correctIndex: correctIndex0Based, 
                options: [parts[3].trim(), parts[4].trim(), parts[5].trim(), parts[6].trim()]
            });
        });
        
        if (parsingError || validQuestions.length === 0) {
            if (errorMsgElement) errorMsgElement.classList.remove('hidden');
            // 修正：更新錯誤訊息以反映 1-4 索引
            let message = '數據格式錯誤。請檢查每行是否有 **7 個欄位**，並以 **`|` 垂直線** 分隔，且正確答案索引在 **1-4 範圍內 (1=A, 4=D)**。';
            if (errorLine !== -1) { message = '**第 ' + errorLine + ' 行** 數據欄位數不正確或答案索引無效。請修正該行。'; }
            window.popBox(message, '解析錯誤');
            return;
        }
//alert(JSON.stringify(validQuestions));
        quizData = window.shuffleArray(validQuestions); 
        currentQuestionIndex = 0;
        score = 0;
        isAnswered = false;
        incorrectAnswers = []; 
        
        const totalQuestions = quizArea.querySelector('#totalQuestions');
        if (totalQuestions) totalQuestions.textContent = quizData.length;
        if (errorMsgElement) errorMsgElement.classList.add('hidden');
        
        window.toggleEditMode(quizArea, false); 
    };
    
    window.renderQuestion = function(quizArea) {
        window.stopTimer(); 
        window.speechSynthesis.cancel(); 

        if (currentQuestionIndex >= quizData.length) {
            window.showScore(quizArea);
            return;
        }

        const q = quizData[currentQuestionIndex];
        isAnswered = false;
        
        const nextButton = quizArea.querySelector('#nextButton');
        const questionText = quizArea.querySelector('#questionText');
        const currentQIndex = quizArea.querySelector('#currentQIndex');
        const progress = quizArea.querySelector('#progress');
        const optionsContainer = quizArea.querySelector('#optionsContainer');
        
        if (nextButton) nextButton.classList.add('hidden');
        
        const displayQuestion = q.question.trim() || "問題文本遺失或格式錯誤。";

        if (questionText) questionText.innerHTML = q.id + '. ' + displayQuestion;
        
        if (currentQIndex) currentQIndex.textContent = currentQuestionIndex + 1;
        
        const progressPercent = ((currentQuestionIndex) / quizData.length) * 100;
        if (progress) progress.style.width = `${progressPercent}%`;

        if (optionsContainer) optionsContainer.innerHTML = '';
        
        const optionLabels = ['A', 'B', 'C', 'D'];

        let optionsWithStatus = q.options.map((text, originalIndex) => ({
            text: text,
            isCorrect: originalIndex === q.correctIndex
        }));

        const shuffledOptions = window.shuffleArray(optionsWithStatus);
        
        shuffledOptions.forEach((option, index) => {
            const button = document.createElement('button');
            button.className = 'option-button w-full text-left p-4 rounded-lg bg-gray-100 hover:bg-blue-100 text-gray-800 font-medium shadow-sm';
            
            const optionText = option.text.trim() || "此選項數據遺失";
            
            const renderedOption = '<span class="font-bold mr-3">' + optionLabels[index] + '.</span> ' + optionText;
            
            button.innerHTML = renderedOption;
            
            button.onclick = () => window.checkAnswer(option.isCorrect, button, optionsContainer, shuffledOptions, quizArea);
            
            if (optionsContainer) optionsContainer.appendChild(button);
        });

        window.startTimer(quizArea); 
    };

    window.checkAnswer = function(isCorrect, button, container, shuffledOptions, quizArea) {
        if (isAnswered) return;
        isAnswered = true;
        window.stopTimer(); 
        window.speechSynthesis.cancel(); 

        const buttons = container.querySelectorAll('button');
        
        buttons.forEach(btn => {
            btn.disabled = true;
            btn.classList.remove('hover:bg-blue-100');
            btn.style.cursor = 'default';
        });

        if (isCorrect) {
            score++;
            button.classList.remove('bg-gray-100', 'hover:bg-blue-100');
            button.classList.add('bg-green-500', 'text-white', 'font-extrabold', 'ring-4', 'ring-green-400');
        } else {
            button.classList.remove('bg-gray-100', 'hover:bg-blue-100');
            button.classList.add('bg-red-500', 'text-white', 'font-extrabold', 'ring-4', 'ring-red-400');

            const q = quizData[currentQuestionIndex];
            incorrectAnswers.push({
                question: q.question,
                correctAnswer: q.options[q.correctIndex]
            });

            const correctOption = shuffledOptions.find(opt => opt.isCorrect);
            
            const correctOptionHtml = correctOption.text;
            
            const correctButton = Array.from(buttons).find(btn => btn.innerHTML.includes(correctOptionHtml));
            
            if (correctButton) {
                correctButton.classList.remove('bg-gray-100', 'hover:bg-blue-100');
                correctButton.classList.add('bg-green-200', 'text-green-800', 'border-4', 'border-dashed', 'border-green-600');
            }
        }

        const nextButton = quizArea.querySelector('#nextButton');
        if (nextButton) nextButton.classList.remove('hidden');
    };

    window.nextQuestion = function(quizArea) {
        currentQuestionIndex++;
        window.renderQuestion(quizArea);
    };
    
    /**
     * @brief 顯示最終分數
     */
    window.showScore = function(quizArea) {
        window.stopTimer(); 
        const total = quizData.length;
        
        const progress = quizArea.querySelector('#progress');
        const currentQIndex = quizArea.querySelector('#currentQIndex');
        const nextButton = quizArea.querySelector('#nextButton');
        const questionText = quizArea.querySelector('#questionText');
        const optionsContainer = quizArea.querySelector('#optionsContainer');
        
        const finalProgress = 100;
        if (progress) progress.style.width = `${finalProgress}%`;
        if (currentQIndex) currentQIndex.textContent = total;
        
        if (nextButton) nextButton.classList.add('hidden');
        if (questionText) questionText.textContent = `測驗完成！`;

        let reviewHTML = '';
        if (incorrectAnswers.length > 0) {
            reviewHTML += '<h4 class="text-xl font-bold mt-6 mb-3 text-red-600">❌ 錯題回顧:</h4>';
            reviewHTML += '<div class="space-y-4 text-left">';
            incorrectAnswers.forEach((item, index) => {
                reviewHTML += `<div class="p-3 bg-red-50 rounded-lg border border-red-200">`;
                
                const reviewQuestion = item.question;
                reviewHTML += '<p class="font-semibold text-gray-800">Q' + (index + 1) + ': ' + reviewQuestion + '</p>';
                
                const reviewAnswer = item.correctAnswer;
                reviewHTML += '<p class="text-sm text-green-700 mt-1">✓ 正確答案: ' + reviewAnswer + '</p>';
                reviewHTML += '</div>';
            });
            reviewHTML += '</div>';
        } else {
             reviewHTML += '<div class="text-2xl font-extrabold text-green-700 mt-4 mb-4">🎉 全部答對！表現優異！</div>';
        }
        
        if (optionsContainer) {
            optionsContainer.innerHTML = [
                '<div class="text-3xl font-extrabold text-blue-600 mt-4 mb-4">最終分數: ' + score + ' / ' + total + '</div>',
                '<div class="text-2xl font-bold text-gray-700 mb-6">得分率: ' + (((score / total) * 100).toFixed(1)) + '%</div>',
                reviewHTML
            ].join('\n');
        }
    };
    
    // =========================================================================
    // UTILITY FUNCTIONS 
    // =========================================================================
    
    window.shuffleArray = function(array) {
        let currentIndex = array.length, randomIndex;
        while (currentIndex != 0) {
            randomIndex = Math.floor(Math.random() * currentIndex);
            currentIndex--;
            [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
        }
        return array;
    };
    
    window.convertHtmlToText = function(htmlString) {
        const tempDiv = document.createElement('div');
        const cleanHtml = htmlString.replace(/<img[^>]*>/gi, '');
        tempDiv.innerHTML = cleanHtml;
        return tempDiv.textContent || tempDiv.innerText || '';
    };

    window.copyPsvToClipboard = function() {
        const quizDataElement = document.getElementById('quizData');

        if (!quizDataElement) return;

        try {
            const rawHtmlText = quizDataElement.innerHTML.trim(); 
            let cleanedText = rawHtmlText
                .replace(/<br\s*\/?>/gi, '\n')
                .replace(/<\/?(div|p|span)[^>]*>/gi, '\n') 
                .replace(/\s*\n\s*/g, '\n')
                .trim();

            const tempInput = document.createElement('textarea');
            tempInput.value = cleanedText;
            document.body.appendChild(tempInput);
            tempInput.select(tempInput);

            let success = false;
            try {
                success = document.execCommand('copy');
            } catch (err) {
                console.error('execCommand failed:', err);
            }
            document.body.removeChild(tempInput);

            if (success) {
                 window.showModal('測驗數據（垂直線分隔格式）已複製到剪貼簿！', '複製成功');
            } else {
                 window.popBox('無法自動複製，請手動選取並複製內容。', '複製失敗');
            }

        } catch (err) {
            console.error('Failed to copy text: ', err);
            window.popBox('無法自動複製，請手動選取並複製內容。', '複製失敗');
        }
document.getElementById('quizDataSource').value=rawHtmlText;
    };
    
    // =========================================================================
    // UTILITY FUNCTIONS 
    // =========================================================================
    
    window.shuffleArray = function(array) {
        let currentIndex = array.length, randomIndex;
        while (currentIndex != 0) {
            randomIndex = Math.floor(Math.random() * currentIndex);
            currentIndex--;
            [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
        }
        return array;
    };
    
    window.convertHtmlToText = function(htmlString) {
        const tempDiv = document.createElement('div');
        const cleanHtml = htmlString.replace(/<img[^>]*>/gi, '');
        tempDiv.innerHTML = cleanHtml;
        return tempDiv.textContent || tempDiv.innerText || '';
    };

    window.copyPsvToClipboard = function() {
        const quizDataElement = document.getElementById('quizData');
        if (!quizDataElement) return;

        try {
            const rawHtmlText = quizDataElement.innerHTML.trim(); 
            let cleanedText = rawHtmlText
                .replace(/<br\s*\/?>/gi, '\n')
                .replace(/<\/?(div|p|span)[^>]*>/gi, '\n') 
                .replace(/\s*\n\s*/g, '\n')
                .trim();

            const tempInput = document.createElement('textarea');
            tempInput.value = cleanedText;
            document.body.appendChild(tempInput);
            tempInput.select();
            
            let success = false;
            try {
                success = document.execCommand('copy');
            } catch (err) {
                console.error('execCommand failed:', err);
            }
            document.body.removeChild(tempInput);

            if (success) {
                 window.showModal('測驗數據（垂直線分隔格式）已複製到剪貼簿！', '複製成功');
            } else {
                 window.popBox('無法自動複製，請手動選取並複製內容。', '複製失敗');
            }

        } catch (err) {
            console.error('Failed to copy text: ', err);
            window.popBox('無法自動複製，請手動選取並複製內容。', '複製失敗');
        }
    };
//======================== 切水果遊戲開始===========================================================================
 

          // --- 全域遊戲狀態變數 ---
        let QS_quizData = []; 
        let QS_currentQuestionIndex = 0; 
        let QS_gameScore = 0; 
        let QS_lives = 3;
        
        // --- 遊戲狀態 & UI 元素 ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('game-score');
        const livesDisplay = document.getElementById('lives');
        const messageBox = document.getElementById('message-box');
        const messageText = document.getElementById('message-text');
        const initialStartButton = document.getElementById('initial-start-button');
        const currentQuestionDisplay = document.getElementById('current-question');
        const appContainer = document.getElementById('app-container');
        const launchWrapper = document.getElementById('launch-wrapper');
        const quizMessageDetail = document.getElementById('quiz-message-detail');
        const quizEditor = document.getElementById('quiz-editor');
        const gameStartMessage = document.getElementById('game-start-message');
        const totalQuestionsLoaded = document.getElementById('total-questions-loaded');
        const errorMsgElement = document.getElementById('errorMsg');
        
        // 關鍵：對可編輯 DIV 的引用，用於讀取當前內容
 
        let quizDataElementX = document.getElementById('quizData'); 

        let isRunning = false;
        let lastTime = 0;
        let targets = []; 
        let particles = [];
        const maxParticles = 50;
        let mousePath = [];
        const maxPathLength = 5;
        
        // --- 輔助函式 ---

        const QS_updateLoadedQuestionCount = function() {
            totalQuestionsLoaded.textContent = QS_quizData.length;
        };

        const showMessage = function(title, detail, buttonText = "確定", buttonCallback) {
            messageText.textContent = title;
            quizMessageDetail.innerHTML = detail;
            initialStartButton.textContent = buttonText;
            
            if (buttonCallback) {
                 initialStartButton.onclick = buttonCallback;
            } else {
                 // 預設行為：顯示編輯器
                 initialStartButton.onclick = function() { window.QS_toggleEditMode(true); };
            }
            
            messageBox.classList.remove('opacity-0', 'pointer-events-none');
            quizEditor.classList.add('hidden'); 
            gameStartMessage.classList.remove('hidden');
        };

        window.QS_runDiagnostic = function() {
            // 診斷功能仍從 live DOM 讀取，因為它是為了展示讀取結果。
		    let areaq=document.getElementById('quizArea');
            const innerText=document.getElementById('quizArea').querySelector('#quizData').innerText;
            const htmlContent = `
                <h3 class="text-xl font-bold text-red-400 mb-2">測驗資料 DOM 診斷結果（ID: #quizData）</h3>
                <p class="text-gray-300 text-sm mb-4">解析器現在使用 **.innerHTML + 清理** 來讀取。</p>

                <div class="bg-gray-800 p-3 rounded-lg overflow-x-auto text-left space-y-2" id="diagnostic-display">
                    <p class="text-orange-400 font-bold">1. .innerText (原始純文字):</p>
                    <pre class="bg-gray-900 p-2 rounded text-xs text-green-300">${innerText.substring(0, 500)}...</pre>
                </div>
            `;
            
            showMessage("資料診斷完成", htmlContent, "返回編輯器", function() {
                 window.QS_toggleEditMode(true); 
            });
        }
        
        const shuffleArray = function(array) { 
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        };

        const resizeCanvas = function() { 
            const parent = canvas.parentNode;
            canvas.width = parent.clientWidth;
            canvas.height = parent.clientHeight;
        };
        
        class GameElement { 
            constructor(text, x, y, radius, isCorrect) {
                this.text = text;
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.isCorrect = isCorrect;
                this.color = isCorrect ? 'rgb(52, 211, 153)' : 'rgb(239, 68, 68)'; 
                this.gravity = 0.05; 
                this.vy = -Math.random() * 5 - 4; 
                this.vx = (Math.random() - 0.5) * 3; 
                this.isSliced = false;
            }
            update() {
                this.vy += this.gravity;
                this.x += this.vx;
                this.y += this.vy;
            }
            draw() {
                if (this.isSliced) return;
                
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();

                ctx.fillStyle = 'white';
                ctx.font = 'bold 16px Inter';
                ctx.textAlign = 'center';
                const display_text = this.text.length > 12 ? this.text.substring(0, 10) + '...' : this.text;
                ctx.fillText(display_text, this.x, this.y + 5); 
            }
        };
        
        class Particle { 
             constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.size = Math.random() * 3 + 1;
                this.color = color;
                this.vx = (Math.random() - 0.5) * 5;
                this.vy = (Math.random() - 0.5) * 5;
                this.alpha = 1;
                this.decay = 0.05;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.alpha -= this.decay;
                if (this.alpha < 0) this.alpha = 0;
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.globalAlpha = this.alpha;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        };
        
        // --- 修正後的 spawnTargets 函式：現在接受一個包含所有 4 個選項資料的陣列 ---
        const spawnTargets = function(targetData) { 
            targets = [];
            const radius = 45; 
            const y = canvas.height + radius; 
            const totalTargets = targetData.length; // 應該是 4 個

            // 1. 隨機打亂選項，以便它們在畫布上隨機出現
            const shuffledData = shuffleArray(targetData); 

            // 2. 根據目標數量計算間距，以確保它們不會重疊
            const spacing = canvas.width / (totalTargets + 1);

            shuffledData.forEach((data, index) => {
                // X 位置：在間距中均勻分佈
                const x = spacing * (index + 1);
                
                const target = new GameElement(data.text, x, y, radius, data.isCorrect);
                // 為了讓它們稍微錯開，調整水平速度
                target.vx = (Math.random() - 0.5) * 3;
                targets.push(target);
            });
        }
        // --- 結束修正後的 spawnTargets 函式 ---


        const generateParticles = function(x, y, color) { 
            for (let i = 0; i < maxParticles; i++) {
                particles.push(new Particle(x, y, color));
            }
        };

        const gameOver = function(allQuestionsCompleted, outOfLives, error = false) { 
            isRunning = false;
            targets = []; 
            
            initialStartButton.textContent = "再玩一次";
            initialStartButton.onclick = window.QS_startQuiz; 
            
            if (error) {
                messageText.textContent = "嚴重資料錯誤";
                quizMessageDetail.textContent = "遊戲因測驗資料結構問題而停止。";
            } else if (allQuestionsCompleted) {
                messageText.textContent = "測驗大師！";
                quizMessageDetail.textContent = `恭喜你！你完成了所有 ${QS_quizData.length} 個問題。最終分數：${QS_gameScore}。`; 
            } else if (outOfLives) {
                messageText.textContent = "遊戲結束！生命值耗盡。";
                quizMessageDetail.textContent = `你用完了所有生命！你答對了 ${QS_gameScore} 題。點擊「再玩一次」重試。`; 
            } else {
                 messageText.textContent = "遊戲結束！";
                 quizMessageDetail.textContent = `最終分數：${QS_gameScore}。點擊再玩一次！`;
            }
            
            QS_updateLoadedQuestionCount(); 
            quizEditor.classList.add('hidden');
            gameStartMessage.classList.remove('hidden');
            messageBox.classList.remove('opacity-0', 'pointer-events-none');
        };


        const launchNextItem = function() { 
            targets = []; 
            
            if (QS_lives <= 0) { 
                gameOver(false, true); 
                return;
            }

            if (QS_currentQuestionIndex >= QS_quizData.length || QS_quizData.length === 0) { 
                if (QS_quizData.length > 0) {
                    gameOver(true, false);
                } else {
                    showMessage('無測驗資料！', '請先使用「編輯資料」按鈕載入測驗問題。', '編輯資料');
                }
                return;
            }
            
            const questionObj = QS_quizData[QS_currentQuestionIndex]; 

            if (!questionObj || questionObj.options.length !== 4) {
                 currentQuestionDisplay.textContent = "錯誤：資料結構無效或資料遺失。";
                 gameOver(false, false, true); 
                 return;
            }

            const question = questionObj.question;
            const correctIndex1Based = questionObj.correctIndex; 
            const allOptions = questionObj.options;
            
            const correctIndex0Based = correctIndex1Based - 1; 

            // --- 修正後的邏輯：準備所有 4 個目標的資料 ---
            const targetData = allOptions.map(function(option, index) {
                return {
                    text: option,
                    isCorrect: index === correctIndex0Based
                };
            });
            // --- 結束修正後的邏輯 ---

            currentQuestionDisplay.innerHTML = `Q ${QS_currentQuestionIndex + 1}/${QS_quizData.length}: ${question}`; 
            
            // 使用包含所有選項的新資料陣列呼叫 spawnTargets
            spawnTargets(targetData);
            isRunning = true; 
        };
        
        const checkSlice = function(x, y) { 
             for (let i = targets.length - 1; i >= 0; i--) {
                const target = targets[i];
                if (target.isSliced) continue;

                const distance = Math.sqrt(Math.pow(target.x - x, 2) + Math.pow(target.y - y, 2));

                if (distance < target.radius) {
                    target.isSliced = true;
                    generateParticles(target.x, target.y, target.color);
                    
                    if (target.isCorrect) {
                        QS_gameScore += 1; 
                        currentQuestionDisplay.textContent = `答對了！你切了正確答案: ${target.text}。+1 分。`;
                        QS_currentQuestionIndex++; 
                    } else {
                        QS_lives -= 1; 
                        currentQuestionDisplay.textContent = `錯誤！你切了錯誤答案: ${target.text}。-1 生命。`;
                    }
                    
                    // 當切中任何一個目標後，清除所有未切的目標並進入下一個問題
                    // 為了防止連續切中多個目標，我們只處理第一個切中的事件
                    
                    // 清除所有未切的目標 (它們會從螢幕上移除，但不會觸發 miss 邏輯)
                    targets.forEach(t => {
                        if (!t.isSliced) t.isSliced = true;
                    });
                    
                    if (QS_lives > 0) {
                        // 延遲啟動下一個問題，以便粒子效果顯示
                        setTimeout(launchNextItem, 500); 
                    } else {
                        gameOver(false, true); 
                    }

           if(QS_currentQuestionIndex == QS_quizData.length){
               // alert('pass');
             //window.popBox(QS_currentQuestionIndex+'---'+QS_quizData.length,'');
           window.popBox(`恭喜你！你完成了所有 ${QS_quizData.length} 個問題。最終分數：${QS_gameScore}。`,'');
                //quizMessageDetail.textContent = `恭喜你！你完成了所有 ${QS_quizData.length} 個問題。最終分數：${QS_gameScore}。`; 
               // gameOver(allQuestionsCompleted,false); 
           }
                    return;
                }
            }
        };

        const gameLoop = function(timestamp) { 
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            let correctTargetMissed = false; 

            for (let i = targets.length - 1; i >= 0; i--) {
                const target = targets[i];
                
                if (isRunning && !target.isSliced) target.update();

                target.draw();

                if (target.y > canvas.height + target.radius * 2) {
                    // 如果正確答案被錯過 (到達底部)
                    if (target.isCorrect && !target.isSliced) {
                        if (isRunning) { 
                            QS_lives -= 1; 
                            currentQuestionDisplay.textContent = `錯過正確答案：${target.text}！-1 生命。`;
                            correctTargetMissed = true; 
                        }
                    }
                    targets.splice(i, 1);
                }
            }
            
            // 如果正確目標被錯過，則進入下一個問題
            if (correctTargetMissed) {
                // 清除所有剩餘的目標，因為問題已經結束了
                targets = [];
                QS_currentQuestionIndex++;
                if (QS_lives > 0) { 
                    launchNextItem(); 
                } else {
                    gameOver(false, true); 
                }
                // 立即返回，不執行剩餘的繪圖或動畫邏輯
                return;
            };


            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.update();
                p.draw();
                if (p.alpha <= 0) {
                    particles.splice(i, 1);
                }
            }

            if (mousePath.length > 1) {
                ctx.globalAlpha = 0.8;
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 5;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(mousePath[0].x, mousePath[0].y);
                for (let i = 1; i < mousePath.length; i++) {
                    ctx.lineTo(mousePath[i].x, mousePath[i].y);
                }
                ctx.stroke();
                ctx.globalAlpha = 1;
            }

            scoreDisplay.textContent = QS_gameScore; 
            livesDisplay.textContent = QS_lives; 

            
            requestAnimationFrame(gameLoop);
        }
        
        const getCanvasMousePosition = function(e) { 
            const rect = canvas.getBoundingClientRect();
            let x, y;

            if (e.touches && e.touches.length > 0) {
                x = e.touches[0].clientX - rect.left;
                y = e.touches[0].clientY - rect.top;
            } else {
                x = e.clientX - rect.left;
                y = e.clientY - rect.top;
            }

            return { x, y };
        };

        let isSlicing = false;
        
        const startSlicing = function(e) { 
            if (!isRunning) return;
            isSlicing = true;
            const pos = getCanvasMousePosition(e);
            mousePath = [pos];
            checkSlice(pos.x, pos.y);
        };

        const moveSlicing = function(e) { 
            if (!isRunning || !isSlicing) return;
            e.preventDefault(); 
            const pos = getCanvasMousePosition(e);
            
            mousePath.push(pos);
            while (mousePath.length > maxPathLength) {
                mousePath.shift();
            }

            if (mousePath.length >= 2) {
                checkSlice(pos.x, pos.y);
            }
        };

        const endSlicing = function() { 
            isSlicing = false;
            mousePath = []; 
        };


        // --- 全域入口函式 ---

        window.QS_toggleEditMode = function(show) {
            if (show) {
                document.getElementById('quizDataSource').value = quizDataElementX.innerText;
                quizEditor.classList.remove('hidden'); 
                gameStartMessage.classList.add('hidden');
                messageBox.classList.remove('opacity-0', 'pointer-events-none');
            } else {
                quizEditor.classList.add('hidden');
                gameStartMessage.classList.remove('hidden');
                if (QS_quizData.length > 0) {
                     messageBox.classList.add('opacity-0', 'pointer-events-none');
                }
            }
        };


        window.QS_launchGame = function(s,m) {
            if(m=='slasher'){
                launchWrapper.style.display = 'none';
               appContainer.style.display = 'flex';
              // launchWrapper.classList.remove('hidden');               
               //appContainer.classList.remove('hidden'); 
            }else{
               //launchWrapper.style.display = 'none';               
               //appContainer.style.display = 'flex';
              // launchWrapper.classList.add('hidden');               
               //appContainer.classList.add('hidden'); 
           }
             resizeCanvas(); 
            
             // 遊戲啟動後，強制進入編輯模式，讓用戶點擊「載入」
             showMessage('測驗斬擊啟動', '請點擊「編輯資料」以載入或輸入您的 PSV 格式測驗數據。', '編輯資料', function() {
                 window.QS_toggleEditMode(true); 
             });
        };

        // 【關鍵修正】：使用 innerHTML + 正則表達式進行資料淨化與解析
        window.QS_parseAndLoadQuiz = function() {
            // 1. 從 DOM 獲取原始文字，使用 innerHTML 以捕獲 <br> 和其他標籤
            const rawHtmlText = quizDataElementX.innerHTML.trim();
            
            // 2. 嚴格資料淨化：將編輯器可能插入的 HTML 標籤轉換為標準換行符 (\n)
            let cleanedText = rawHtmlText.replace(/<br\s*\/?>/gi, '\n'); // 替換 <br>
            cleanedText = cleanedText.replace(/<\/?(p|div|span)[^>]*>/gi, '\n'); // 替換 <p>, <div>, <span>
            // 標準化換行符，確保沒有連續換行或多餘的空白
            cleanedText = cleanedText.replace(/\s*\n\s*/g, '\n').trim(); 

            // 3. 按標準 \n 拆分，並過濾掉空行
            const lines = cleanedText.split('\n').filter(function(line) { return line.trim() !== ''; });
            
            let validQuestions = [];
            let parsingError = false;
            let errorLine = -1;

            lines.forEach(function(line, index) {
                // 4. 按 PSV 分隔符 (|) 分割，並清理每個部分的空白
                const parts = line.split('|').map(function(part) { return part.trim(); }); 

                if (parts.length !== 7) { 
                    errorLine = index + 1; 
                    parsingError = true; 
                    return; 
                }

                const rawIndex = parts[2].trim();
                const correctIndex1Based = parseInt(rawIndex, 10); 
                
                // 檢查索引是否為 1 到 4 之間的乾淨數字
                if (isNaN(correctIndex1Based) || correctIndex1Based < 1 || correctIndex1Based > 4 || String(correctIndex1Based) !== rawIndex) {
                    errorLine = index + 1; 
                    parsingError = true; 
                    return;
                }
                
                validQuestions.push({
                    id: parseInt(parts[0].trim()),
                    question: parts[1].trim(),
                    correctIndex: correctIndex1Based, // 保持 1-based 索引以符合遊戲邏輯
                    options: [parts[3].trim(), parts[4].trim(), parts[5].trim(), parts[6].trim()]
                });
            });
            
            errorMsgElement.classList.add('hidden');

            // 錯誤處理
            if (parsingError || validQuestions.length === 0) {
                const message = `
                    <p class="font-extrabold text-red-300">第 ${errorLine} 行格式不正確，或者「正確選項索引」不是乾淨的 1 到 4 之間的數字。</p>
                    <p class="mt-2 text-sm">請檢查格式: ID | 問題 | **正確選項索引 (1-4, 必須是數字)** | 選項1 | 選項2 | 選項3 | 選項4</p>
                `;
                showMessage('資料解析錯誤', message, '修正資料', function() {
                     window.QS_toggleEditMode(true); 
                });
                QS_quizData = [];
                QS_updateLoadedQuestionCount();
                return;
            }

            // 成功解析：更新全域資料並重設遊戲狀態
            // 將編輯器內容保存回 quizDataElementX，以便下次編輯時顯示最新內容
            quizDataElementX.innerText = document.getElementById('quizDataSource').value;
            
            QS_quizData = shuffleArray(validQuestions); 
            QS_currentQuestionIndex = 0; 
            QS_gameScore = 0;
            QS_lives = 3;
            
            QS_updateLoadedQuestionCount();
            
            // 成功載入後，直接開始遊戲
            window.QS_startQuiz();
        };

        window.QS_startQuiz = function() {
            if (QS_quizData.length === 0) {

                showMessage('無測驗資料！', '請先使用「編輯資料」按鈕載入測驗問題。', '編輯資料');

                return;
            }
            // 確保所有狀態完全重置 (以防從 Game Over 狀態重啟)
            QS_currentQuestionIndex = 0; 
            QS_gameScore = 0;
            QS_lives = 3;
            targets = [];
            particles = [];
            
            messageBox.classList.add('opacity-0', 'pointer-events-none');
            
            // 啟動遊戲
            launchNextItem();
            
            lastTime = performance.now();
        };
        
        // --- 初始化 ---
        canvas.addEventListener('mousedown', startSlicing);
        canvas.addEventListener('mousemove', moveSlicing);
        canvas.addEventListener('mouseup', endSlicing);
        canvas.addEventListener('mouseleave', endSlicing); 

        canvas.addEventListener('touchstart', startSlicing);
        canvas.addEventListener('touchmove', moveSlicing);
        canvas.addEventListener('touchend', endSlicing);
        canvas.addEventListener('touchcancel', endSlicing);
        
        window.addEventListener('load', function() {
            // 在 load 時確保 quizDataElementX 被正確初始化
            quizDataElementX = document.getElementById('quizArea').querySelector('#quizData');
            
            // 將隱藏的資料複製到編輯器
            document.getElementById('quizDataSource').value = quizDataElementX.innerText.trim();

            resizeCanvas();
            // 啟動遊戲 loop
            requestAnimationFrame(gameLoop); 

            // 啟動遊戲
            window.QS_launchGame();

        });

        window.addEventListener('resize', resizeCanvas);
            //launchWrapper.style.display = 'none';
            //appContainer.style.display = 'flex';

             launchWrapper.style.display = 'none';
             //appContainer.style.display = 'none';
              //dualGameContainer.style.display = 'flex';
//=========================切水果遊戲結束======================================================================
//=========================================================== Dual player Game


        // --- START OF IIFE FOR SCOPE ISOLATION ---
        (function() {
            const startGameButton = document.getElementById('startGameButton');
            const dualGameContainer = document.getElementById('dualGameContainer');
            
            const shuffleArray = (array) => {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
            };

            function initializeAndStartGame() {
                if (dualGameContainer.dataset.initialized === 'true') return;
                dualGameContainer.dataset.initialized = 'true';

                const canvas = document.getElementById('dualGameCanvas');
                const ctx = canvas.getContext('2d');
                
                const p1ScoreDisplay = document.getElementById('p1-score');
                const p2ScoreDisplay = document.getElementById('p2-score');

                let CANVAS_WIDTH = 0;
                let CANVAS_HEIGHT = 0;
                let VIEW_WIDTH = 0;
                let ANSWER_SPACING = 0; 
                let answerBoxes = []; 

                const PLAYER_SIZE_RATIO = 0.04; 
                let PLAYER_SPEED_PIXELS = 0; 
                const ANSWER_BOX_COUNT = 4;
                const ANSWER_BOX_SIZE_RATIO = 0.16; 

                let externalQuizSet = [];
                let currentQuizIndex = 0;
                let successMessage = null; // New state for success message

                // --- Data Parsing (ULTRA-ROBUST FIX V2) ---
                const parseQuizData = () => {
                    const quizDataElement = document.getElementById('quizArea').querySelector('#quizData');
                    if (!quizDataElement) {
                        console.error("Quiz data element not found.");
                        return;
                    }
                    
                    try {
                        let dataString = quizDataElement.textContent.trim();
  
            // 1. 從 DOM 獲取原始文字，使用 innerHTML 以捕獲 <br> 和其他標籤
            const rawHtmlText = quizDataElementX.innerHTML.trim();
            
            // 2. 嚴格資料淨化：將編輯器可能插入的 HTML 標籤轉換為標準換行符 (\n)
            let cleanedText = rawHtmlText.replace(/<br\s*\/?>/gi, '\n'); // 替換 <br>
            cleanedText = cleanedText.replace(/<\/?(p|div|span)[^>]*>/gi, '\n'); // 替換 <p>, <div>, <span>
            // 標準化換行符，確保沒有連續換行或多餘的空白
            cleanedText = cleanedText.replace(/\s*\n\s*/g, '\n').trim(); 

            // 3. 按標準 \n 拆分，並過濾掉空行
            const lines = cleanedText.split('\n').filter(function(line) { return line.trim() !== ''; });




                      
                       
                        externalQuizSet = lines.map((item, index) => {
                            // Split each item by the pipe '|' and remove leading/trailing spaces from parts
                            const parts = item.split('|').map(p => p.trim());
                            
                            if (parts.length < 7) {
                                console.warn(`Skipping malformed quiz item at index ${index}. Expected 7 parts (ID|Q|ANS_INDEX|A|B|C|D), got ${parts.length}. Data:`, item);
                                return null;
                            }
                            
                            const correctIndex1Based = parseInt(parts[2]);
                            if (isNaN(correctIndex1Based) || correctIndex1Based < 1 || correctIndex1Based > 4) {
                                console.error(`Invalid correct index for item ID ${parts[0]}: ${parts[2]}. Must be 1, 2, 3, or 4.`);
                                return null;
                            }
                            
                            return {
                                id: parts[0],
                                question: parts[1],
                                correctIndex: correctIndex1Based - 1, // Convert 1-based index to 0-based
                                answers: [parts[3], parts[4], parts[5], parts[6]]
                            };
                        }).filter(q => q !== null);
                        
                        if (externalQuizSet.length > 0) {
                            shuffleArray(externalQuizSet); // Shuffle questions on load
                        }
                        console.log(`Loaded ${externalQuizSet.length} unique quiz questions.`);

                    } catch(e) {
                        console.error("CRITICAL QUIZ PARSING ERROR:", e);
                        console.log("Please ensure your quizData strictly follows the format: ID|QUESTION|CORRECT_INDEX|A|B|C|D");
                        externalQuizSet = [];
                    }
                };
                
                // --- Game State ---
                const players = {
                    p1: { score: 0, x: 0, y: 0, color: '#3b82f6', controls: { up: 'w', down: 's', left: 'a', right: 'd' } },
                    p2: { score: 0, x: 0, y: 0, color: '#ef4444', controls: { up: 'ArrowUp', down: 'ArrowDown', left: 'ArrowLeft', right: 'ArrowRight' } }
                };

                let quizState = {
                    question: "Loading...",
                    answers: ["", "", "", ""],
                    correctIndex: -1
                };
                
                const keys = {};

                // --- Quiz Generation Logic ---
                const generateQuiz = () => {
                    if (externalQuizSet.length === 0) {
                        quizState.question = "No quiz questions loaded. Check console for errors.";
                        return;
                    }
                    
                    // If currentQuizIndex is 0 and length is 1, it will load the same question (index 0)
                    // If currentQuizIndex is 0 and length is > 1, it will load the next question (index 1)

                    const quizItem = externalQuizSet[currentQuizIndex];
                    
                    quizState.question = quizItem.question;
                    quizState.answers = quizItem.answers;
                    quizState.correctIndex = quizItem.correctIndex;
                    
                    // Move to the next question (loops back to 0 when end is reached)
                    currentQuizIndex = (currentQuizIndex + 1) % externalQuizSet.length;
                    
                    console.log(`Now loading Question ID ${quizItem.id}. Next Index: ${currentQuizIndex}. Total Questions: ${externalQuizSet.length}`);
                }

                // --- Responsiveness and Recalculation ---
                const resizeCanvas = () => {
                    const maxContainerWidth = dualGameContainer.parentElement.offsetWidth * 0.95; 
                    const newWidth = Math.min(maxContainerWidth, 800); 
                    const newHeight = newWidth * (480 / 800); 

                    canvas.width = newWidth;
                    canvas.height = newHeight;
                    
                    CANVAS_WIDTH = newWidth;
                    CANVAS_HEIGHT = newHeight;
                    VIEW_WIDTH = CANVAS_WIDTH / 2;
                    
                    // Recalculate size and speed based on new height
                    const PLAYER_SIZE = CANVAS_HEIGHT * PLAYER_SIZE_RATIO;
                    PLAYER_SPEED_PIXELS = CANVAS_HEIGHT * 0.008; 
                    
                    const answerBoxHeight = CANVAS_HEIGHT * ANSWER_BOX_SIZE_RATIO;
                    const answerBoxWidth = answerBoxHeight; 

                    ANSWER_SPACING = (CANVAS_HEIGHT - ANSWER_BOX_COUNT * answerBoxHeight) / (ANSWER_BOX_COUNT + 1); 

                    answerBoxes.length = 0;
                    for(let i = 0; i < ANSWER_BOX_COUNT; i++) {
                        answerBoxes.push({ 
                            id: i, 
                            x: VIEW_WIDTH - answerBoxWidth - (CANVAS_WIDTH * 0.025),
                            y: ANSWER_SPACING * (i + 1) + answerBoxHeight * i, 
                            width: answerBoxWidth, 
                            height: answerBoxHeight 
                        });
                    }

                    players.p1.x = VIEW_WIDTH / 2 - PLAYER_SIZE / 2;
                    players.p1.y = CANVAS_HEIGHT / 2 - PLAYER_SIZE / 2;
                    players.p2.x = VIEW_WIDTH / 2 - PLAYER_SIZE / 2;
                    players.p2.y = CANVAS_HEIGHT / 2 - PLAYER_SIZE / 2;
                };

                // --- Input Handlers (Keyboard) ---
                const handleKeyDown = (e) => { keys[e.key] = true; };
                const handleKeyUp = (e) => { keys[e.key] = false; };
                document.addEventListener('keydown', handleKeyDown);
                document.addEventListener('keyup', handleKeyUp);

                // --- Input Handlers (Touch/Swipe) ---
                let touchStart = { x: 0, y: 0 };
                const SWIPE_THRESHOLD = 20;

                const handleTouchStart = (e) => {
                    e.preventDefault(); 
                    const touch = e.touches[0];
                    touchStart.x = touch.clientX;
                    touchStart.y = touch.clientY;
                };

                const handleTouchEnd = (e) => {
                    e.preventDefault();
                    const touchEnd = { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY };
                    const deltaX = touchEnd.x - touchStart.x;
                    const deltaY = touchEnd.y - touchStart.y;
                    
                    const canvasRect = canvas.getBoundingClientRect(); 

                    const touchMidX = (touchStart.x + touchEnd.x) / 2;
                    const isPlayer1Touch = touchMidX < canvasRect.left + canvasRect.width / 2;

                    const player = isPlayer1Touch ? players.p1 : players.p2;
                    const controls = player.controls;

                    if (Math.abs(deltaX) > SWIPE_THRESHOLD || Math.abs(deltaY) > SWIPE_THRESHOLD) {
                        
                        let keyToPress = null;
                        if (Math.abs(deltaX) > Math.abs(deltaY)) {
                            keyToPress = deltaX > 0 ? controls.right : controls.left;
                        } else {
                            keyToPress = deltaY > 0 ? controls.down : controls.up;
                        }

                        keys[keyToPress] = true;
                        setTimeout(() => {
                            keys[keyToPress] = false;
                        }, 100); 
                    }
                };
                
                canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
                canvas.addEventListener('touchend', handleTouchEnd, { passive: false });


                // --- Game Logic Functions ---
                const checkCollision = (player) => {
                    if (quizState.correctIndex === -1) return;

                    const PLAYER_SIZE = CANVAS_HEIGHT * PLAYER_SIZE_RATIO;
                    const playerRight = player.x + PLAYER_SIZE;
                    const playerBottom = player.y + PLAYER_SIZE;

                    for (const box of answerBoxes) {
                        const boxRight = box.x + box.width;
                        const boxBottom = box.y + box.height;

                        if (playerRight > box.x && player.x < boxRight &&
                            playerBottom > box.y && player.y < boxBottom) {
                            
                            const isCorrect = box.id === quizState.correctIndex;
                            
                            // Reset player position regardless of outcome
                            player.x = VIEW_WIDTH / 2 - PLAYER_SIZE / 2;
                            player.y = CANVAS_HEIGHT / 2 - PLAYER_SIZE / 2;

                            if (isCorrect) {
                                player.score++;
                                p1ScoreDisplay.textContent = players.p1.score;
                                p2ScoreDisplay.textContent = players.p2.score;
                                
                                // Show temporary feedback message
                                successMessage = { 
                                    text: "正確! NEXT QUESTION", 
                                    color: player.color,
                                    x: CANVAS_WIDTH / 2, 
                                    y: CANVAS_HEIGHT / 2 
                                };

                                setTimeout(() => {
                                    successMessage = null;
                                    generateQuiz(); // Generate the next quiz AFTER the message timeout
                                }, 500); // 0.5 second pause for visual feedback
                                
                            } 
                            break; 
                        }
                    }
                }

                const handleMovementInput = (player, viewBoundary) => {
                    const controls = player.controls;
                    const PLAYER_SIZE = CANVAS_HEIGHT * PLAYER_SIZE_RATIO;
                    let dx = 0, dy = 0;

                    if (keys[controls.up]) dy -= 1;
                    if (keys[controls.down]) dy += 1;
                    if (keys[controls.left]) dx -= 1;
                    if (keys[controls.right]) dx += 1;

                    if (dx !== 0 || dy !== 0) {
                        const length = Math.sqrt(dx * dx + dy * dy);
                        if (length > 0) {
                            player.x += (dx / length) * PLAYER_SPEED_PIXELS;
                            player.y += (dy / length) * PLAYER_SPEED_PIXELS;
                        }
                    }

                    player.x = Math.max(0, Math.min(viewBoundary.width - PLAYER_SIZE, player.x));
                    player.y = Math.max(0, Math.min(viewBoundary.height - PLAYER_SIZE, player.y));
                }

                const drawAnswerBox = (box, answerText) => {
                    ctx.fillStyle = '#fef3c7'; 
                    ctx.fillRect(box.x, box.y, box.width, box.height);
                    
                    ctx.strokeStyle = '#d97706'; 
                    ctx.lineWidth = 2;
                    ctx.strokeRect(box.x, box.y, box.width, box.height);

                    ctx.fillStyle = '#1f2937'; 
                    ctx.font = `${Math.floor(box.height * 0.25)}px Inter, sans-serif`; 
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    const words = answerText.split(' ');
                    if (words.length > 2) { 
                        // Handle multiline text for long answers
                        const line1 = words.slice(0, Math.ceil(words.length / 2)).join(' ');
                        const line2 = words.slice(Math.ceil(words.length / 2)).join(' ');
                        const lineHeight = Math.floor(box.height * 0.25) + 4;
                        ctx.fillText(line1, box.x + box.width / 2, box.y + box.height / 2 - lineHeight / 2);
                        ctx.fillText(line2, box.x + box.width / 2, box.y + box.height / 2 + lineHeight / 2);
                    } else {
                        ctx.fillText(answerText, box.x + box.width / 2, box.y + box.height / 2);
                    }
                }

                const drawPlayer = (player) => {
                    const PLAYER_SIZE = CANVAS_HEIGHT * PLAYER_SIZE_RATIO;
                    ctx.fillStyle = player.color;
                    ctx.fillRect(player.x, player.y, PLAYER_SIZE, PLAYER_SIZE);
                }

                const drawView = (player, viewArea, isPlayer1) => {
                    ctx.save();
                    ctx.beginPath();
                    ctx.rect(viewArea.x, viewArea.y, viewArea.width, viewArea.height);
                    ctx.clip();

                    if (!isPlayer1) {
                        ctx.translate(viewArea.x, 0); 
                    }

                    // Draw Question (問題)
                    ctx.fillStyle = '#1f2937'; 
                    ctx.font = `${Math.floor(CANVAS_HEIGHT * 0.045)}px Inter, sans-serif`; 
                    ctx.textAlign = 'center';
                    const questionText = quizState.question;
                    const words = questionText.split(' ');
                    const lineHeight = Math.floor(CANVAS_HEIGHT * 0.045) + 5;
                    
                    const qX = VIEW_WIDTH / 2;
                    const qY_base = CANVAS_HEIGHT * 0.083; 

                    if (words.length > 5) { 
                        let line1 = words.slice(0, Math.ceil(words.length / 2)).join(' ');
                        let line2 = words.slice(Math.ceil(words.length / 2)).join(' ');
                        ctx.fillText(line1, qX, qY_base - lineHeight / 2);
                        ctx.fillText(line2, qX, qY_base + lineHeight / 2);
                    } else {
                        ctx.fillText(questionText, qX, qY_base);
                    }


                    // Draw Answer Boxes (答案區)
                    answerBoxes.forEach((box, index) => {
                        const answerText = quizState.answers[index];
                        drawAnswerBox(box, answerText); 
                    });
                    
                    // Draw the Player (玩家)
                    drawPlayer(player);

                    // Draw the local arena boundary (競技場邊界)
                    ctx.strokeStyle = player.color;
                    ctx.lineWidth = 3;
                    ctx.strokeRect(0, 0, VIEW_WIDTH, CANVAS_HEIGHT);
                    
                    ctx.restore();
                }

                // The 'update' function runs game logic
                const update = () => {
                    const pBoundary = { width: VIEW_WIDTH, height: CANVAS_HEIGHT };
                    
                    handleMovementInput(players.p1, pBoundary);
                    checkCollision(players.p1);

                    handleMovementInput(players.p2, pBoundary);
                    checkCollision(players.p2); 
                }

                // The 'draw' function renders the scene
                const draw = () => {
                    ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

                    // Draw the dividing line (分隔線)
                    ctx.strokeStyle = '#1f2937';
                    ctx.lineWidth = 5;
                    ctx.beginPath();
                    ctx.moveTo(VIEW_WIDTH, 0);
                    ctx.lineTo(VIEW_WIDTH, CANVAS_HEIGHT);
                    ctx.stroke();

                    // Draw Player 1's View (左半邊)
                    const view1 = { x: 0, y: 0, width: VIEW_WIDTH, height: CANVAS_HEIGHT };
                    drawView(players.p1, view1, true);

                    // Draw Player 2's View (右半邊)
                    const view2 = { x: VIEW_WIDTH, y: 0, width: VIEW_WIDTH, height: CANVAS_HEIGHT };
                    drawView(players.p2, view2, false);

                    // Draw Success Message (如果存在)
                    if (successMessage) {
                        ctx.save();
                        ctx.fillStyle = successMessage.color;
                        ctx.font = `${Math.floor(CANVAS_HEIGHT * 0.08)}px Inter, sans-serif`;
                        ctx.textAlign = 'center';
                        ctx.fillText(successMessage.text, successMessage.x, successMessage.y);
                        ctx.restore();
                    }
                }

                // --- Game Loop ---
                const gameLoop = () => {
                    update();
                    draw();
                    requestAnimationFrame(gameLoop);
                }

                // --- Start Sequence ---
                parseQuizData();
                resizeCanvas(); 
                generateQuiz(); 
                gameLoop();

                window.addEventListener('resize', resizeCanvas);
            }

            // Add the click handler to the start button
            startGameButton.addEventListener('click', () => {
                // 1. Hide the button
                startGameButton.style.display = 'none';
                
                // 2. Show the game container (and the canvas inside it)
                dualGameContainer.style.display = 'flex';
                
                // 3. Start the logic
                initializeAndStartGame();
            });
        })(); 
        // --- END OF IIFE ---



//=========================切水果遊戲結束======================================================================
//=========================================================== Dual player Game


        // --- START OF IIFE FOR SCOPE ISOLATION ---
        (function() {
            const startGameButton = document.getElementById('startGameButton');
            const dualGameContainer = document.getElementById('dualGameContainer');
            
            const shuffleArray = (array) => {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
            };

            function initializeAndStartGame() {
                if (dualGameContainer.dataset.initialized === 'true') return;
                dualGameContainer.dataset.initialized = 'true';

                const canvas = document.getElementById('dualGameCanvas');
                const ctx = canvas.getContext('2d');
                
                const p1ScoreDisplay = document.getElementById('p1-score');
                const p2ScoreDisplay = document.getElementById('p2-score');

                let CANVAS_WIDTH = 0;
                let CANVAS_HEIGHT = 0;
                let VIEW_WIDTH = 0;
                let ANSWER_SPACING = 0; 
                let answerBoxes = []; 

                const PLAYER_SIZE_RATIO = 0.04; 
                let PLAYER_SPEED_PIXELS = 0; 
                const ANSWER_BOX_COUNT = 4;
                const ANSWER_BOX_SIZE_RATIO = 0.16; 

                let externalQuizSet = [];
                let currentQuizIndex = 0;
                let successMessage = null; // New state for success message

                // --- Data Parsing (ULTRA-ROBUST FIX V2) ---
                const parseQuizData = () => {
                    const quizDataElement = document.getElementById('quizArea').querySelector('#quizData');
                    if (!quizDataElement) {
                        console.error("Quiz data element not found.");
                        return;
                    }
                    
                    try {
                        let dataString = quizDataElement.textContent.trim();
  
            // 1. 從 DOM 獲取原始文字，使用 innerHTML 以捕獲 <br> 和其他標籤
            const rawHtmlText = quizDataElementX.innerHTML.trim();
            
            // 2. 嚴格資料淨化：將編輯器可能插入的 HTML 標籤轉換為標準換行符 (\n)
            let cleanedText = rawHtmlText.replace(/<br\s*\/?>/gi, '\n'); // 替換 <br>
            cleanedText = cleanedText.replace(/<\/?(p|div|span)[^>]*>/gi, '\n'); // 替換 <p>, <div>, <span>
            // 標準化換行符，確保沒有連續換行或多餘的空白
            cleanedText = cleanedText.replace(/\s*\n\s*/g, '\n').trim(); 

            // 3. 按標準 \n 拆分，並過濾掉空行
            const lines = cleanedText.split('\n').filter(function(line) { return line.trim() !== ''; });




                      
                       
                        externalQuizSet = lines.map((item, index) => {
                            // Split each item by the pipe '|' and remove leading/trailing spaces from parts
                            const parts = item.split('|').map(p => p.trim());
                            
                            if (parts.length < 7) {
                                console.warn(`Skipping malformed quiz item at index ${index}. Expected 7 parts (ID|Q|ANS_INDEX|A|B|C|D), got ${parts.length}. Data:`, item);
                                return null;
                            }
                            
                            const correctIndex1Based = parseInt(parts[2]);
                            if (isNaN(correctIndex1Based) || correctIndex1Based < 1 || correctIndex1Based > 4) {
                                console.error(`Invalid correct index for item ID ${parts[0]}: ${parts[2]}. Must be 1, 2, 3, or 4.`);
                                return null;
                            }
                            
                            return {
                                id: parts[0],
                                question: parts[1],
                                correctIndex: correctIndex1Based - 1, // Convert 1-based index to 0-based
                                answers: [parts[3], parts[4], parts[5], parts[6]]
                            };
                        }).filter(q => q !== null);
                        
                        if (externalQuizSet.length > 0) {
                            shuffleArray(externalQuizSet); // Shuffle questions on load
                        }
                        console.log(`Loaded ${externalQuizSet.length} unique quiz questions.`);

                    } catch(e) {
                        console.error("CRITICAL QUIZ PARSING ERROR:", e);
                        console.log("Please ensure your quizData strictly follows the format: ID|QUESTION|CORRECT_INDEX|A|B|C|D");
                        externalQuizSet = [];
                    }
                };
                
                // --- Game State ---
                const players = {
                    p1: { score: 0, x: 0, y: 0, color: '#3b82f6', controls: { up: 'w', down: 's', left: 'a', right: 'd' } },
                    p2: { score: 0, x: 0, y: 0, color: '#ef4444', controls: { up: 'ArrowUp', down: 'ArrowDown', left: 'ArrowLeft', right: 'ArrowRight' } }
                };

                let quizState = {
                    question: "Loading...",
                    answers: ["", "", "", ""],
                    correctIndex: -1
                };
                
                const keys = {};

                // --- Quiz Generation Logic ---
                const generateQuiz = () => {
                    if (externalQuizSet.length === 0) {
                        quizState.question = "No quiz questions loaded. Check console for errors.";
                        return;
                    }
                    
                    // If currentQuizIndex is 0 and length is 1, it will load the same question (index 0)
                    // If currentQuizIndex is 0 and length is > 1, it will load the next question (index 1)

                    const quizItem = externalQuizSet[currentQuizIndex];
                    
                    quizState.question = quizItem.question;
                    quizState.answers = quizItem.answers;
                    quizState.correctIndex = quizItem.correctIndex;
                    
                    // Move to the next question (loops back to 0 when end is reached)
                    currentQuizIndex = (currentQuizIndex + 1) % externalQuizSet.length;
                    
                    console.log(`Now loading Question ID ${quizItem.id}. Next Index: ${currentQuizIndex}. Total Questions: ${externalQuizSet.length}`);
                }

                // --- Responsiveness and Recalculation ---
                const resizeCanvas = () => {
                    const maxContainerWidth = dualGameContainer.parentElement.offsetWidth * 0.95; 
                    const newWidth = Math.min(maxContainerWidth, 800); 
                    const newHeight = newWidth * (480 / 800); 

                    canvas.width = newWidth;
                    canvas.height = newHeight;
                    
                    CANVAS_WIDTH = newWidth;
                    CANVAS_HEIGHT = newHeight;
                    VIEW_WIDTH = CANVAS_WIDTH / 2;
                    
                    // Recalculate size and speed based on new height
                    const PLAYER_SIZE = CANVAS_HEIGHT * PLAYER_SIZE_RATIO;
                    PLAYER_SPEED_PIXELS = CANVAS_HEIGHT * 0.008; 
                    
                    const answerBoxHeight = CANVAS_HEIGHT * ANSWER_BOX_SIZE_RATIO;
                    const answerBoxWidth = answerBoxHeight; 

                    ANSWER_SPACING = (CANVAS_HEIGHT - ANSWER_BOX_COUNT * answerBoxHeight) / (ANSWER_BOX_COUNT + 1); 

                    answerBoxes.length = 0;
                    for(let i = 0; i < ANSWER_BOX_COUNT; i++) {
                        answerBoxes.push({ 
                            id: i, 
                            x: VIEW_WIDTH - answerBoxWidth - (CANVAS_WIDTH * 0.025),
                            y: ANSWER_SPACING * (i + 1) + answerBoxHeight * i, 
                            width: answerBoxWidth, 
                            height: answerBoxHeight 
                        });
                    }

                    players.p1.x = VIEW_WIDTH / 2 - PLAYER_SIZE / 2;
                    players.p1.y = CANVAS_HEIGHT / 2 - PLAYER_SIZE / 2;
                    players.p2.x = VIEW_WIDTH / 2 - PLAYER_SIZE / 2;
                    players.p2.y = CANVAS_HEIGHT / 2 - PLAYER_SIZE / 2;
                };

                // --- Input Handlers (Keyboard) ---
                const handleKeyDown = (e) => { keys[e.key] = true; };
                const handleKeyUp = (e) => { keys[e.key] = false; };
                document.addEventListener('keydown', handleKeyDown);
                document.addEventListener('keyup', handleKeyUp);

                // --- Input Handlers (Touch/Swipe) ---
                let touchStart = { x: 0, y: 0 };
                const SWIPE_THRESHOLD = 20;

                const handleTouchStart = (e) => {
                    e.preventDefault(); 
                    const touch = e.touches[0];
                    touchStart.x = touch.clientX;
                    touchStart.y = touch.clientY;
                };

                const handleTouchEnd = (e) => {
                    e.preventDefault();
                    const touchEnd = { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY };
                    const deltaX = touchEnd.x - touchStart.x;
                    const deltaY = touchEnd.y - touchStart.y;
                    
                    const canvasRect = canvas.getBoundingClientRect(); 

                    const touchMidX = (touchStart.x + touchEnd.x) / 2;
                    const isPlayer1Touch = touchMidX < canvasRect.left + canvasRect.width / 2;

                    const player = isPlayer1Touch ? players.p1 : players.p2;
                    const controls = player.controls;

                    if (Math.abs(deltaX) > SWIPE_THRESHOLD || Math.abs(deltaY) > SWIPE_THRESHOLD) {
                        
                        let keyToPress = null;
                        if (Math.abs(deltaX) > Math.abs(deltaY)) {
                            keyToPress = deltaX > 0 ? controls.right : controls.left;
                        } else {
                            keyToPress = deltaY > 0 ? controls.down : controls.up;
                        }

                        keys[keyToPress] = true;
                        setTimeout(() => {
                            keys[keyToPress] = false;
                        }, 100); 
                    }
                };
                
                canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
                canvas.addEventListener('touchend', handleTouchEnd, { passive: false });


                // --- Game Logic Functions ---
                const checkCollision = (player) => {
                    if (quizState.correctIndex === -1) return;

                    const PLAYER_SIZE = CANVAS_HEIGHT * PLAYER_SIZE_RATIO;
                    const playerRight = player.x + PLAYER_SIZE;
                    const playerBottom = player.y + PLAYER_SIZE;

                    for (const box of answerBoxes) {
                        const boxRight = box.x + box.width;
                        const boxBottom = box.y + box.height;

                        if (playerRight > box.x && player.x < boxRight &&
                            playerBottom > box.y && player.y < boxBottom) {
                            
                            const isCorrect = box.id === quizState.correctIndex;
                            
                            // Reset player position regardless of outcome
                            player.x = VIEW_WIDTH / 2 - PLAYER_SIZE / 2;
                            player.y = CANVAS_HEIGHT / 2 - PLAYER_SIZE / 2;

                            if (isCorrect) {
                                player.score++;
                                p1ScoreDisplay.textContent = players.p1.score;
                                p2ScoreDisplay.textContent = players.p2.score;
                                
                                // Show temporary feedback message
                                successMessage = { 
                                    text: "正確! NEXT QUESTION", 
                                    color: player.color,
                                    x: CANVAS_WIDTH / 2, 
                                    y: CANVAS_HEIGHT / 2 
                                };

                                setTimeout(() => {
                                    successMessage = null;
                                    generateQuiz(); // Generate the next quiz AFTER the message timeout
                                }, 500); // 0.5 second pause for visual feedback
                                
                            } 
                            break; 
                        }
                    }
                }

                const handleMovementInput = (player, viewBoundary) => {
                    const controls = player.controls;
                    const PLAYER_SIZE = CANVAS_HEIGHT * PLAYER_SIZE_RATIO;
                    let dx = 0, dy = 0;

                    if (keys[controls.up]) dy -= 1;
                    if (keys[controls.down]) dy += 1;
                    if (keys[controls.left]) dx -= 1;
                    if (keys[controls.right]) dx += 1;

                    if (dx !== 0 || dy !== 0) {
                        const length = Math.sqrt(dx * dx + dy * dy);
                        if (length > 0) {
                            player.x += (dx / length) * PLAYER_SPEED_PIXELS;
                            player.y += (dy / length) * PLAYER_SPEED_PIXELS;
                        }
                    }

                    player.x = Math.max(0, Math.min(viewBoundary.width - PLAYER_SIZE, player.x));
                    player.y = Math.max(0, Math.min(viewBoundary.height - PLAYER_SIZE, player.y));
                }

                const drawAnswerBox = (box, answerText) => {
                    ctx.fillStyle = '#fef3c7'; 
                    ctx.fillRect(box.x, box.y, box.width, box.height);
                    
                    ctx.strokeStyle = '#d97706'; 
                    ctx.lineWidth = 2;
                    ctx.strokeRect(box.x, box.y, box.width, box.height);

                    ctx.fillStyle = '#1f2937'; 
                    ctx.font = `${Math.floor(box.height * 0.25)}px Inter, sans-serif`; 
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    const words = answerText.split(' ');
                    if (words.length > 2) { 
                        // Handle multiline text for long answers
                        const line1 = words.slice(0, Math.ceil(words.length / 2)).join(' ');
                        const line2 = words.slice(Math.ceil(words.length / 2)).join(' ');
                        const lineHeight = Math.floor(box.height * 0.25) + 4;
                        ctx.fillText(line1, box.x + box.width / 2, box.y + box.height / 2 - lineHeight / 2);
                        ctx.fillText(line2, box.x + box.width / 2, box.y + box.height / 2 + lineHeight / 2);
                    } else {
                        ctx.fillText(answerText, box.x + box.width / 2, box.y + box.height / 2);
                    }
                }

                const drawPlayer = (player) => {
                    const PLAYER_SIZE = CANVAS_HEIGHT * PLAYER_SIZE_RATIO;
                    ctx.fillStyle = player.color;
                    ctx.fillRect(player.x, player.y, PLAYER_SIZE, PLAYER_SIZE);
                }

                const drawView = (player, viewArea, isPlayer1) => {
                    ctx.save();
                    ctx.beginPath();
                    ctx.rect(viewArea.x, viewArea.y, viewArea.width, viewArea.height);
                    ctx.clip();

                    if (!isPlayer1) {
                        ctx.translate(viewArea.x, 0); 
                    }

                    // Draw Question (問題)
                    ctx.fillStyle = '#1f2937'; 
                    ctx.font = `${Math.floor(CANVAS_HEIGHT * 0.045)}px Inter, sans-serif`; 
                    ctx.textAlign = 'center';
                    const questionText = quizState.question;
                    const words = questionText.split(' ');
                    const lineHeight = Math.floor(CANVAS_HEIGHT * 0.045) + 5;
                    
                    const qX = VIEW_WIDTH / 2;
                    const qY_base = CANVAS_HEIGHT * 0.083; 

                    if (words.length > 5) { 
                        let line1 = words.slice(0, Math.ceil(words.length / 2)).join(' ');
                        let line2 = words.slice(Math.ceil(words.length / 2)).join(' ');
                        ctx.fillText(line1, qX, qY_base - lineHeight / 2);
                        ctx.fillText(line2, qX, qY_base + lineHeight / 2);
                    } else {
                        ctx.fillText(questionText, qX, qY_base);
                    }


                    // Draw Answer Boxes (答案區)
                    answerBoxes.forEach((box, index) => {
                        const answerText = quizState.answers[index];
                        drawAnswerBox(box, answerText); 
                    });
                    
                    // Draw the Player (玩家)
                    drawPlayer(player);

                    // Draw the local arena boundary (競技場邊界)
                    ctx.strokeStyle = player.color;
                    ctx.lineWidth = 3;
                    ctx.strokeRect(0, 0, VIEW_WIDTH, CANVAS_HEIGHT);
                    
                    ctx.restore();
                }

                // The 'update' function runs game logic
                const update = () => {
                    const pBoundary = { width: VIEW_WIDTH, height: CANVAS_HEIGHT };
                    
                    handleMovementInput(players.p1, pBoundary);
                    checkCollision(players.p1);

                    handleMovementInput(players.p2, pBoundary);
                    checkCollision(players.p2); 
                }

                // The 'draw' function renders the scene
                const draw = () => {
                    ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

                    // Draw the dividing line (分隔線)
                    ctx.strokeStyle = '#1f2937';
                    ctx.lineWidth = 5;
                    ctx.beginPath();
                    ctx.moveTo(VIEW_WIDTH, 0);
                    ctx.lineTo(VIEW_WIDTH, CANVAS_HEIGHT);
                    ctx.stroke();

                    // Draw Player 1's View (左半邊)
                    const view1 = { x: 0, y: 0, width: VIEW_WIDTH, height: CANVAS_HEIGHT };
                    drawView(players.p1, view1, true);

                    // Draw Player 2's View (右半邊)
                    const view2 = { x: VIEW_WIDTH, y: 0, width: VIEW_WIDTH, height: CANVAS_HEIGHT };
                    drawView(players.p2, view2, false);

                    // Draw Success Message (如果存在)
                    if (successMessage) {
                        ctx.save();
                        ctx.fillStyle = successMessage.color;
                        ctx.font = `${Math.floor(CANVAS_HEIGHT * 0.08)}px Inter, sans-serif`;
                        ctx.textAlign = 'center';
                        ctx.fillText(successMessage.text, successMessage.x, successMessage.y);
                        ctx.restore();
                    }
                }

                // --- Game Loop ---
                const gameLoop = () => {
                    update();
                    draw();
                    requestAnimationFrame(gameLoop);
                }

                // --- Start Sequence ---
                parseQuizData();
                resizeCanvas(); 
                generateQuiz(); 
                gameLoop();

                window.addEventListener('resize', resizeCanvas);
            }

            // Add the click handler to the start button
            startGameButton.addEventListener('click', () => {
                // 1. Hide the button
                startGameButton.style.display = 'none';
                
                // 2. Show the game container (and the canvas inside it)
                dualGameContainer.style.display = 'flex';
                
                // 3. Start the logic
                initializeAndStartGame();
            });
        })(); 
        // --- END OF IIFE ---




//=========================切水果遊戲結束======================================================================
//=========================================================== Dual player Game


        // --- START OF IIFE FOR SCOPE ISOLATION ---
        (function() {
            const startGameButton = document.getElementById('startGameButton');
            const dualGameContainer = document.getElementById('dualGameContainer');
            
            const shuffleArray = (array) => {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
            };

            function initializeAndStartGame() {
                if (dualGameContainer.dataset.initialized === 'true') return;
                dualGameContainer.dataset.initialized = 'true';

                const canvas = document.getElementById('dualGameCanvas');
                const ctx = canvas.getContext('2d');
                
                const p1ScoreDisplay = document.getElementById('p1-score');
                const p2ScoreDisplay = document.getElementById('p2-score');

                let CANVAS_WIDTH = 0;
                let CANVAS_HEIGHT = 0;
                let VIEW_WIDTH = 0;
                let ANSWER_SPACING = 0; 
                let answerBoxes = []; 

                const PLAYER_SIZE_RATIO = 0.04; 
                let PLAYER_SPEED_PIXELS = 0; 
                const ANSWER_BOX_COUNT = 4;
                const ANSWER_BOX_SIZE_RATIO = 0.16; 

                let externalQuizSet = [];
                let currentQuizIndex = 0;
                let successMessage = null; // New state for success message

                // --- Data Parsing (ULTRA-ROBUST FIX V2) ---
                const parseQuizData = () => {
                    const quizDataElement = document.getElementById('quizArea').querySelector('#quizData');
                    if (!quizDataElement) {
                        console.error("Quiz data element not found.");
                        return;
                    }
                    
                    try {
                        let dataString = quizDataElement.textContent.trim();
  
            // 1. 從 DOM 獲取原始文字，使用 innerHTML 以捕獲 <br> 和其他標籤
            const rawHtmlText = quizDataElementX.innerHTML.trim();
            
            // 2. 嚴格資料淨化：將編輯器可能插入的 HTML 標籤轉換為標準換行符 (\n)
            let cleanedText = rawHtmlText.replace(/<br\s*\/?>/gi, '\n'); // 替換 <br>
            cleanedText = cleanedText.replace(/<\/?(p|div|span)[^>]*>/gi, '\n'); // 替換 <p>, <div>, <span>
            // 標準化換行符，確保沒有連續換行或多餘的空白
            cleanedText = cleanedText.replace(/\s*\n\s*/g, '\n').trim(); 

            // 3. 按標準 \n 拆分，並過濾掉空行
            const lines = cleanedText.split('\n').filter(function(line) { return line.trim() !== ''; });




                      
                       
                        externalQuizSet = lines.map((item, index) => {
                            // Split each item by the pipe '|' and remove leading/trailing spaces from parts
                            const parts = item.split('|').map(p => p.trim());
                            
                            if (parts.length < 7) {
                                console.warn(`Skipping malformed quiz item at index ${index}. Expected 7 parts (ID|Q|ANS_INDEX|A|B|C|D), got ${parts.length}. Data:`, item);
                                return null;
                            }
                            
                            const correctIndex1Based = parseInt(parts[2]);
                            if (isNaN(correctIndex1Based) || correctIndex1Based < 1 || correctIndex1Based > 4) {
                                console.error(`Invalid correct index for item ID ${parts[0]}: ${parts[2]}. Must be 1, 2, 3, or 4.`);
                                return null;
                            }
                            
                            return {
                                id: parts[0],
                                question: parts[1],
                                correctIndex: correctIndex1Based - 1, // Convert 1-based index to 0-based
                                answers: [parts[3], parts[4], parts[5], parts[6]]
                            };
                        }).filter(q => q !== null);
                        
                        if (externalQuizSet.length > 0) {
                            shuffleArray(externalQuizSet); // Shuffle questions on load
                        }
                        console.log(`Loaded ${externalQuizSet.length} unique quiz questions.`);

                    } catch(e) {
                        console.error("CRITICAL QUIZ PARSING ERROR:", e);
                        console.log("Please ensure your quizData strictly follows the format: ID|QUESTION|CORRECT_INDEX|A|B|C|D");
                        externalQuizSet = [];
                    }
                };
                
                // --- Game State ---
                const players = {
                    p1: { score: 0, x: 0, y: 0, color: '#3b82f6', controls: { up: 'w', down: 's', left: 'a', right: 'd' } },
                    p2: { score: 0, x: 0, y: 0, color: '#ef4444', controls: { up: 'ArrowUp', down: 'ArrowDown', left: 'ArrowLeft', right: 'ArrowRight' } }
                };

                let quizState = {
                    question: "Loading...",
                    answers: ["", "", "", ""],
                    correctIndex: -1
                };
                
                const keys = {};

                // --- Quiz Generation Logic ---
                const generateQuiz = () => {
                    if (externalQuizSet.length === 0) {
                        quizState.question = "No quiz questions loaded. Check console for errors.";
                        return;
                    }
                    
                    // If currentQuizIndex is 0 and length is 1, it will load the same question (index 0)
                    // If currentQuizIndex is 0 and length is > 1, it will load the next question (index 1)

                    const quizItem = externalQuizSet[currentQuizIndex];
                    
                    quizState.question = quizItem.question;
                    quizState.answers = quizItem.answers;
                    quizState.correctIndex = quizItem.correctIndex;
                    
                    // Move to the next question (loops back to 0 when end is reached)
                    currentQuizIndex = (currentQuizIndex + 1) % externalQuizSet.length;
                    
                    console.log(`Now loading Question ID ${quizItem.id}. Next Index: ${currentQuizIndex}. Total Questions: ${externalQuizSet.length}`);
                }

                // --- Responsiveness and Recalculation ---
                const resizeCanvas = () => {
                    const maxContainerWidth = dualGameContainer.parentElement.offsetWidth * 0.95; 
                    const newWidth = Math.min(maxContainerWidth, 800); 
                    const newHeight = newWidth * (480 / 800); 

                    canvas.width = newWidth;
                    canvas.height = newHeight;
                    
                    CANVAS_WIDTH = newWidth;
                    CANVAS_HEIGHT = newHeight;
                    VIEW_WIDTH = CANVAS_WIDTH / 2;
                    
                    // Recalculate size and speed based on new height
                    const PLAYER_SIZE = CANVAS_HEIGHT * PLAYER_SIZE_RATIO;
                    PLAYER_SPEED_PIXELS = CANVAS_HEIGHT * 0.008; 
                    
                    const answerBoxHeight = CANVAS_HEIGHT * ANSWER_BOX_SIZE_RATIO;
                    const answerBoxWidth = answerBoxHeight; 

                    ANSWER_SPACING = (CANVAS_HEIGHT - ANSWER_BOX_COUNT * answerBoxHeight) / (ANSWER_BOX_COUNT + 1); 

                    answerBoxes.length = 0;
                    for(let i = 0; i < ANSWER_BOX_COUNT; i++) {
                        answerBoxes.push({ 
                            id: i, 
                            x: VIEW_WIDTH - answerBoxWidth - (CANVAS_WIDTH * 0.025),
                            y: ANSWER_SPACING * (i + 1) + answerBoxHeight * i, 
                            width: answerBoxWidth, 
                            height: answerBoxHeight 
                        });
                    }

                    players.p1.x = VIEW_WIDTH / 2 - PLAYER_SIZE / 2;
                    players.p1.y = CANVAS_HEIGHT / 2 - PLAYER_SIZE / 2;
                    players.p2.x = VIEW_WIDTH / 2 - PLAYER_SIZE / 2;
                    players.p2.y = CANVAS_HEIGHT / 2 - PLAYER_SIZE / 2;
                };

                // --- Input Handlers (Keyboard) ---
                const handleKeyDown = (e) => { keys[e.key] = true; };
                const handleKeyUp = (e) => { keys[e.key] = false; };
                document.addEventListener('keydown', handleKeyDown);
                document.addEventListener('keyup', handleKeyUp);

                // --- Input Handlers (Touch/Swipe) ---
                let touchStart = { x: 0, y: 0 };
                const SWIPE_THRESHOLD = 20;

                const handleTouchStart = (e) => {
                    e.preventDefault(); 
                    const touch = e.touches[0];
                    touchStart.x = touch.clientX;
                    touchStart.y = touch.clientY;
                };

                const handleTouchEnd = (e) => {
                    e.preventDefault();
                    const touchEnd = { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY };
                    const deltaX = touchEnd.x - touchStart.x;
                    const deltaY = touchEnd.y - touchStart.y;
                    
                    const canvasRect = canvas.getBoundingClientRect(); 

                    const touchMidX = (touchStart.x + touchEnd.x) / 2;
                    const isPlayer1Touch = touchMidX < canvasRect.left + canvasRect.width / 2;

                    const player = isPlayer1Touch ? players.p1 : players.p2;
                    const controls = player.controls;

                    if (Math.abs(deltaX) > SWIPE_THRESHOLD || Math.abs(deltaY) > SWIPE_THRESHOLD) {
                        
                        let keyToPress = null;
                        if (Math.abs(deltaX) > Math.abs(deltaY)) {
                            keyToPress = deltaX > 0 ? controls.right : controls.left;
                        } else {
                            keyToPress = deltaY > 0 ? controls.down : controls.up;
                        }

                        keys[keyToPress] = true;
                        setTimeout(() => {
                            keys[keyToPress] = false;
                        }, 100); 
                    }
                };
                
                canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
                canvas.addEventListener('touchend', handleTouchEnd, { passive: false });


                // --- Game Logic Functions ---
                const checkCollision = (player) => {
                    if (quizState.correctIndex === -1) return;

                    const PLAYER_SIZE = CANVAS_HEIGHT * PLAYER_SIZE_RATIO;
                    const playerRight = player.x + PLAYER_SIZE;
                    const playerBottom = player.y + PLAYER_SIZE;

                    for (const box of answerBoxes) {
                        const boxRight = box.x + box.width;
                        const boxBottom = box.y + box.height;

                        if (playerRight > box.x && player.x < boxRight &&
                            playerBottom > box.y && player.y < boxBottom) {
                            
                            const isCorrect = box.id === quizState.correctIndex;
                            
                            // Reset player position regardless of outcome
                            player.x = VIEW_WIDTH / 2 - PLAYER_SIZE / 2;
                            player.y = CANVAS_HEIGHT / 2 - PLAYER_SIZE / 2;

                            if (isCorrect) {
                                player.score++;
                                p1ScoreDisplay.textContent = players.p1.score;
                                p2ScoreDisplay.textContent = players.p2.score;
                                
                                // Show temporary feedback message
                                successMessage = { 
                                    text: "正確! NEXT QUESTION", 
                                    color: player.color,
                                    x: CANVAS_WIDTH / 2, 
                                    y: CANVAS_HEIGHT / 2 
                                };

                                setTimeout(() => {
                                    successMessage = null;
                                    generateQuiz(); // Generate the next quiz AFTER the message timeout
                                }, 500); // 0.5 second pause for visual feedback
                                
                            } 
                            break; 
                        }
                    }
                }

                const handleMovementInput = (player, viewBoundary) => {
                    const controls = player.controls;
                    const PLAYER_SIZE = CANVAS_HEIGHT * PLAYER_SIZE_RATIO;
                    let dx = 0, dy = 0;

                    if (keys[controls.up]) dy -= 1;
                    if (keys[controls.down]) dy += 1;
                    if (keys[controls.left]) dx -= 1;
                    if (keys[controls.right]) dx += 1;

                    if (dx !== 0 || dy !== 0) {
                        const length = Math.sqrt(dx * dx + dy * dy);
                        if (length > 0) {
                            player.x += (dx / length) * PLAYER_SPEED_PIXELS;
                            player.y += (dy / length) * PLAYER_SPEED_PIXELS;
                        }
                    }

                    player.x = Math.max(0, Math.min(viewBoundary.width - PLAYER_SIZE, player.x));
                    player.y = Math.max(0, Math.min(viewBoundary.height - PLAYER_SIZE, player.y));
                }

                const drawAnswerBox = (box, answerText) => {
                    ctx.fillStyle = '#fef3c7'; 
                    ctx.fillRect(box.x, box.y, box.width, box.height);
                    
                    ctx.strokeStyle = '#d97706'; 
                    ctx.lineWidth = 2;
                    ctx.strokeRect(box.x, box.y, box.width, box.height);

                    ctx.fillStyle = '#1f2937'; 
                    ctx.font = `${Math.floor(box.height * 0.25)}px Inter, sans-serif`; 
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    const words = answerText.split(' ');
                    if (words.length > 2) { 
                        // Handle multiline text for long answers
                        const line1 = words.slice(0, Math.ceil(words.length / 2)).join(' ');
                        const line2 = words.slice(Math.ceil(words.length / 2)).join(' ');
                        const lineHeight = Math.floor(box.height * 0.25) + 4;
                        ctx.fillText(line1, box.x + box.width / 2, box.y + box.height / 2 - lineHeight / 2);
                        ctx.fillText(line2, box.x + box.width / 2, box.y + box.height / 2 + lineHeight / 2);
                    } else {
                        ctx.fillText(answerText, box.x + box.width / 2, box.y + box.height / 2);
                    }
                }

                const drawPlayer = (player) => {
                    const PLAYER_SIZE = CANVAS_HEIGHT * PLAYER_SIZE_RATIO;
                    ctx.fillStyle = player.color;
                    ctx.fillRect(player.x, player.y, PLAYER_SIZE, PLAYER_SIZE);
                }

                const drawView = (player, viewArea, isPlayer1) => {
                    ctx.save();
                    ctx.beginPath();
                    ctx.rect(viewArea.x, viewArea.y, viewArea.width, viewArea.height);
                    ctx.clip();

                    if (!isPlayer1) {
                        ctx.translate(viewArea.x, 0); 
                    }

                    // Draw Question (問題)
                    ctx.fillStyle = '#1f2937'; 
                    ctx.font = `${Math.floor(CANVAS_HEIGHT * 0.045)}px Inter, sans-serif`; 
                    ctx.textAlign = 'center';
                    const questionText = quizState.question;
                    const words = questionText.split(' ');
                    const lineHeight = Math.floor(CANVAS_HEIGHT * 0.045) + 5;
                    
                    const qX = VIEW_WIDTH / 2;
                    const qY_base = CANVAS_HEIGHT * 0.083; 

                    if (words.length > 5) { 
                        let line1 = words.slice(0, Math.ceil(words.length / 2)).join(' ');
                        let line2 = words.slice(Math.ceil(words.length / 2)).join(' ');
                        ctx.fillText(line1, qX, qY_base - lineHeight / 2);
                        ctx.fillText(line2, qX, qY_base + lineHeight / 2);
                    } else {
                        ctx.fillText(questionText, qX, qY_base);
                    }


                    // Draw Answer Boxes (答案區)
                    answerBoxes.forEach((box, index) => {
                        const answerText = quizState.answers[index];
                        drawAnswerBox(box, answerText); 
                    });
                    
                    // Draw the Player (玩家)
                    drawPlayer(player);

                    // Draw the local arena boundary (競技場邊界)
                    ctx.strokeStyle = player.color;
                    ctx.lineWidth = 3;
                    ctx.strokeRect(0, 0, VIEW_WIDTH, CANVAS_HEIGHT);
                    
                    ctx.restore();
                }

                // The 'update' function runs game logic
                const update = () => {
                    const pBoundary = { width: VIEW_WIDTH, height: CANVAS_HEIGHT };
                    
                    handleMovementInput(players.p1, pBoundary);
                    checkCollision(players.p1);

                    handleMovementInput(players.p2, pBoundary);
                    checkCollision(players.p2); 
                }

                // The 'draw' function renders the scene
                const draw = () => {
                    ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

                    // Draw the dividing line (分隔線)
                    ctx.strokeStyle = '#1f2937';
                    ctx.lineWidth = 5;
                    ctx.beginPath();
                    ctx.moveTo(VIEW_WIDTH, 0);
                    ctx.lineTo(VIEW_WIDTH, CANVAS_HEIGHT);
                    ctx.stroke();

                    // Draw Player 1's View (左半邊)
                    const view1 = { x: 0, y: 0, width: VIEW_WIDTH, height: CANVAS_HEIGHT };
                    drawView(players.p1, view1, true);

                    // Draw Player 2's View (右半邊)
                    const view2 = { x: VIEW_WIDTH, y: 0, width: VIEW_WIDTH, height: CANVAS_HEIGHT };
                    drawView(players.p2, view2, false);

                    // Draw Success Message (如果存在)
                    if (successMessage) {
                        ctx.save();
                        ctx.fillStyle = successMessage.color;
                        ctx.font = `${Math.floor(CANVAS_HEIGHT * 0.08)}px Inter, sans-serif`;
                        ctx.textAlign = 'center';
                        ctx.fillText(successMessage.text, successMessage.x, successMessage.y);
                        ctx.restore();
                    }
                }

                // --- Game Loop ---
                const gameLoop = () => {
                    update();
                    draw();
                    requestAnimationFrame(gameLoop);
                }

                // --- Start Sequence ---
                parseQuizData();
                resizeCanvas(); 
                generateQuiz(); 
                gameLoop();

                window.addEventListener('resize', resizeCanvas);
            }

            // Add the click handler to the start button
            startGameButton.addEventListener('click', () => {
                // 1. Hide the button
                  //startGameButton.style.display = 'none';
                  startGameButton.style.display = '';              
                // 2. Show the game container (and the canvas inside it)
                dualGameContainer.style.display = 'flex';
                
                // 3. Start the logic
                initializeAndStartGame();
            });
        })(); 
        // --- END OF IIFE ---








//============================================================End Dual player Game
//==========================================Random Number




    // 全域變數用於儲存號碼狀態
    let MAX_NUMBER = 30; 
    let availableNumbers = [];
    let pickedNumbers = [];
    let isFlipping = false; // Prevent multiple clicks during animation
 
    // =========================================================================
    // MODAL AND SPEECH FUNCTIONS (Used for non-alert communication)
    // =========================================================================

    window.popMSG = function(content, title = '通知') {

        document.getElementById('modalTitle').textContent = title;
        document.getElementById('modalBody').textContent = content;
        document.getElementById('modalOverlay').classList.remove('hidden');
    }



    // =========================================================================
    // PICKER LOGIC
    // =========================================================================

    window.initializeNumbers = function() {
	let r=parseInt(document.getElementById('maxClassNumber').value);
        	 MAX_NUMBER=r;
            showModal(r,'');
        availableNumbers = [];
        pickedNumbers = [];

        for (let i = 1; i <= MAX_NUMBER; i++) {
            availableNumbers.push(i);

        }
        updateDisplay();
        document.getElementById('pickBtn').disabled = false;
        document.getElementById('pickBtn').textContent = '抽號碼';
        // Ensure card starts on the front side
        document.getElementById('flipper').classList.remove('is-flipped');
        document.getElementById('resultDisplay').textContent = '';
        console.log("號碼池已重置。");
    }

    function updateDisplay() {
        const listElement = document.getElementById('pickedList');
        const countElement = document.getElementById('countDisplay');
        
        listElement.innerHTML = pickedNumbers
            .sort((a, b) => a - b)
            .map(num => `<span class="px-2 py-1 bg-green-100 text-green-800 rounded-full text-xs font-semibold">${num}</span>`)
            .join('');

        countElement.textContent = pickedNumbers.length;
        	MAX_NUMBER=parseInt(document.getElementById('maxClassNumber').value);
        if (pickedNumbers.length === MAX_NUMBER) {
            document.getElementById('pickBtn').disabled = true;
            document.getElementById('pickBtn').textContent = '號碼已抽完';
            // Do not update resultDisplay here to allow '完' to show on the card back
        }
    }

    window.pickNumber = function() {
        if (availableNumbers.length === 0 || isFlipping) {
            if (availableNumbers.length === 0) {
                window.popMSG('所有號碼已抽出。請重置號碼池。', '提示');
                window.speakText('所有號碼已抽出。');
            }
            return;
        }
        
        // 1. Reset card to front side if it was flipped
        const flipper = document.getElementById('flipper');
        
        if (flipper.classList.contains('is-flipped')) {
            // If already flipped, reset to front quickly, then draw
            flipper.classList.remove('is-flipped');
            // Use a short delay before drawing the number
            setTimeout(() => drawAndFlip(), 500); 
        } else {
            drawAndFlip();
        }
    }

    function drawAndFlip() {
        isFlipping = true;
        
        // 1. Get Draw Number
        const randomIndex = Math.floor(Math.random() * availableNumbers.length);
        const drawNumber = availableNumbers[randomIndex];
        availableNumbers.splice(randomIndex, 1);
        pickedNumbers.push(drawNumber);

        // 2. Prepare the back of the card with the new number
        document.getElementById('resultDisplay').textContent = drawNumber;

        // 3. Perform the flip (will show the back side)
        document.getElementById('flipper').classList.add('is-flipped');
        
        const speechText = `抽到 ${drawNumber} 號，請上台`;

        // 4. Wait for animation, then show modal and speak
        setTimeout(() => {
            window.speakText(speechText);
            //window.popMSG(drawNumber + ' 號', '抽中的是');
            updateDisplay();
            isFlipping = false;
        }, 850); // Delay slightly longer than CSS transition time (0.8s)
    }

    window.resetPicker = function() {
        window.initializeNumbers();
        document.getElementById('flipper').classList.remove('is-flipped');
        window.popMSG('號碼池已重置，現在可以重新抽籤了！', '重置成功');
    }

    document.addEventListener('DOMContentLoaded', window.initializeNumbers);

    if ('speechSynthesis' in window) {
        window.speechSynthesis.onvoiceschanged = () => {
            console.log("語音列表已載入。");
        };
    }








//=======================================End Random Number
//===============================  core logic =================================================================
        window.initElement = function(element) {
            let resizer = element.querySelector('.resizer');
            if (!resizer) {
                resizer = document.createElement('div');
                resizer.className = 'resizer';
                element.appendChild(resizer);
            }
            
            if (!element.style.zIndex || parseInt(element.style.zIndex) < 10) {
                element.style.zIndex = '10'; 
            }

            if (element.classList.contains('floating-div') && element.getAttribute('contenteditable') !== 'true') {
                element.setAttribute('contenteditable', 'false');
            }

        }















        window.pageNav = function() {
            // *** PASTE YOUR FULL window.pageNav FUNCTION BODY HERE ***
            const div1 = document.getElementById("pagelist");
            const pagex = div1.getElementsByTagName("a");
            const num = pagex.length;
            const Currentpage=document.getElementById("fname").value;
            const cpn=Currentpage.substr(0,Currentpage.lastIndexOf('.'));
            let x=0;
            let navbar ="";
            for (i=0;i<num;i++){
                if (cpn==pagex[i].innerText){
                    x=i;
                    navbar ="<div id=\"pager\" style=\"display:inline;position:relative;border:1px solid blue;background:white;width:40px;height:25px;padding:10px;cursor:hand\" onclick=\"document.getElementById('pagelist').style.display=(document.getElementById('pagelist').style.display=='none')?'':'none';\" >P"+i+"頁</div>";
                }
            }
            if(x>0){
                navbar ="<button onclick=\"window.location.href='"+pagex[x-1].href+"';\"><font size=6 >⬅️</font></button>"+navbar;
            }
            if(x<pagex.length-1){
                navbar += "<button onclick=\"window.location.href='"+pagex[x+1].href+"';\"><font size=6 >➡️</font></button>";
            }
            document.getElementById("Navi").innerHTML=navbar;
        }

        window.PicNav = function() {
            // *** PASTE YOUR FULL window.PicNav FUNCTION BODY HERE ***
            const items = document.querySelectorAll('.draggable-image');
            const titles = document.querySelectorAll('.floating-div, locked');
            titles.forEach( title  =>{title.classList.toggle('hidden');});

            if(null==document.getElementById('Flashcards')){
                
                let piclist='<img id=\"previewx\" src=\"'+items[0].style.backgroundImage.substring(5,items[0].style.backgroundImage.length-2)+'\" style=\"width:auto;height:400px\" ><div id=\"picTitle\" style=\"display: none\" >'+items[0].id+'</div><BR>';

                items.forEach((item, i) => {
                    piclist +='<img id=\"p_'+i+'\" style=\"display:none\" src=\"'+items[i].style.backgroundImage.substring(5,items[i].style.backgroundImage.length-2)+'\" width=\"400px\" height=\"auto\" >';
                    item.style.display=(item.style.display=='none')?'':'none';
                });
                
                const buttonx='<button onclick=\"window.showPic(\'Previous\')\" style=\"width:100px;font-size:50px\" >⬅️ </button><div id=\"picCount\" style=\"display:inline;border:2px solid black;minWidth:120px;font-size:40px\" >01</div><button  onclick=\"window.showPic(\'Next\')\"  style=\"width:100px;font-size:50px\">➡️</button><button onclick=\"window.showPic(\'random\')\" title=\"隨機\"  > 🎲</button><HR><button onclick=\"window.SlidePic(\'Next\')\" title=\"自動播放\"  > ▶️</button><button onclick=\"window.SlidePic(\'stop\')\" title=\"停止播放\"  > ⏹️</button><button onclick=\"window.SlidePic(\'random\')\" title=\"隨機播放\"  > 🔀</button><button onclick=\"window.exitFlash();\" title=\"離開\"  > ❎</button>';
                const tts=`<BR><button onclick="window.speakText(document.getElementById('picTitle').innerText)" title="唸讀" style="width:200px;font-size:50px;background:yellow;border:4px solid black" > 🔊</button> <HR><button style="width:100px;font-size:20px;background: ;border:2px dotted black;padding:4px"><input id="mute" type="checkbox"     ><BR>靜音</button> <button style="width:100px;font-size:20px;background: ;border:2px dotted black;padding:4px"><input id="picInfomation" type="checkbox"    checked><BR>中文</button>`;
                
                const textDiv = document.createElement('div');
                textDiv.className = 'p-4 bg-white shadow-lg rounded-xl'; 
                textDiv.style.position = 'absolute';
                textDiv.style.left = '50px';
                textDiv.style.top = '20px';
                textDiv.style.width = '95%'; 
                textDiv.style.height = '95%'; 
                textDiv.id='Flashcards';
                textDiv.style.display='';
                textDiv.style.backgroundColor = 'white';
                textDiv.style.border ='solid gray 4px'; 
                textDiv.style.padding = '10px';
                textDiv.style.minWidth = '500px'; 
                textDiv.style.fontSize = '30pt'; 
                
                textDiv.innerHTML ='<div id=\"picZone\" style=\"width:70%;height:90%;border:2px dashed gray;float:left;display: grid ;place-content: center\" ><span id=\"picTitle\" style=\"display:none;align-item:center;font-size:120px\" >====</span>'+piclist+'</div><div style=\"width:30%;height:90%;border:2px dashed gray;padding:10px;float:right\" >'+buttonx+tts+'</div>';               
                document.getElementById('editor').appendChild(textDiv);
            }else{
                document.getElementById('Flashcards').style.display='none'; 
                items.forEach((item, i) => {
                    item.style.display='';
                });
                document.getElementById('Flashcards').remove();
            }
            window.showPic('Previous');
        }

        let flag=true;
        window.showPic = function(way){
            // *** PASTE YOUR FULL window.showPic FUNCTION BODY HERE ***
            const items = document.querySelectorAll('.draggable-image');
            let num=items.length;
            flag=!flag;
        
            if(flag==true && counter< num ){
                document.getElementById('previewx').style.display='';
                if(way=='Next' && counter<(items.length-1)){
                    counter +=1;	
                }
                if(way=='Previous' && counter>0){
                    counter -=1;
                }
                if(way=='random'){
                    counter = Math.floor( Math.random() * num );
                }
                if(items[counter].classList.contains('locked')){counter+=1;flag=true;}
                document.getElementById('previewx').src=items[counter].style.backgroundImage.substring(5,items[counter].style.backgroundImage.length-2);
                document.getElementById('picCount').innerText=counter;
                document.getElementById('picTitle').style.display='none';
                document.getElementById('picTitle').innerText=items[counter].id;
                document.getElementById('previewx').style.display='';
            }
            
            if(flag==false && counter< num ){
                let banner=document.getElementById('picTitle');
                let picInfo='';
                if(items[counter].id && document.getElementById('picInfomation').checked==true){
                    picInfo= items[counter].innerText;	    	   
                }
                if(items[counter].id){
                    banner.innerHTML=items[counter].id+'<br><font style=\"font-size:50px;line-height:20%;\" >'+picInfo.replace(/(?:\r\n|\r|\n)/g, '<br>')+'</font>';
                }else{
                    banner.innerText='請幫圖片輸入ID名稱';
                }
                banner.style.display='';
                document.getElementById('previewx').style.display='none';
            }
            if(items[counter].id && document.getElementById('mute').checked==false){ 
                window.speakText(items[counter].id); 
            }
        }

        window.exitFlash = function(){
            // *** PASTE YOUR FULL window.exitFlash FUNCTION BODY HERE ***
            document.getElementById('Flashcards').style.display='none';
            window.PicNav(); 
        }

        window.SlidePic = function(action){
            // *** PASTE YOUR FULL window.SlidePic FUNCTION BODY HERE ***
            if(action=='stop'){	
                clearInterval(myinterval);
                window.clearInterval(myinterval);
            }else{
                counter=0;
                var myinterval =setInterval(() => {
                    window.showPic(action); 
                }, 3000);
            }
        }

        window.speakText = function(textToSpeak) {
		   let seed=Math.floor(Math.random()*2);
		   let lan=4;
		if (textToSpeak.charCodeAt() > 255) {

		   //showModal('Chinese',seed);

		   lan=seed;
		}else{
		  if(textToSpeak.substring(0,1)=='*'){lan=5}else{lan=4;}
		  //lan=4;
		}
            if ('speechSynthesis' in window) {
                //const textToSpeak = document.getElementById('textInput').value;
                const utterance = new SpeechSynthesisUtterance(textToSpeak);

                // Optional: Customize properties   5:en-US   female    6:UK-GB Female 7 :en-UK-GB-Male   1國女~2國男:zh-TW
                utterance.lang = 'en-US';
                utterance.pitch = 1;
                utterance.rate = 0.8;
                utterance.volume = 1;
		// To select a specific voice:
		  const voices = speechSynthesis.getVoices();
 		 utterance.voice = voices[lan]; // Choose a voice from the available list   4:en-US   female 5:en-GB  male 5:en-GB   1~3:zh-TW
                speechSynthesis.speak(utterance);
            } else {
                alert("Your browser does not support Web Speech API.");
            }
	//Text to speech-----------https://developer.mozilla.org/en-US/docs/Web/API/SpeechSynthesis/getVoices
        }



  window.SimplepickNumber= function(){
      const drawNumber=Math.floor(Math.random()*30);
      speakText('抽到'+drawNumber+'號，請上台');
      showModal(drawNumber,'抽中的是');
 }

   window.dartMode = function() {
            gameMode = !gameMode;
          const ebtn = document.getElementById('dartModeBtn');

            if (gameMode) {
                ebtn.textContent = 'stop🎯';
	window.speakText('get'+window.randomItem());
            }else{
                ebtn.textContent = ' 🎯';	
          }
     }

        window.toggleGameMode = function() {
            // *** PASTE YOUR FULL window.toggleGameMode FUNCTION BODY HERE ***
            gameMode = !gameMode;
            
            const btn = document.getElementById('toggleGameModeBtn');
            
            if (gameMode) {
                btn.textContent = '🛑 🎮';
                btn.className = 'px-4 py-2 bg-red-600 text-white font-semibold rounded-lg hover:bg-red-700 transition duration-150 shadow-md';
                
                window.startGameTimer(GAME_DURATION_SECONDS);
                window.startContinuousAnimation();
                console.log("Game Mode ON");
document.getElementById('tmBar').style.display='';
            } else {
                if (gameTimerInterval !== null) {
                    clearInterval(gameTimerInterval);
                    gameTimerInterval = null;

                }
                
                btn.textContent = '▶️ 🎮';
                btn.className = 'px-4 py-2 bg-green-500 text-white font-semibold rounded-lg hover:bg-green-600 transition duration-150 shadow-md';
                
                window.updateTimerDisplay(GAME_DURATION_SECONDS);
                console.log("Game Mode OFF");
document.getElementById('tmBar').style.display='none';
            }
        }
        
        // --- Game Helper Functions (Existing) ---

        window.updateTimerDisplay = function(totalSeconds) {
             const minutes = Math.floor(totalSeconds / 60);
             const seconds = totalSeconds % 60;
             const timeString = `${minutes}:${seconds.toString().padStart(2, '0')}`;
             document.getElementById('gameTimerDisplay').textContent = timeString;
        }

        window.startGameTimer = function(durationSeconds) {
             let timeLeft = durationSeconds;
             window.updateTimerDisplay(timeLeft);
             score=0;
             quizCount=0;
             if (gameTimerInterval !== null) {
                 clearInterval(gameTimerInterval);
             }

             gameTimerInterval = setInterval(() => {
                 timeLeft--;
                 window.updateTimerDisplay(timeLeft);

                 if (timeLeft <= 0) {
                     clearInterval(gameTimerInterval);
                     gameTimerInterval = null;
                     window.updateTimerDisplay(0);
                     
                     if (gameMode) {
                         window.toggleGameMode();
                         document.getElementById('speechResult').style.display='';
                         document.getElementById('speechResult').innerHTML="<font color=red >Time's up!</font> <BR><BR> sore:"+Math.floor((score/quizCount)*100)+'--------------'+score+'/'+quizCount;
                     }
                 }
             }, 1000); 
        }

        window.animateAllRandomly = function(durationSeconds) {
     const editor = document.getElementById('editor');
    const targets = editor.querySelectorAll('.draggable-image');
   //const targets = editor.querySelectorAll('.draggable-image, .floating-div');

    if (targets.length === 0) {
        return Promise.resolve(); // Nothing to animate, resolve immediately
    }

    const editorWidth = editor.offsetWidth;
    const editorHeight = editor.offsetHeight;
    const durationMs = durationSeconds * 1000;

    let itemsToComplete = targets.length;
    
    // Create a new Promise that will resolve when all items are done moving
    return new Promise(resolve => {
        targets.forEach(item => {
            // --- Generate Random Target Coordinates (same as before) ---
            const maxRandX = Math.max(0, editorWidth - item.offsetWidth);
            const maxRandY = Math.max(0, editorHeight - item.offsetHeight);

            const targetX = Math.floor(Math.random() * maxRandX);
            const targetY = Math.floor(Math.random() * maxRandY);

            // --- Animation Variables ---
            const startX = item.offsetLeft;
            const startY = item.offsetTop;
            let startTime;

            // Define a completion callback
            const onComplete = () => {
                itemsToComplete--;
                if (itemsToComplete === 0) {
                    resolve(); // All items have finished this cycle
                }
            };

            // If item is already at target, resolve its cycle immediately
            if (startX === targetX && startY === targetY) {
                onComplete();
                return;
            }

            // --- The Animation Loop (step function) ---
            function step(timestamp) {
                if (!startTime) {
                    startTime = timestamp;
                }

                const elapsed = timestamp - startTime;
                let progress = elapsed / durationMs;


                if (progress >= 1) {
                    progress = 1;
                    // Ensure the item lands exactly on the target coordinates
                    item.style.left = `${targetX}px`;
                    item.style.top = `${targetY}px`;
                    onComplete(); // Mark this item as complete
                    return;
                }

                // Linear Interpolation
                const currentX = startX + (targetX - startX) * progress;
                const currentY = startY + (targetY - startY) * progress;

                item.style.left = `${currentX}px`;
                item.style.top = `${currentY}px`;

                // Continue the animation loop
                requestAnimationFrame(step);
            }

            requestAnimationFrame(step);
        });
    });

        }
        
        let isAnimationRunning = false; 
        window.startContinuousAnimation = async function() {
    if (isAnimationRunning) return; // Already running
    isAnimationRunning = true;

    // Use a duration between 1.5 and 2.5 seconds for a fluid, continuous motion
    const DURATION = 2; 

    // Loop continues as long as the gameMode flag is true
    while (gameMode) {
        // Wait for ALL items to finish their current random movement
        await animateAllRandomly(DURATION);

        // Optional: Add a brief pause between cycles for effect (e.g., 200ms)
        await new Promise(r => setTimeout(r, 200)); 
    }
    
    isAnimationRunning = false;
    console.log("Continuous animation stopped.");

        }


        // --- Final Utility Functions (Existing) ---

        window.zzzzcheckOverlap = function(item) {
            // *** PASTE YOUR FULL window.checkOverlap FUNCTION BODY HERE ***
            const itemRect = item.getBoundingClientRect();
            const items = document.querySelectorAll('.draggable-image, .floating-div');
            
            items.forEach(otherItem => {
                if (otherItem !== item) {
                    const otherRect = otherItem.getBoundingClientRect();
                    if (!(itemRect.right < otherRect.left || itemRect.left > otherRect.right || 
                          itemRect.bottom < otherRect.top || itemRect.top > otherRect.bottom)) {
                        console.log('Overlap detected!');
                        if(!otherItem.classList.contains('locked') && checkMode==true){
                            window.handleOverlap(otherItem);
                        }
                    }
                }
            });
        }

        window.handleOverlap = function(otherItem) {
            // *** PASTE YOUR FULL window.handleOverlap FUNCTION BODY HERE ***
            let ch=activeItem.id+"-a";
            if(otherItem.id==ch){
                otherItem.classList.add('opacity-50', 'animate-bounce');
                otherItem.classList.toggle('locked');
                if(otherItem.classList.contains('draggable-image')){
                    //otherItem.innerHTML="<span style=\"text-align:center;verticle-align:center;color:red\" >答對了~</div>";
                }
            }
        }

        window.updateBackground = function() {
            // *** PASTE YOUR FULL window.updateBackground FUNCTION BODY HERE ***
            const imageUrl = document.getElementById('Xurl').value;
            if (activeItem) {
                activeItem.style.backgroundImage = `url('${imageUrl}')`;
            }
        }


    window.flip=function(){
        //activeItem.style.transform='perspective: 1000px';
      //activeItem.style.transform='transform-style:preserve-3d';
     if(activeItem.style.transform=='rotateY(180deg)'){
       activeItem.style.transform='rotateY(0deg)';
     }else{
       activeItem.style.transform='rotateY(180deg)';
       popBox(activeItem.style.transform,'');
     }
       popBox(activeItem.style.transform,'');
    }

//========================================================全螢幕相關處理================[involves draw(e)]======================================
let isFullScreen =false;

 window.FullScreen=function(){
   isFullScreen = !isFullScreen;
if(isFullScreen){

	let element = document.getElementById('screen'); // Or any other element
element.requestFullscreen()
  .then(() => {
    console.log('Fullscreen mode entered successfully.');
  })
  .catch((error) => {
    console.error('Error entering fullscreen mode:', error);
  });

  }
  else
  {
	
	document.exitFullscreen()
  .then(() => {
    console.log('Fullscreen mode exited successfully.');
  })
  .catch((error) => {
    console.error('Error exiting fullscreen mode:', error);
  });


    }
}


function panEditor(container, editor, deltaX, deltaY, zoomFactor) {
  // 1. Convert the pan amount (delta) from *screen pixels* to *editor-content pixels*.
  // The actual scroll distance needs to be adjusted by the inverse of the zoom factor.
  const scrollDeltaX = deltaX / zoomFactor;
  const scrollDeltaY = deltaY / zoomFactor;

  // 2. Apply the change to the container's scroll position.
  container.scrollLeft += scrollDeltaX;
  container.scrollTop += scrollDeltaY;

  // Optional: Add listeners for mouse-drag/touch events to calculate deltaX/Y
  // and call this function repeatedly for smooth panning.
}

function getUnscaledEditorCoordinates(editor, container, clientX, clientY, zoomFactor) {
  // 1. Get the bounding rectangle of the editor (gives position in viewport)
  const rect = editor.getBoundingClientRect();

  // 2. Calculate the position relative to the *top-left of the scaled editor*
  //    (This is the mouse position *inside* the scaled editor element)
  const editorX = clientX - rect.left;
  const editorY = clientY - rect.top;

  // 3. Convert the relative position back to *unscaled content coordinates*
  //    by dividing by the zoom factor.
  const unscaledX = editorX / zoomFactor;
  const unscaledY = editorY / zoomFactor;

  // 4. Factor in the container's scroll offset.
  //    The canvas position should be based on the unscaled coordinates,
  //    but the actual drawing should be positioned relative to the container's scroll
  //    *if* the canvas is absolutely positioned within the container.
  
  // NOTE: For overlay canvas, it is usually fixed to the viewport,
  // so you only need the unscaled position to calculate where to draw.

  // The *drawing coordinates* on the canvas will also need to be scaled
  // if the canvas itself is NOT scaled, but the editor IS.

  // The final, most useful value for plotting points on the unscaled editor content:
  return {
    x: unscaledX + container.scrollLeft,
    y: unscaledY + container.scrollTop
  };
}



/**
 * Toggles the pan mode on/off.
 */
window.togglePanMode = function() {
    isPanModeActive = !isPanModeActive;
    const btn = document.getElementById('pan-toggle-btn');
    
    if (isPanModeActive) {
        // Activate pan mode
        btn.textContent = 'Pan Mode: ON';
        btn.classList.replace('bg-blue-600', 'bg-red-600');
        
        // Add listeners only when pan mode is ON
        scrollContainer.addEventListener('mousedown', startPan);
        scrollContainer.addEventListener('mousemove', pan);
        scrollContainer.addEventListener('mouseup', stopPan);
        scrollContainer.addEventListener('mouseleave', stopPan);

        // Add touch support for touchpads/mobiles
        scrollContainer.addEventListener('touchstart', startPan);
        scrollContainer.addEventListener('touchmove', pan);
        scrollContainer.addEventListener('touchend', stopPan);
        
        // Change cursor to indicate drag-ability
        scrollContainer.style.cursor = 'grab';
        
    } else {
        // Deactivate pan mode
        btn.textContent = 'Toggle Pan Mode';
        btn.classList.replace('bg-red-600', 'bg-blue-600');
        
        // Remove listeners when pan mode is OFF
        scrollContainer.removeEventListener('mousedown', startPan);
        scrollContainer.removeEventListener('mousemove', pan);
        scrollContainer.removeEventListener('mouseup', stopPan);
        scrollContainer.removeEventListener('mouseleave', stopPan);

        scrollContainer.removeEventListener('touchstart', startPan);
        scrollContainer.removeEventListener('touchmove', pan);
        scrollContainer.removeEventListener('touchend', stopPan);

        scrollContainer.style.cursor = 'default';
        
        isDragging = false; // Ensure dragging is stopped
    }
};

/**
 * Starts the drag operation on mousedown or touchstart.
 */
function startPan(e) {
    if (!isPanModeActive) return;

    e.preventDefault(); // Prevent text selection/default scrolling
    isDragging = true;
    scrollContainer.style.cursor = 'grabbing';
    
    // Get initial cursor position, adjusting for touch events
    lastX = e.clientX || e.touches[0].clientX;
    lastY = e.clientY || e.touches[0].clientY;
}

/**
 * Handles the dragging and updates the scroll position.
 */
function pan(e) {
    if (!isDragging) return;

    // Get current cursor position, adjusting for touch events
    const currentX = e.clientX || e.touches[0].clientX;
    const currentY = e.clientY || e.touches[0].clientY;

    // Calculate the difference (delta) from the last position
    const deltaX = currentX - lastX;
    const deltaY = currentY - lastY;
    
    // Get the current zoom factor (e.g., 0.9, 1.0, 1.5)
    // We assume setZoom() is active and the body has a transform
    const transform = scrollContainer.style.transform;
    const match = transform.match(/scale\(([^)]+)\)/);
    const zoomFactor = match ? parseFloat(match[1]) : 1.0;

    // The scroll distance must be adjusted by the inverse of the zoom factor.
    // If zoomed in (zoomFactor > 1), moving the mouse 10px on screen 
    // corresponds to a smaller distance in the actual content size.
    const scrollDeltaX = deltaX / zoomFactor;
    const scrollDeltaY = deltaY / zoomFactor;

    // Apply the change to the scroll position
    scrollContainer.scrollLeft -= scrollDeltaX;
    scrollContainer.scrollTop -= scrollDeltaY;

    // Update last position for the next move event
    lastX = currentX;
    lastY = currentY;
}

/**
 * Stops the drag operation on mouseup, mouseleave, or touchend.
 */
function stopPan() {
    if (!isPanModeActive) return;
    
    isDragging = false;
    scrollContainer.style.cursor = 'grab'; // Restore grab cursor
}

// Add the original setZoom function here for context, 
// ensuring the body has `transform-origin: top left;` set.

/*
// Example of your setZoom function (ensure it's in the final script)
window.setZoom = function(zoomV = null) {
    // ... (rest of the setZoom logic from the previous answer)
    const bodyStyle = document.getElementById('editor-wrapper');
    bodyStyle.transform = `scale(${scaleFactor})`;
    bodyStyle.transformOrigin = 'top left'; 
    // ...
};
*/






       //############################## DRAWIMG  #########################################
        // --- Drawing Logic (Enhanced with Eraser) ---
         isDrawing = false;
        let lastX = 0;
        let lastY = 0;
         //let context = null;--- stated in global 
         let drawingCanvas = null;
        let penColor = '#FF0000'; // Default pen color (Red)
        let penSize = 5;      // Default pen size
        let drawingMode = 'none'; // 'pen' or 'erase'

  window.initDrawingCanvas=function(ele) {


         drawingCanvas = document.getElementById('drawingCanvas');


        // 2. Make the check simple: if it's null, something is fundamentally wrong
        if (!drawingCanvas) {
             showModal('Canvas element not found in DOM after creation.', 'Error');
            return;
        }

             context = drawingCanvas.getContext('2d'); 
         
             updateCanvasSize();

   if (drawingMode=='none') {
        // If a tool is active (currentTool is not null), the canvas receives events ('auto').
        // If selection mode is active (currentTool is null), clicks pass through ('none').
        drawingCanvas.style.pointerEvents = 'none';
    }

            // Event listeners for drawing (Mouse and Touch)

            drawingCanvas.addEventListener('mousedown', startDrawing);
            drawingCanvas.addEventListener('mousemove', draw);
            drawingCanvas.addEventListener('mouseup', stopDrawing);
            drawingCanvas.addEventListener('mouseout', stopDrawing);

            drawingCanvas.addEventListener('touchstart', (e) => {
                e.preventDefault(); 
                startDrawing(e.touches[0]);
            });
            drawingCanvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                draw(e.touches[0]);
            });
            drawingCanvas.addEventListener('touchend', stopDrawing);

            // Listeners for drawing controls
            document.getElementById('pen-color').addEventListener('change', (e) => {
                penColor = e.target.value;
                setDrawingMode('pen');
            });
            
            const penSizeInput = document.getElementById('pen-size');
            const sizeDisplay = document.getElementById('size-display');
            penSizeInput.addEventListener('input', (e) => {
                penSize = parseInt(e.target.value, 10);
                sizeDisplay.textContent = penSize;
            });
            
            document.getElementById('pen-tool').addEventListener('click', () => setDrawingMode('pen'));
            document.getElementById('eraser-tool').addEventListener('click', () => setDrawingMode('erase'));
            document.getElementById('clear-canvas-button').addEventListener('click', clearCanvas);

            window.addEventListener('resize', updateCanvasSize);
            
            // Set initial active tool state
            window.updateToolButtons();
        }

         window.setDrawingMode=function(mode) {
            drawingMode = mode;
                        //drawingCanvas.style.pointerEvents = drawingMode ? 'auto' : 'none';
            window.updateToolButtons();
            // Ensure the context is set correctly for the new mode before drawing
            if (context) {
                 if (drawingMode === 'erase') {
                    context.globalCompositeOperation = 'destination-out';
                     drawingCanvas.style.pointerEvents = 'auto';

                 } else if (drawingMode === 'none') {

                     drawingCanvas.style.pointerEvents = 'none';


                } else {
                    context.globalCompositeOperation = 'source-over';
                    drawingCanvas.style.pointerEvents = 'auto';

                }
            }
        }
        
       window.updateToolButtons=function() {
            const penBtn = document.getElementById('pen-tool');
            const eraseBtn = document.getElementById('eraser-tool');
            
            penBtn.classList.toggle('active-tool', drawingMode === 'pen');
            eraseBtn.classList.toggle('active-tool', drawingMode === 'erase');
            		
            // Highlight the color picker if in pen mode
            document.getElementById('pen-color').parentElement.classList.toggle('ring-2', drawingMode === 'pen');
            document.getElementById('pen-color').parentElement.classList.toggle('ring-gray-300', drawingMode === 'pen');
        }

        function clearCanvas() {
            if (!context) return;
            // Temporarily set composite operation to clear everything
            context.globalCompositeOperation = 'destination-out';
            context.fillRect(0, 0, drawingCanvas.width, drawingCanvas.height);
            
            // Restore drawing mode setting
            window.setDrawingMode(drawingMode);
            
            // Autosave the clear action (saves an empty drawing data string)
            //saveCurrentPage();
            //showMessageBox("Canvas cleared!", 'bg-blue-100 border-blue-400 text-blue-700');
        }
        
        function updateCanvasSize() {
             if (!drawingCanvas) return;
            const container = document.getElementById('editor');
            const rect = container.getBoundingClientRect();
 
            if (drawingCanvas) {
                // Set CSS dimensions for layout
                drawingCanvas.style.width = `${rect.width}px`;
                drawingCanvas.style.height = `${rect.height}px`;
                // Set canvas element dimensions for drawing resolution
                const wasDrawing = isDrawing;
                isDrawing = false; // Prevent drawing during resize/reload
                
                // IMPORTANT: Before setting new dimensions, save the current drawing data
                const imgData = drawingCanvas.toDataURL('image/png');
                
                drawingCanvas.width = rect.width;
                drawingCanvas.height = rect.height;
 
                // Redraw saved image data onto the newly sized canvas
                if (imgData) {
                    const img = new Image();
                    img.onload = () => {
                        context.drawImage(img, 0, 0, drawingCanvas.width, drawingCanvas.height);
                        // Ensure drawing mode is restored
                        window.setDrawingMode(drawingMode);
                        isDrawing = wasDrawing;
                    };
                    img.src = imgData;
                 
                }
                
                // If there's content loaded, ensure the Firestore listener handles the reload
                // if (currentPageId) {
                   //loadPageData(currentPageId); //loadPageContent(currentPageName); 
                // }
            }
        }
        
        function startDrawing(e) {
            isDrawing = true;
            const rect = drawingCanvas.getBoundingClientRect();
       //showModal(drawingMode,'drawingMode');
            [lastX, lastY] = [e.clientX - rect.left, e.clientY - rect.top];
            
            if (drawingMode === 'erase') {
                context.globalCompositeOperation = 'destination-out';
                context.strokeStyle = 'rgba(0,0,0,1)'; // Color doesn't matter for eraser
            } else {
                context.globalCompositeOperation = 'source-over';
                context.strokeStyle = penColor;
            }
            
            context.lineWidth = penSize;
            context.lineCap = 'round';
            
            context.beginPath();
            context.moveTo(lastX, lastY);
            // Draw a tiny dot for single clicks/taps
            context.lineTo(lastX + 0.1, lastY + 0.1); 
            context.stroke();
            
            [lastX, lastY] = [lastX + 0.1, lastY + 0.1]; 
        }

      function draw(e) {
            if (!isDrawing) return;
   
            const rect = drawingCanvas.getBoundingClientRect();
            let x = e.clientX - rect.left;
            let y = e.clientY - rect.top;

            context.beginPath();
            context.moveTo(lastX, lastY);
            context.lineTo(x, y);
            context.stroke();
            
         [lastX, lastY] = [x, y];


const editor = document.getElementById('editor');
//const editor = document.getElementById('editor-wrapper');
    const container = editor.parentElement; // Assuming the editor is in a scrollable container

const transformMatch = editor.style.transform.match(/scale\(([^)]+)\)/);
    
    let zoomFactor = 1.0; // Default to 1.0 (no zoom)
    //const zoomFactor = parseFloat(editor.style.transform.match(/scale\(([^)]+)\)/)[1] || 1.0);

// 2. Safely extract the value if a match was found
    if (transformMatch && transformMatch[1]) {
        zoomFactor = parseFloat(transformMatch[1]);
    }


    const editorRect = editor.getBoundingClientRect();

    // 1. Get the unscaled position inside the editor content
    const unscaledX = (e.clientX - editorRect.left) / zoomFactor;
    const unscaledY = (e.clientY - editorRect.top) / zoomFactor;
    
    // 2. Adjust for scroll (this is the coordinate relative to the unscaled editor's top-left corner)
    const contentX = unscaledX + container.scrollLeft;
    const contentY = unscaledY + container.scrollTop;

    // 3. Convert content coordinates back to canvas/viewport coordinates for drawing
    const canvasDrawX = (contentX - container.scrollLeft) * zoomFactor + editorRect.left;
    const canvasDrawY = (contentY - container.scrollTop) * zoomFactor + editorRect.top;


   

// TEMPORARY TEST: Subtract the 80px offset
 
  let OFFSET = 0; 
    unscaledX = (e.clientX - editorRect.left - OFFSET) / zoomFactor; 
   unscaledY = (e.clientY - editorRect.top - OFFSET) / zoomFactor;
        }



function TEMPdraw(e) {
    if (!isDrawing) return;

    const editor = document.getElementById('editor');
    const drawingCanvas = document.getElementById('drawingCanvas');
    const context = drawingCanvas.getContext('2d');
    
    // --- Determine Scroll Container ---
    // If your editor is the only content and the entire page scrolls, 
    // the scroll parent is typically the document body/documentElement.
    // If the editor is inside a specific scrollable <div>, use its parent.
    const container = editor.parentElement; 
    
    // Get scroll values from the container
    const scrollLeft = container.scrollLeft || 0;
    const scrollTop = container.scrollTop || 0;
    
    // --- Get Zoom Factor ---
    const transformMatch = editor.style.transform.match(/scale\(([^)]+)\)/);
    // Default to 1.0 if not found, to prevent division by zero/NaN errors
    const zoomFactor = transformMatch ? parseFloat(transformMatch[1]) : 1.0; 
    
    // --- Get Editor Position ---
    const editorRect = editor.getBoundingClientRect(); 

    // 1. Calculate the distance from the mouse to the editor's top-left corner (in scaled screen pixels)
    const mouseToEditorX = e.clientX - editorRect.left;
    const mouseToEditorY = e.clientY - editorRect.top;

    // 2. Convert to unscaled content coordinates
    // This gives the exact coordinate inside the *unscaled* content div.
    const contentX = (mouseToEditorX / zoomFactor) + scrollLeft;
    const contentY = (mouseToEditorY / zoomFactor) + scrollTop;

    // 3. Convert back to Canvas/Viewport coordinates for drawing
    // This coordinate is where the point should be drawn on the unscaled canvas overlay.
    const canvasDrawX = (contentX - scrollLeft) * zoomFactor + editorRect.left;
    const canvasDrawY = (contentY - scrollTop) * zoomFactor + editorRect.top;

    // --- EXECUTE DRAWING ---
    
    // Use the calculated, correct coordinates
    let x = canvasDrawX;
    let y = canvasDrawY;
    
    context.beginPath();
    context.moveTo(lastX, lastY);
    context.lineTo(x, y);
    context.stroke();
    
    // Update lastX and lastY for the next segment
    [lastX, lastY] = [x, y];
}








        function stopDrawing() {
	
            isDrawing = false;

        }
        window.setPenColor=function(clr){
                penColor = clr;
                window.setDrawingMode('pen');
       }
        // Attach init functions to the window load event
        window.onload = function() {
            window.initDrawingCanvas();
            
        };
        
 

// (Include all other editor functions like handleStart, handleMove, initElement, etc., here)

// ====================================================================
// IV. APPLICATION ENTRY POINT (DOCUMENT READY)
// ====================================================================

document.addEventListener('DOMContentLoaded', () => {
      // 1. Load project data and render page list
            //loadProject();
            renderPageList();
            if(currentPageId) {
                loadPageData(currentPageId);
            }
       // 2. Initialize canvas
            //window.resizeCanvas();
            //ctx.strokeStyle = document.getElementById('penColor').value;
            //ctx.lineWidth = document.getElementById('lineWidth').value;
            //drawingCanvas.style.pointerEvents = 'none';
            // 初始狀態為 Select/Move 模式
            //setDrawingTool(null);
       // 3. Attach ALL event listeners
            // Element drag, drop, and resize listeners
            editor.addEventListener('mousedown', handleStart); editor.addEventListener('mousemove', handleMove);
            editor.addEventListener('mouseup', handleEnd); editor.addEventListener('mouseleave', handleEnd);
            editor.addEventListener('touchstart', handleStart, {passive: false}); editor.addEventListener('touchmove', handleMove, {passive: false});
            editor.addEventListener('touchend', handleEnd); editor.addEventListener('touchcancel', handleEnd);


            // NEW: 滑動手勢的觸發點
            editor.addEventListener('mousedown', handleGestureStart);
            editor.addEventListener('mousemove', handleGestureMove);
            editor.addEventListener('mouseup', handleGestureEnd);
            editor.addEventListener('mouseleave', handleGestureEnd);

            // NEW: 滑動手勢的觸控事件
            editor.addEventListener('touchstart', handleGestureStart, {passive: false});
            editor.addEventListener('touchmove', handleGestureMove, {passive: false});
            editor.addEventListener('touchend', handleGestureEnd);
            editor.addEventListener('touchcancel', handleGestureEnd);

            // Drawing listeners


            // Listeners for drawing controls
            document.getElementById('pen-color').addEventListener('change', (e) => {
                penColor = e.target.value;
                setDrawingMode('pen');
            });

            //drawingCanvas.addEventListener('mousedown', startDraw); drawingCanvas.addEventListener('mousemove', draw);
            //drawingCanvas.addEventListener('mouseup', stopDraw); drawingCanvas.addEventListener('mouseleave', stopDraw);
            //drawingCanvas.addEventListener('touchstart', startDraw, {passive: false}); drawingCanvas.addEventListener('touchmove', draw, {passive: false});
            //drawingCanvas.addEventListener('touchend', stopDraw);

            // Toolbar listeners
           // penColorInput.addEventListener('change', (e) => ctx.strokeStyle = e.target.value);
           // lineWidthInput.addEventListener('input', (e) => ctx.lineWidth = e.target.value);
            
            //toggleDrawingBtn.addEventListener('click', toggleDrawing);
            //document.getElementById('penColor').addEventListener('change', (e) => ctx.strokeStyle = e.target.value);
            //document.getElementById('lineWidth').addEventListener('input', (e) => ctx.lineWidth = e.target.value);

            //window.addEventListener('resize', resizeCanvas);

            // Auto-save project every 5 seconds
            setInterval(saveCurrentPageData, 5000);
            window.addEventListener('beforeunload', () => {
                saveCurrentPageData();
                saveProject();
            });

    
    // 5. Finalize tool state
    //window.setDrawingTool(null); // Initialize in selection mode
});



        // --- 6. INITIALIZATION ---
        
        document.addEventListener('DOMContentLoaded', () => {
           window.loadProjectFromLocalStorage();
            
            window.updateTimerDisplay(GAME_DURATION_SECONDS);
        });




    </script>
</body>
</html>
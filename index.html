
<html lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>💡MyEbook</title>
       <script src="https://cdn.tailwindcss.com"></script> 
    <script src="./Canvas_files/saved_resource"></script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap');
        /* General Setup */
        body {  
              font-family:  'cwTeXYen','Inter', sans-serif;
            background-color: #f7f7f7;
margin: 0;
    padding: 0;
  
         }
        /* Editor Area */
        #editor-wrapper { display: flex; flex-grow: 1; margin: 0;
    padding: 0;
    border: none;
    /* Also ensure it is positioned relative for context */
    position: relative;}
        #editor { height: 100%; width: 100%; border: 0px solid #e5e7eb; background-color: #ffffff; position: relative; overflow: hidden; touch-action: none; cursor: default;transform-origin: top left; }
        
        /* Drawing Canvas */
        #drawingCanvas { position: absolute; top: 0; left: 0; z-index: 15; pointer-events: none; }
        #myCanvas { position: absolute; top: 0; left: 0; z-index: 50; pointer-events: none; }        
        /* Draggable Elements (CSS from your original code) */
 
        .draggable-image, .floating-div {
            cursor: move;
           position: absolute;
            padding: 5px;
            box-sizing: border-box;
            z-index: 10; /* Draggable elements base layer */
            /*min-width: 10px;
            min-height: 10px;*?
            /*box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);*/
            transition: border-radius 0.1s;
             transition: all 0.3s ease-out;
        }

        /* Selected State */
        .draggable-image.selected, .floating-div.selected {
            outline: 2px dashed #3b82f6;
             /*transition: all 0.7s ease-out;*/
        }
        
        .floating-div.editing { outline: 2px solid #10b981; cursor: text; }
        .draggable-image.locked, .floating-div.locked { cursor: not-allowed; }
        .resizer { position: absolute; width: 12px; height: 12px; border-radius: 50%; bottom: -6px; right: -6px; cursor: nwse-resize; z-index: 10; }
        .resizer:hover { background: #3b82f6; border: 2px solid #ffffff; }

        /* Main Layout */
        #main-container { display: flex; height: calc(90vh - 50px); } 

        /* Page Management Sidebar */
        #page-manager { width: 350px; background-color: #ffffff; padding: 16px; border-right: 1px solid #e5e7eb; box-shadow: 2px 0 5px rgba(0,0,0,0.05); display: flex; flex-direction: column; }
        #page-list { list-style: none; padding: 0; margin: 0; overflow-y: auto; flex-grow: 1; }
        #page-list li { padding: 10px; cursor: pointer; border-radius: 6px; margin-bottom: 5px; border: 1px solid transparent; display: flex; justify-content: space-between; align-items: center; }
        #page-list li.active { background-color: #dbeafe; color: #1e40af; font-weight: bold; border-color: #93c5fd; }
        
        /* Typography */
        h1 { color: coral; text-shadow: -2px 0 black, 0 2px black, 2px 0 black, 0 -2px black; }
        h2 { color: #333; text-shadow: 0 0 3px cyan, 0 0 5px cyan; }
        h3 { color: coral; text-shadow: 2px 2px 4px #000000; }
        .fly-in-animated { transition: all 1.8s ease-out; }
   

        .picker-container {
            background-color: white;
            padding: 2rem;
            border-radius: 1rem;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            max-width: 400px;
            width: 90%;
            text-align: center;
	justify-content: center;align-items: center;
            position:absolute;
           top:0px;           left:calc(50vw - 200px);   
           z-index:50;
        }
        .result-display {
            font-size: 4rem;
            font-weight: 800;
            color: #1f2937;
            margin-top: 1rem;
            min-height: 4rem;
	justify-content: center;align-items: center;
        }
        /* Toolbar */
         #main-toolbar { padding:5px; background-color: mintcream; display: flex;border-bottom: 1px solid #ccc;  gap: 10px; align-items: center; } 
        #currentProjectDisplay { font-weight: bold; padding: 0 10px; background: #fff; border-radius: 4px; }


/* QUIZ  AREA   */ 
        #app-container {
            position: relative;
            width: 95vw;
            max-width: 900px;
            height: 90vh;
            max-height: 800px;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
            flex-direction: column;
            display: none; 
        }

        #gameCanvas {
pointer-events: auto;
            cursor: crosshair;
            touch-action: none;
        }

        /* 樣式針對 DIV ID quizData */
        #quizData {
            max-height: 200px;
            min-height: 100px;
            border: 1px solid #f97316; 
            white-space: pre-wrap;
            overflow-y: scroll;
        }
        
        #quizData::-webkit-scrollbar {
            width: 8px;
        }
        #quizData::-webkit-scrollbar-thumb {
            background-color: #f97316;
            border-radius: 4px;
        }
        #quizData::-webkit-scrollbar-track {
            background: #4b5563;
        }

        /* 診斷訊息的預格式化文字 */
        #diagnostic-display pre {
            word-wrap: break-word;
            white-space: pre-wrap;
        }
        /* Custom CSS for a clean, centered game look */
        #gameCanvas {

            border: 4px solid #1f2937;
            border-radius: 12px;
            box-shadow: 0 10px 20px -5px rgba(0, 0, 0, 0.2);
            background-color: #f9fafb;
            touch-action: none; /* Prevents default browser actions like scrolling/zooming */
        }
        /*  canno game look */
        .game-container { background-color: #374151; padding: 1.5rem; border-radius: 1rem; box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.5); width: 850px; }
        #game-canvas { background-color: #87CEEB; border: 2px solid #1f2937; border-radius: 0.5rem; }
        .player-control-panel { background-color: #4b5563; padding: 1rem; border-radius: 0.75rem; box-shadow: inset 0 2px 4px 0 rgba(0, 0, 0, 0.2); }
        input[type=range] { width: 100%; height: 8px; border-radius: 4px; background: #6b7280; -webkit-appearance: none; appearance: none; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 20px; height: 20px; border-radius: 50%; background: #6366f1; cursor: pointer; transition: background 0.2s; }
        .player-1-text { color: #f87171; }
        .player-2-text { color: #34d399; }
        .fire-btn-base {
            @apply w-full mt-3 font-bold py-2 rounded-lg shadow-md transition duration-150 transform hover:scale-[1.01] active:scale-[0.99] disabled:opacity-50;
        }
        /* Style for the Start Button */
        #start-button {
            transition: all 0.3s ease-in-out;
            box-shadow: 0 5px 0 0 #1e40af;
        }
        #start-button:hover {
            box-shadow: 0 3px 0 0 #1e40af;
            transform: translateY(2px);
        }
        /* --- 3D FLIP CSS --- */
        .flip-container {
            perspective: 1000px; /* Gives the scene depth */
            height: 120px; /* Fixed height for flip container */
            width: 100%;
            margin-bottom: 2rem;
        }
        .flipper {
            position: relative;
            transform-style: preserve-3d;
            transition: transform 0.8s; /* Smooth flip animation */
            width: 100%;
            height: 100%;
        }
        .flipper.is-flipped {
            transform: rotateY(180deg);
        }
        .front, .back {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            backface-visibility: hidden; /* CRITICAL: Hides the element when rotated away */
            border-radius: 0.5rem;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .front {
            background-color: #e5e7eb; /* Light gray background for the "?" */
            z-index: 2;
            transform: rotateY(0deg);
        }
        .back {
            background-color: #d1fae5; /* Light green background for the result */
            transform: rotateY(180deg); /* Start rotated, ready to flip into view */
        }

        /* Styling for the content inside the card faces */
        .card-content {
            font-size: 4rem;
            font-weight: 800;
            color: #1f2937;
        }
        /* --- END 3D FLIP CSS --- */
        .dice {
            /* CRITICAL FIX for touchstart reliability */
            touch-action: none; 
            
            width: 120px;
            height: 120px;
            
            /* Visual styling for the dice */
            background-color: #f7f7f7;
            border: 8px solid #3b82f6; /* Blue border */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.2), 0 4px 6px -2px rgba(0, 0, 0, 0.1);
            
            /* Grid layout for the dots */
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            padding: 12px;
            cursor: pointer;
            user-select: none;
            transition: transform 0.1s;
        }

        .dot {
            width: 12px;
            height: 12px;
            background-color: #1f2937; /* Dark gray dot */
            border-radius: 50%;
            place-self: center; /* Center dot in its grid cell */
            transition: opacity 0.15s;
        }

        /* Active state for visual feedback */
        .dice:active {
            transform: scale(0.95);
        }

        /* Grid positioning classes for the 9 dots (D1 to D9) */
        .d1 { grid-area: 1 / 1; } /* Top Left */
        .d2 { grid-area: 1 / 2; } /* Top Center */
        .d3 { grid-area: 1 / 3; } /* Top Right */
        .d4 { grid-area: 2 / 1; } /* Middle Left */
        .d5 { grid-area: 2 / 2; } /* Absolute Center */
        .d6 { grid-area: 2 / 3; } /* Middle Right */
        .d7 { grid-area: 3 / 1; } /* Bottom Left */
        .d8 { grid-area: 3 / 2; } /* Bottom Center */
        .d9 { grid-area: 3 / 3; } /* Bottom Right */

/* Style the dropdown */
 
details {
  list-style: none; 
  display: inline-block;
  height:40px;
  position: relative;
  border-radius:8px;
  /*list-style: none;----hide triagle*/

}
 

details > summary {
  padding: 0.5rem;
  /*background: silver;*/
  cursor: pointer;
}

details > ul {
  display: none;
  position: absolute;
  top: 100%;
  left: 0;
  background: white;
  border: 2px solid silver;
  padding: 0.5rem;
  box-shadow:2px 2px gray;
  min-width:200px;
  z-index:60;
}

details[open] > ul {
  display: block;

}


    /* 背景設定：紫色到藍色漸層 */
    #gamebody {
      font-family: 'Nunito', sans-serif;
      background: linear-gradient(to bottom right, #800080, #0000FF);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      padding-top: 20px;
width:100%;
align-items: center;
    }
    #confetti-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 100;
      pointer-events: none;
    }

    .game-container {
      width:80%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      padding: 20px;
      flex: 1;
      position: relative;
    }

    /* 控制區 */
    .question-controls {
      width: 80%;
      max-width: 800px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 20px;
    }
    .controls-left {
      display: flex;
      gap: 10px;
    }
    /* 速度切換按鈕 */
    .speed-toggle-button {
      background: linear-gradient(to bottom, #FF9F43, #FF5E7D);
      color: white;
      border: none;
      border-radius: 50px;
      padding: 10px 20px;
      font-size: 1rem;
      cursor: pointer;
      box-shadow: 0 5px 0 #E65100, 0 10px 20px rgba(0,0,0,0.2);
      transition: all 0.3s;
      font-weight: bold;
    }
    .speed-toggle-button:hover {
      transform: translateY(-3px);
      box-shadow: 0 8px 0 #E65100, 0 15px 25px rgba(0,0,0,0.25);
    }
    .speed-toggle-button:active {
      transform: translateY(3px);
      box-shadow: 0 2px 0 #E65100, 0 5px 10px rgba(0,0,0,0.2);
    }

    /* 隱藏下一題按鈕 */
    .next-button {
      display: none;
    }

    .question-number {
      background-color: white;
      padding: 10px 20px;
      border-radius: 50px;
      font-size: 1.3rem;
      font-weight: bold;
      color: #333;
      box-shadow: 0 5px 15px rgba(0,0,0,0.1);
    }

    /* 提示訊息 */
    .result-container {
      display: none;
      position: absolute;
      padding: 10px 20px;
      font-size: 1.5rem;
      font-weight: bold;
      color: white;
      border-radius: 30px;
      box-shadow: 0 5px 15px rgba(0,0,0,0.1);
      background-color: rgba(0,0,0,0.5);
    }

    /* 題目區塊 */
    .question-display {
      background-color: rgba(255,255,255,0.9);
      border-radius: 20px;
      padding: 20px 30px;
      margin-bottom: 20px;
      width: 80%;
      max-width: 800px;
      text-align: center;
      font-size: 1.8rem;
      color: #333;
      box-shadow: 0 15px 30px rgba(0,0,0,0.2);
      position: relative;
      z-index: 10;
      min-height: 100px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .question-display:before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 10px;
      background: linear-gradient(to right, #FF9F43, #FF5E7D);
      border-radius: 20px 20px 0 0;
    }
    .author-sign {
      position: absolute;
      right: 5px;
      bottom: 5px;
      color: #ccc;
      font-size: 10px;
      pointer-events: none;
    }

    /* ninja-area */
    .ninja-area {
      display: flex;
      justify-content: space-between;
      gap: 10px;
      width: 120%;
      max-width: 1200px;
      height: 440px;
      position: relative;
      margin-top: 20px;
      margin-left: auto;
      margin-right: auto;
    }

    /* 二方區塊：外觀改為窗戶風格，保留背景圖設定，
       背景色為淡綠色50%透明，窗框邊線加粗至6px並增加立體感 */
    .team-area {
      width: 60%;
      height: 100%;
      background-color: rgba(144,238,144,0.5);
      background-size: cover;
      background-repeat: no-repeat;
      background-position: center;
      background-blend-mode: multiply;
      border: 6px solid #555;
      border-radius: 10px;
      box-shadow: inset 0 0 10px rgba(255,255,255,0.6), 0 10px 20px rgba(0,0,0,0.5);
      position: relative;
      overflow: hidden;
    }
    .team-name {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      background-color: rgba(255,255,255,0.9);
      color: #333;
      font-size: 1.5rem;
      padding: 8px 20px;
      border-radius: 30px;
      z-index: 5;
      box-shadow: 0 5px 15px rgba(0,0,0,0.1);
    }
    .left-team .team-name {
      background-color: #4285f4;
      color: white;
    }
    .right-team .team-name {
      background-color: #ea4335;
      color: white;
    }
    .score-display {
      position: absolute;
      top: 60px;
      left: 50%;
      transform: translateX(-50%);
      background-color: rgba(255,255,255,0.9);
      font-size: 2rem;
      font-weight: bold;
      padding: 5px 15px;
      border-radius: 15px;
      z-index: 5;
      box-shadow: 0 5px 10px rgba(0,0,0,0.1);
    }
    .left-team .score-display {
      color: #4285f4;
    }
    .right-team .score-display {
      color: #ea4335;
    }

    .fruit-container {
      position: absolute;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }

    /* 選項樣式，新增 white-space: nowrap 確保排版固定 */
    .fruit {
      position: absolute;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      white-space: nowrap;
      font-weight: bold;
      color: white;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
      cursor: pointer;
      overflow: hidden;
      box-shadow: 0 5px 15px rgba(0,0,0,0.2);
      user-select: none;
      transition: transform 0.1s, width 0.2s;
      padding: 0 10px;
      height: 50px;
      width: auto;
      border-radius: 5px;
      font-size: 1.5rem;
    }
    .fruit::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.5) 5%, transparent 40%);
    }
    .fruit.watermelon {
      background: linear-gradient(45deg, #229954, #2ECC71);
    }
    .fruit.orange {
      background: linear-gradient(45deg, #E67E22, #F39C12);
    }
    .fruit.strawberry {
      background: linear-gradient(45deg, #C0392B, #E74C3C);
    }
    .fruit.blueberry {
      background: linear-gradient(45deg, #2980B9, #3498DB);
    }
    .fruit.pineapple {
      background: linear-gradient(45deg, #F1C40F, #FFD700);
    }
    .fruit.correct {
      transform: scale(1.2);
      animation: correct-slice 0.5s forwards;
    }
    .fruit.wrong {
      animation: wrong-slice 0.5s forwards;
    }
    .fruit.sliced-top {
      clip-path: polygon(0% 0%, 100% 0%, 100% 50%, 0% 50%);
      animation: fall-top 1s forwards;
    }
    .fruit.sliced-bottom {
      clip-path: polygon(0% 50%, 100% 50%, 100% 100%, 0% 100%);
      animation: fall-bottom 1s forwards;
    }
    @keyframes correct-slice {
      0% { transform: scale(1); }
      50% { transform: scale(1.2); }
      100% { transform: scale(0); }
    }
    @keyframes wrong-slice {
      0% { transform: scale(1); opacity: 1; }
      100% { transform: scale(0); opacity: 0; }
    }
    @keyframes fall-top {
      0% { transform: translateY(0) rotate(0deg); }
      100% { transform: translateY(-300px) translateX(-100px) rotate(-30deg); opacity: 0; }
    }
    @keyframes fall-bottom {
      0% { transform: translateY(0) rotate(0deg); }
      100% { transform: translateY(300px) translateX(100px) rotate(30deg); opacity: 0; }
    }
    .sword-slash {
      position: absolute;
      width: 0;
      height: 8px;
      background-color: white;
      border-radius: 4px;
      transform-origin: left center;
      box-shadow: 0 0 10px 2px rgba(255,255,255,0.8);
      z-index: 20;
      opacity: 0;
    }
    .font-toggle-button {
      background: linear-gradient(to bottom, #9C27B0, #673AB7);
      color: white;
      border: none;
      border-radius: 50px;
      padding: 10px 20px;
      font-size: 1rem;
      cursor: pointer;
      box-shadow: 0 5px 0 #4A148C, 0 10px 20px rgba(0,0,0,0.2);
      transition: all 0.3s;
      font-weight: bold;
    }
    .font-toggle-button:hover {
      transform: translateY(-3px);
      box-shadow: 0 8px 0 #4A148C, 0 15px 25px rgba(0,0,0,0.25);
    }
    .font-toggle-button.active {
      background: linear-gradient(to bottom, #7E57C2, #5E35B1);
      box-shadow: 0 5px 0 #4A148C, 0 10px 20px rgba(0,0,0,0.2);
    }
    .question-number {
      background-color: white;
      padding: 10px 20px;
      border-radius: 50px;
      font-size: 1.3rem;
      font-weight: bold;
      color: #333;
      box-shadow: 0 5px 15px rgba(0,0,0,0.1);
    }
    .winner-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.5s;
    }
    .winner-screen.show {
      opacity: 1;
      pointer-events: all;
    }
    .winner-content {
      background: white;
      padding: 40px;
      border-radius: 20px;
      text-align: center;
      box-shadow: 0 20px 40px rgba(0,0,0,0.3);
      animation: pop-in 0.5s;
      position: relative;
    }
    @keyframes pop-in {
      0% { transform: scale(0.5); opacity: 0; }
      70% { transform: scale(1.1); }
      100% { transform: scale(1); opacity: 1; }
    }
    .winner-content h2 {
      font-size: 3rem;
      color: #FF5E7D;
      margin-bottom: 20px;
    }
    .winner-team {
      font-size: 4rem;
      margin: 20px 0;
      font-weight: bold;
      background: linear-gradient(to right, #4285f4, #4285f4, #ea4335, #ea4335);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
    }
    .restart-button {
      background: linear-gradient(to bottom, #FF9F43, #FF5E7D);
      color: white;
      border: none;
      border-radius: 50px;
      padding: 15px 40px;
      font-size: 1.5rem;
      cursor: pointer;
      box-shadow: 0 5px 0 #E65100, 0 10px 20px rgba(0,0,0,0.2);
      transition: all 0.3s;
      margin-top: 20px;
      font-weight: bold;
    }
    .restart-button:hover {
      transform: translateY(-3px);
      box-shadow: 0 8px 0 #E65100, 0 15px 25px rgba(0,0,0,0.25);
    }
    /* 題庫輸入面板 */
    #question-bank-panel {
      position: fixed;
      top: 50%; /* 調整為50%以居中 */
      left: 50%;
      transform: translate(-50%, -50%);
      background: white;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 5px 15px rgba(0,0,0,0.3);
      z-index: 2000;
      display: none;
      width: 80%;
      max-width: 500px;
    }
    #question-bank-panel textarea {
      width: 100%;
      height: 200px;
      margin-bottom: 10px;
      font-size: 1rem;
      padding: 10px;
    }
    #question-bank-panel button {
      padding: 10px 20px;
      font-size: 1rem;
      cursor: pointer;
    }
    /* 移除原下方 footer 區塊 */
    
    /* 音量控制按鈕 */
    .volume-control {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 1000;
      background-color: rgba(255,255,255,0.7);
      border-radius: 50%;
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }
    .volume-control:hover {
      background-color: rgba(255,255,255,0.9);
    }
    .volume-icon {
      width: 24px;
      height: 24px;
    }
    /* 調整內容區塊的 flex 佈局 */
    #question-bank-panel .input-controls {
        display: flex;
        flex-direction: column;
        gap: 10px;
    }
    </style>
</head>
<body onclick="window.dropmenu();window.expand();"  ontouchstart="window.expand();" >

     <div id="screenArea" class="p-0 bg-white shadow-lg rounded-xl" style="border:2px double gray "><!-- 全螢幕範圍開始 -->





<!-- 測驗區開始 -->
<!-- 彈出視窗 Modal 結構 (用於顯示錯誤或最終分數) -->
<div id="modalOverlay" class="fixed inset-0 bg-black bg-opacity-50 hidden justify-center items-center z-50">
    <div id="modalContent" class="bg-white p-6 rounded-xl shadow-2xl max-w-sm w-full text-center" style="margin-left:500px;margin-top:200px" >
        <h3 id="modalTitle" class="text-xl font-bold mb-4  "></h3>
        <p id="modalBody" class="text-xl font-medium text-gray-700 mb-6"></p>
        <button onclick="document.getElementById('modalOverlay').classList.add('hidden')" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700">關閉</button>
    </div>
</div>


<!-- 測驗區結束 -->



    
    <!-- 隱藏的 DOM 元素，用於儲存和讀取資料 (即使編輯器未顯示，也必須存在) -->
    <div id="quizArea" class="hidden">
        <div id="quizData" contenteditable="true">
1 | 哪種水果是紅色的? | 1 | 蘋果 | 香蕉 | 葡萄 | 橘子
2 | 10 + 5 等於多少? | 3 | 12 | 14 | 15 | 16
3 | 地球繞著什麼轉? | 4 | 月亮 | 火星 | 金星 | 太陽
4 | 台灣的首都在哪裡? | 1 | 台北 | 台中 | 高雄 | 台南
        </div>
    </div>









<!-- 雙人遊戲開始  dual game-->

       <div id="cannonGame" class="hidden game-container flex flex-col items-center w-full">
     



        <!-- 初始啟動畫面 -->
        <div id="start-screen" class="flex flex-col items-center justify-center p-12 bg-gray-700 rounded-lg w-full h-[600px] text-center">
            <h2 class="text-3xl font-semibold mb-4 text-white">歡迎來到對戰射擊場！</h2>
            <p class="mb-8 text-lg text-gray-300">擊中正確答案的方塊以得分。P1 先發射。</p>
            <!-- 函數呼叫更新 -->
            <button id="start-button" onclick="dual_startGame()" class="bg-blue-600 text-white text-2xl font-bold py-4 px-10 rounded-xl hover:bg-blue-700">
                🚀 開始遊戲
            </button>
        </div>

        <!-- 遊戲元素區域 (預設隱藏) -->
        <div id="game-elements" class="hidden w-full flex flex-col items-center">
        
            <!-- Scoreboard -->
            <div class="flex justify-between w-full mb-4 px-4 text-lg font-bold">
                <div class="player-1-text">P1 分數: <span id="score-p1">0</span></div><p id="game-status" class="text-xl font-bold text-yellow-300 text-center mb-3">準備開始...</p>
<button onclick="window.toggleGameTheme('none');" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700">關閉</button>
                <div class="player-2-text">P2 分數: <span id="score-p2">0</span></div>
            </div>
            
            <!-- 遊戲狀態/測驗區 (僅顯示文字) -->
            <div id="quiz-panel" class="w-full bg-yellow-900/50 p-4 rounded-lg mb-4 border border-yellow-500 transition duration-300 min-h-[50px]">                
                <p id="question-text" class="text-xlg font-medium text-white text-center" style="font-size:35px" ></p>
            </div>

            <!-- Canvas for the Game Area width="800" height="450"-->
            <canvas id="game-canvas" width="1280" height="600"></canvas>
            
            <!-- Controls Section -->
            <div class="w-full flex justify-between space-x-4 mt-6">
                
                <!-- Player 1 Controls -->
                <div id="p1-controls" class="player-control-panel flex-1 player-1-text">
                    <h2 class="text-xl mb-3 font-bold">Player 1 </h2>
                    
                    <div class="control-label">瞄準角度: <span id="angle-p1">45</span>°</div>
                    <!-- 函數呼叫更新 -->
                    <input type="range" id="angle-slider-p1" min="10" max="90" value="45" oninput="dual_updateAngle(1, this.value)">
                    
                    <!-- 函數呼叫更新 -->
                    <button onclick="dual_fireBullet(1)" class="fire-btn-base bg-red-600 hover:bg-red-700 text-white" id="fire-btn-p1" disabled>
                        FIRE!
                    </button>
                </div>

                <!-- Player 2 Controls -->
                <div id="p2-controls" class="player-control-panel flex-1 player-2-text">
                    <h2 class="text-xl mb-3 font-bold">Player 2</h2> 
                    
                    <div class="control-label">瞄準角度: <span id="angle-p2">135</span>°</div>
                    <!-- 函數呼叫更新 -->
                    <input type="range" id="angle-slider-p2" min="90" max="170" value="135" oninput="dual_updateAngle(2, this.value)">

                    <!-- 函數呼叫更新 -->
                    <button onclick="dual_fireBullet(2)" class="fire-btn-base bg-green-600 hover:bg-green-700 text-white" id="fire-btn-p2" disabled>
                        FIRE!
                    </button>
                </div>
            </div>
        </div>
    </div>




<!--雙人遊戲結束  dual game-->

<!-- 忍者切水果開始 -->
<div id="gamebody" style="display:none" >
<div  title="關閉" onclick="document.getElementById('gamebody').style.display='none';"  style="color:gray;cursor:hand;font-size:26px;font-weight:bolder;margin-left:2px;font-size:20px;" >🗷</div>
  <div id="confetti-container"></div>
  <div class="volume-control" id="volume-control">
    <img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9ImN1cnJlbnRDb2xvciIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGNsYXNzPSJsdWNpZGUgbHVjaWRlLXZvbHVtZS0yIj48cG9seWdvbiBwb2ludHM9IjExIDUgNiA5IDIgOSAyIDE1IDYgMTUgMTEgMTkgMTEgNSIvPjxwYXRoIGQ9Ik0xOS4wNyA0LjkzYTEwIDEwIDAgMCAxIDAgMTQuMTQiLz48cGF0aCBkPSJNMTUuNTQgOC40NmE1IDUgMCAwIDEgMCA3LjA3Ii8+PC9zdmc+" alt="音量開" class="volume-icon" id="volume-on">
    <img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9ImN1cnJlbnRDb2xvciIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGNsYXNzPSJsdWNpZGUgbHVjaWRlLXZvbHVtZS14Ij48cG9seWdvbiBwb2ludHM9IjExIDUgNiA5IDIgOSAyIDE1IDYgMTUgMTEgMTkgMTEgNSIvPjxsaW5lIHgxPSIyMyIgeTE9IjkiIHgyPSIxNyIgeTI9IjE1Ii8+PGxpbmUgeDE9IjE3IiB5MT0iOSIgeDI9IjIzIiB5Mj0iMTUiLz48L3N2Zz4=" alt="音量關" class="volume-icon" id="volume-off" style="display: none;">
  </div>
  <div class="game-container">
    <div class="question-controls">
      <div class="controls-left">
        <button id="next-question" class="next-button">下一題</button>
        <button id="toggle-font" class="font-toggle-button">切換注音字體</button>
        <button id="speed-toggle" class="speed-toggle-button">速度快</button>
      </div>
      <div class="question-number" id="question-number">第 1 題 / 4 題</div>
    </div>
    <div class="question-display" id="question-display">
      <div class="author-sign">Made by 阿剛老師</div>
    </div>
    <div class="ninja-area">
      <div class="team-area left-team">
        <div class="team-name">藍隊</div>
        <div class="score-display" id="team1-score">0</div>
        <div class="fruit-container" id="team1-fruit-container"></div>
      </div>
      <div class="team-area right-team">
        <div class="team-name">紅隊</div>
        <div class="score-display" id="team2-score">0</div>
        <div class="fruit-container" id="team2-fruit-container"></div>
      </div>
    </div>
  </div>
  <div id="winner-screen" class="winner-screen">
    <div class="winner-content">
      <h2>恭喜獲勝！</h2>
      <div id="winner-team" class="winner-team"></div>
      <button id="restart-button" class="restart-button">重新開始</button>
    </div>
  </div>
  <div id="question-bank-panel">
    <p>請在此貼上題庫，每行一筆，欄位以 **|** 或 **tab** 分隔，格式為：<br>**[題號] | [題目] | [正確答案索引 1-4] | [選項1] | [選項2] | [選項3] | [選項4]**</p>
    <textarea id="question-bank-input" placeholder="請貼上題庫，每行一筆資料，欄位順序依次：題號, 題目, 答案(1/2/3/4), 選項1, 選項2, 選項3, 選項4，欄位以 | 或 tab 分隔">
1 | 哪種水果是紅色的? | 1 | 蘋果 | 香蕉 | 葡萄 | 橘子
2 | 10 + 5 等於多少? | 3 | 12 | 14 | 15 | 16
3 | 地球繞著什麼轉? | 4 | 月亮 | 火星 | 金星 | 太陽
4 | 台灣的首都在哪裡? | 1 | 台北 | 台中 | 高雄 | 台南</textarea>
    <div class="input-controls">
        <button id="question-bank-submit">送出並開始遊戲</button>
    </div>
  </div>

</div>
  <audio id="correct-sound" preload="auto">
    <source src="right.mp3" type="audio/mp3">
    <source src="https://taira-komori.jpn.org/sound_os2/game01/jump05.mp3" type="audio/mp3">
  </audio>
  <audio id="wrong-sound" preload="auto">
    <source src="wrong.mp3" type="audio/mp3">
    <source src="https://taira-komori.jpn.org/sound_os2/game01/powerdown05.mp3" type="audio/mp3">
  </audio>
  <audio id="slice-sound" preload="auto">
    <source src="https://taira-komori.jpn.org/sound_os2/game01/swish.mp3" type="audio/mp3">
  </audio>
  <audio id="bgm" loop>
    <source src="" type="audio/mp3">
  </audio>

<!-- 結束忍者切水果 -->
    <!-- 抽號碼開始 -->

<div id="picker-wrapper" class="picker-container hidden" >
    <h2 class="text-2xl font-bold mb-6 text-orange-800">班級抽號機 </h2>
    
    <!-- FLIP CONTAINER WRAPPER -->
    <div id="flipContainer" class="flip-container">
        <div id="flipper" class="flipper">
            <!-- FRONT SIDE: Shows the initial question mark -->
            <div class="front">
                <div class="card-content">?</div>
            </div>
            <!-- BACK SIDE: Shows the drawn number -->
            <div class="back">
                <div id="resultDisplay" class="card-content"></div>
            </div>
        </div>
    </div>
    <!-- END FLIP CONTAINER WRAPPER -->
    
    <!-- 抽號碼按鈕 -->
    <button 
        id="pickBtn"
        onclick="window.pickNumber()" 
        class="w-full mb-4 px-6 py-3 text-lg font-semibold text-white bg-blue-600 rounded-xl hover:bg-blue-700 transition duration-150 shadow-lg shadow-blue-500/50"
    >
        抽號碼
    </button>
    
    <!-- 重置按鈕 -->
        <button onclick="document.getElementById('picker-wrapper').classList.add('hidden')" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700">關閉</button>
    <button 
        onclick="window.resetPicker()" 
        class="w-full px-6 py-2 text-md font-medium text-gray-700 bg-gray-200 rounded-xl hover:bg-gray-300 transition duration-150"
    >
        重置號碼池
    </button>

    <div class="mt-8 pt-4 border-t border-gray-200">
        <h2 class="text-lg font-semibold mb-2">已抽出的號碼 (<span id="countDisplay">0</span> / <input type="number" id="maxClassNumber" min="1" max="30" step="1" value="30" oninput="window.resetPicker();" >)</h2>
        <div id="pickedList" class="text-sm text-gray-600 flex flex-wrap justify-center gap-2">
            <!-- 已抽出的號碼將顯示在這裡 -->
        </div>
 
    </div>
</div>

<!-- 彈出視窗 Modal 結構 -->


    <!-- 抽號碼結束 -->



<!-- 分組計分板 -->
<div id="teamBoard" style="display:none;position:absolute;left:calc(50vw - 350px);top:40px;height:40px;width:700px;z-index:50;font-size:20px;background:lightyellow;border-radius:6px; border:4px solid lightgrey" >
<span  title="關閉" onclick="document.getElementById('teamBoard').style.display='none';"  style="color:gray;cursor:hand;font-size:26px;font-weight:bolder;margin-left:10px;font-size:20px;" >🗷</span>
<!-- 分組計分 -->
<b>Team</b>
<font color="dodgerblue" ><b>  1 </b></font>
<div style="margin:4px;display:inline;background:lightcyan;border-radius:6px;width:120px; border:1px solid lightgrey" >

<div style="display:inline; " onclick="document.getElementById('tem_1').value=Number(document.getElementById('tem_1').value)+1;">+</div>
<input type="text" id="tem_1" size="2" value="0" style="height:20px;width:30px;" >
<div style="display:inline; " onclick="document.getElementById('tem_1').value=Number(document.getElementById('tem_1').value)-1;">-</div></div>

<!-- 分組計分 -->
<font color="orange" ><b>  2 </b></font>
<div style="margin:4px;display:inline;background:yellow;border-radius:6px;width:120px; border:1px solid lightgrey" >

<div style="display:inline;color:gray" onclick="document.getElementById('tem_2').value=Number(document.getElementById('tem_2').value)+1;">+</div>
<input type="text" id="tem_2" size="2" value="0" style="height:20px;width:30px" >
<div style="margin:4px;display:inline;color:gray" onclick="document.getElementById('tem_2').value=Number(document.getElementById('tem_2').value)-1;">-</div></div>
<!-- 分組計分 -->
<font color="lime" ><b>   3 </b></font>
<div style="margin:4px;display:inline;background:lime;border-radius:6px;width:120px; border:1px solid lightgrey" >

<div style="display:inline; " onclick="document.getElementById('tem_3').value=Number(document.getElementById('tem_3').value)+1;">+</div>
<input type="text" id="tem_3" size="2" value="0" style="height:20px;width:30px" >
<div style="display:inline; " onclick="document.getElementById('tem_3').value=Number(document.getElementById('tem_3').value)-1;">-</div></div>
<!-- 分組計分 -->
<font color="lightseagreen" ><b>  4 </b></font>
<div style="margin:4px;display:inline;background:lightskyblue;border-radius:6px;width:120px; border:1px solid lightgrey" >

<div style="display:inline;color:gray" onclick="document.getElementById('tem_4').value=Number(document.getElementById('tem_4').value)+1;">+</div>
<input type="text" id="tem_4" size="2" value="0" style="height:20px;width:30px" >
<div style="display:inline;color:gray" onclick="document.getElementById('tem_4').value=Number(document.getElementById('tem_4').value)-1;">-</div></div>
<!-- 分組計分 -->
<font color="fuchsia" ><b>   5  </b></font>
<div style="margin:4px;display:inline;background:fuchsia;border-radius:6px;width:120px; border:1px solid lightgrey" >

<div style="display:inline; " onclick="document.getElementById('tem_5').value=Number(document.getElementById('tem_5').value)+1;">+</div>
<input type="text" id="tem_5" size="2" value="0" style="height:20px;width:30px" >
<div style="display:inline; " onclick="document.getElementById('tem_5').value=Number(document.getElementById('tem_5').value)-1;">-</div></div>
<!-- 分組計分 -->
<font color="red" ><b>  6 </b></font>
<div style="margin:4px;display:inline;background:tomato;border-radius:6px;width:120px; border:1px solid lightgrey" >

<div style="display:inline;color:gray" onclick="document.getElementById('tem_6').value=Number(document.getElementById('tem_6').value)+1;">+</div>
<input type="text" id="tem_6" size="2" value="0" style="height:20px;width:30px" >
<div style="display:inline;color:gray" onclick="document.getElementById('tem_6').value=Number(document.getElementById('tem_6').value)-1;">-</div></div>
  
</div>

<!-- side page controllers-->
<div style="position:absolute;top:50vh;left:98vw;width:15px;height:25px;font-size:30px;z-index:50" >
 <div style="display:inline;color:gray" onclick="goToPreviousPage();"  ontouchstart="goToPreviousPage();">🜂</div> <div style="display:inline;color:gray" onclick="goToNextPage();"  ontouchstart="goToNextPage();">🜄</div>   
</div>
 
<div style="position:absolute;top:50vh;left:0;width:15px;height:25px;font-size:30px;z-index:50" >
 <div style="display:inline;color:gray" onclick="goToPreviousPage();"  ontouchstart="goToPreviousPage();">🜂</div> <div style="display:inline;color:gray" onclick="goToNextPage();"  ontouchstart="goToNextPage();">🜄</div>   
</div>



<!--≡main toolbar area-->
    <div id="main-toolbar" >

 



 <button style="background-color:lime;border-radius:8px;padding:8px;box-shadow:1px 1px gray" onclick="document.getElementById('page-manager').style.display=(document.getElementById('page-manager').style.display=='none')?'':'none';document.getElementById('project-manager').style.display=(document.getElementById('project-manager').style.display=='none')?'':'none';">
  pages</button>



<details style="background-color:yellow;width:100px;box-shadow:1px 1px gray">
  <summary>Project</summary>
  <ul>
    <li><button onclick="window.saveProject()" title="Save to Cloud" >💾儲存雲端</button></li>
    <li><button onclick="window.renderAllProjectsList()" title=" Switch/Create Project" >📂開啟/新增專案</button></li>
    <li>        <button onclick="importProject()"  title="import" >📥匯入</button>
              <input type="file" id="importFile" accept=".json" style="display: none;" onchange="handleFileImport(event)"> </li>
    <li><button onclick="exportProject()" title="export"  >📤匯出</button></li>
    <li><button onclick="document.all.codeArea.style.display='';document.getElementById('htmlPageCode').value=editor.innerHTML;" title="Coding"  >✍編輯原始碼</button></li>
  </ul>
</details>
<button onclick="window.renderAllProjectsList()" title=" Switch/Create Project"  style="display:inline;font-size:15px;width:60px" class=" gap-2 p-2 rounded-lg border border-gray-200 " >📂</button>
  <button id="add"  title="插入" onclick="document.getElementById('Scale').value='95';window.setZoom(95)"   style="display:inline;font-size:15px;width:90px" class=" gap-2 p-2 rounded-lg border border-gray-200 ">➕🖼️</button>
<button id="layerControl" onclick="document.getElementById('Scale').value='95';window.setZoom(95)" style="width:90px; "  class=" gap-2 p-2 rounded-lg border border-gray-200 ">🌈樣式</button>	
<span style="display:inline">
            <select id="addElementType" onchange="window.addNewTextElement(this.value)"  class="px-1 py-1 h-10 bg-blue-500 text-white font-xssemibold rounded-lg hover:bg-blue-600 transition duration-150 shadow-md cursor-pointer">
                <option value="" disabled selected class="bg-gray-700 text-white">➕插入文字</option>
                <option value="P" class="bg-white text-gray-800">一般文字</option>
                <option value="H1" class="bg-white text-gray-800">黑框字</option>
                <option value="H2" class="bg-white text-gray-800">光暈字</option>
                <option value="H3" class="bg-white text-gray-800">陰影字</option>
                <option value="Animateout" class="bg-white text-gray-800">動畫字</option>
                <option value="Hinter" class="bg-white text-gray-800">答案選項</option>
                <option value="DropMenu" class="bg-white text-gray-800">隱藏內文</option>
                <option value="Poke" class="bg-white text-gray-800">撲克牌</option>
                <option value="TTS" class="bg-white text-gray-800">報讀文字</option>
                <option value="VRS" class="bg-white text-gray-800">聽讀文字</option>
                <option value="Quiz" class="bg-white text-gray-800" >測驗題庫</option>
            </select></span>
<!--文字編輯列-->
<button id="textStyle" onclick="" style="border:2px solid black;width:30px;font-size:18px" >🗛</button> 

<div id="textStyle_menu" style="display:none;align-items: center;padding:4px;background:mintcream;border:1px solid gray;border-radius:8px;z-index:31;height:40px;" >
<span  title="關閉" onclick="document.getElementById('textStyle_menu').style.display='none';"  style="color:gray;cursor:hand;font-weight:bolder;margin-right:5px;margin-left:5px;font-size:20px;" >🗷</span>

               <button id="editToggleBtn"  title="啟用/停用-編輯文字區塊" onclick="window.toggleContentEditable();" disabled class="hidden px-2 py-2 bg-teal-500 text-white font-semibold rounded-lg hover:bg-yellow-500 transition duration-150 shadow-md">編輯文字區塊</button>
                <button onclick="runTextCommand('bold')" title="粗體" class="px-2 py-1 text-gray-700 bg-white border border-gray-300 rounded-lg hover:bg-gray-100">B</button>
                <button onclick="runTextCommand('italic')" title="斜體" class="px-3 py-1 text-gray-700 bg-white border border-gray-300 rounded-lg hover:bg-gray-100">I</button>
                <button onclick="runTextCommand('underline')" title="底線" class="px-2 py-1 text-gray-700 bg-white border border-gray-300 rounded-lg hover:bg-gray-100">U</button>
                
                <!-- formatBlock dropdown removed -->
                
                <input type="color" id="fontColor" onchange="setFontColor()"  onblur="setFontColor()" title="文字色彩" value="#1f2937" class="h-8 w-10 border-none">
                
                <!-- Font Size Dropdown (functional) -->
                <select id="fontSize" onchange="setFontSize()" title="字體大小(1-7)"  style="border:1px solid lightgray;padding:2px;border-radius:6px">
                    <option value="1">Size 1</option>
                    <option value="2">Size 2</option>
                    <option value="3" selected>Size 3</option>
                    <option value="4">Size 4</option>
                    <option value="5">Size 5</option>
                    <option value="6">Size 6</option>
                    <option value="7">Size 7</option>
                </select>
                
		<select id="fontSelector" onchange="changeFont()" style="border:1px solid lightgray;padding:2px;border-radius:6px">
		  <option value="Arial">Arial</option>
		  <option value="Verdana">Verdana</option>
		  <option value="Times New Roman">Times New Roman</option>
		  <option value="Courier New">Courier New</option>
		  <option value="Comic Sans MS">Comic Sans MS</option>
		  <option value="Pacifico">Pacifico</option>
		  <option value="Microsoft JhengHei">微軟正黑體</option>
		  <option value="DFKai-SB">標楷體</option>
		  <option value="PMingLiU">新細明體</option>
		  <option value="cwTeXYen (Chinese Traditional)">圓體字體</option>

		</select>


                <button  title="插入超連結" onclick="window.insertLink();window.showModa('圖層需「🔏鎖定」才能在觸屏使用','info')" title="Insert Link" class="px-1 py-1 text-gray-700 bg-white border border-gray-300 rounded-lg hover:bg-gray-100">🔗</button>
                <button  title="移除超連結" onclick="window.removeLink()" title="Remove Link" class="px-1 py-1 text-gray-700 bg-white border border-gray-300 rounded-lg hover:bg-gray-100">🚫</button>
             <button onclick="window.undo()" class="px-1 py-1 bg-gray-100 text-white font-semibold rounded-lg hover:bg-green-600 transition duration-150 shadow-md" id="undoBtn"   title="復原上一步Undo (Ctrl+Z)">↩️</button>
            <button onclick="window.redo()" class="px-1 py-1 bg-gray-100 text-white font-semibold rounded-lg hover:bg-green-600 transition duration-150 shadow-md" id="redoBtn"   title="重作上一步Redo (Ctrl+Y)">↪️</button>
            
             <button onclick="window.duplicateActiveItem()" title="再製" style="font-size:20px">🗐</button>|<button onclick="window.pasteClone();" title="貼上物件">📋</button>
</div>


  <!-- Text Formatting Controls (only for inline styles now) --> 
  


 <button 
        onclick="document.getElementById('Scale').value='100';window.setZoom(100)" 
        class="px-1 py-1 bg-green-600 text-white text-xs font-semibold rounded-lg hover:bg-green-700 transition duration-150 shadow-md">
        100%
    </button> 
    <div id="panScaleBar" style="position:relative;border-left: 1px solid #ccc; margin: 0 5px; padding-left: 10px;display:inline"  >🔍
<div id="panScaleBar_menu" style="display:none;background-color:lightblue;border:10px solid black;border-radius:18px;position:absolute;top:20px;left:-250;width:550px;hieght:100px;padding:10px;z-index:50;" >

🔍<div id="panScale" style="display:inline"></div>

   頁面
    <input 
        type="range" 
        id="zoom" 
        min="5" 
        max="20" 
        step="1" 
        value="10" 
        title="Zoom Scale" 
        style="width:100px;margin:10px" 
        oninput="setZoom();" 
    >
<button 
    id="pan-toggle-btn" 
    onclick="togglePanMode()" 
    class="px-2 py-1 bg-blue-100 text-white text-xs font-semibold rounded-lg hover:bg-blue-700 transition duration-150 shadow-md">
    🤚
</button>
    <button 
        onclick="document.getElementById('Scale').value='90';window.setZoom(95)" 
        class="px-1 py-1 bg-green-600 text-white text-xs font-semibold rounded-lg hover:bg-green-700 transition duration-150 shadow-md">
        95%
    </button>
    <button 
        onclick="document.getElementById('Scale').value='100';window.setZoom(100)" 
        class="px-1 py-1 bg-green-600 text-white text-xs font-semibold rounded-lg hover:bg-green-700 transition duration-150 shadow-md">
        100%
    </button>
     🔍視窗
    <input 
        type="range" 
        id="Scale" 
        min="50" 
        max="150" 
        step="1" 
        value="100" 
        title="Browser Zoom Scale" 
        style="width:100px;margin:10px;color:red" 
        oninput="setZoom();" 
    >
<span  title="關閉" onclick="document.getElementById('panScaleBar_menu').style.display='none';"  style="color:gray;cursor:hand;font-weight:bolder;margin-right:5px;margin-left:5px;font-size:20px;" >🗷</span>
    
</div></div>

<!--
            <button onclick="window.toggleEditMode();window.toggleEditable();">Toggle Edit</button>
            <button onclick="document.execCommand('bold', false, null)">B</button>
            <button onclick="window.applyForeColor('#0000ff')">Blue Text</button>
-->
        </div>



    </div>
         <div style="position:absolute;left:0px;top:0px;z-index:50;width:90vw;justify-content:center;align-items: center;">
         
              <div id="tmBar" style="display:none ;position:absolute;z-index:50;top:80px;left:calc(50vw - 150px);width:300px; height: 80px; color:white;font-size:30pt;text-align:center;background-color:darkgreen;opacity:0.8;border-radius:18px;border:2px brown solid;" onclick="this.style.display='none';" >
                  TIME:<span id="gameTimerDisplay" style="color:yellow;font-size:30pt">1:00 </span>
               </div>
               <span id="speechResult" style="display:none;position:absolute;z-index:50;top:80px;left:calc(50vw - 400px);padding: 20px; height:80px;width:800px;background-color:yellow;opacity:0.8;font-color:yellow;font-size:30pt;border-radius:18px;border:4px orange solid;" onclick="this.style.display='none';" ></span>


          </div>


<!-- add image dropmenu -->
          	
<div id="add_menu" style="display:none;position:;top:40px;left:800px;width:;z-index:50" class="flex flex-wrap items-center gap-2 p-3 bg-gray-50 rounded-lg border border-gray-200 mb-4 ">

<span  title="關閉" onclick="document.getElementById('add_menu').style.display='none';"  style="color:gray;cursor:hand;font-size:26px;font-weight:bolder;margin-left:10px;font-size:20px;z-index:30" >🗷</span>


<span style="display:inline" >圖片網址:<input type="text" id="Xurl" value="" size="20" onchange="" style="border:dashed 1px lightgray"></span>
<span onclick="document.getElementById('Xurl').value='';" alt="套用網址套用網址"  style="display:inline;cursor:hand">❎</span>
<span onclick="window.updateBackground()"    class="hover:bg-teal-600 cursor-hand">✔️更新</span>

<button  title="浮動圖片" onclick="window.addDivWithImageBackgroundElement()" class="px-2 py-1 bg-teal-100 text-white font-semibold rounded-lg hover:bg-teal-200 transition duration-150 shadow-md" style="background:darkblue;">➕浮動圖片</button>
<button  title="用網址貼上內文圖片" onclick="window.insertCode('img');" class="px-2 py-1 bg-green-500 text-white font-semibold rounded-lg hover:bg-teal-200 transition duration-150 shadow-md"  >➕內文圖片</button>           
<button  title="用網址貼上網頁框" onclick="window.insertCode('iframe')" class="px-2 py-1 bg-red-500 text-white font-semibold rounded-lg hover:bg-teal-200 transition duration-150 shadow-md"  >➕內文網頁框</button>

    <button  title="從圖庫插入" onclick="addDivWithImageBackgroundElement();document.all.picker.style.display='';"  style="background:cyan;border-radius:25%" >圖庫</button>


            <!-- NEW: Add Text Element Dropdown -->


<!--Start🗃️閃示卡設定-->
<div   id="idop"  onclick=""   class="flex flex-wrap text-s justify-center items-center hover:bg-yellow-100 cursor-hand  rounded-lg border border-gray-200 " style="display:inline;position:relative;width:100px;height:40px;display:inline" >
		🗃️圖卡設定
           <span id="idop_menu" style="display:none;position:absolute;top:-60px;left:20px;width:700px; font-size:18px;background:white;border:2px solid gray;z-index:30;padding:10px;border-radius:15px">
<span  title="關閉" onclick="document.getElementById('idop_menu').style.display='none';"  style="color:gray;cursor:hand;font-size:26px;font-weight:bolder;margin-left:10px;font-size:20px;" >🗷</span>
<span style="display:inline;font-color:blue;" >英文名稱:
<span onclick="window.applyMyInfo();"    class="hover:bg-teal-600 cursor-hand" style="cursor:hand;border:2px solid black;background:yellow" >✔️套用</span>
<input type="text" id="MyID" value="" size="16" color="blue" style=";border:dashed 1px lightgray;padding-left:2px"></span>
<span onclick="document.getElementById('MyID').value=document.getElementById('MyID').value+'-a';applyMyID();"   onmouseover="dropmenu('hintx')" style="position:relative" >❔<font id="hintx" style="display:none;z-index:50;position:absolute;top:80px;left:-60px;width:550px;height:100px;background:lightyellow;border:2px dashed brown" >會在「圖片閃示卡」功能中顯示輸入的名稱，例如:cat<BR>，如果和別的圖同名稱綴加"-a"的話，例如:cat-a，彼此接觸時會有配對反應</font></span>


<HR>
<span style="display:inline" >輸入說明:
<span onclick="window.applyMyInfo();"    class="hover:bg-teal-600 cursor-hand"  style="cursor:hand;border:2px solid black;background:yellow" >
✔️套用</span>

<textarea id="MyInfo"   cols="40"   style="border:dashed 1px lightgray;padding-left:2px"></textarea>
</span>
           </div><!--END🗃️圖卡設定-->

</div>
<!-- add image menu -->












<div id="layerControl_menu"  style="display:none;padding:4px;width:100%px;background-color:mintcream;border:2px solid gray;border-radius:8px;color:black;font-size:12px;justify-content: center;align-items: center;" >

<span  title="關閉" onclick="document.getElementById('layerControl_menu').style.display='none';"  style="color:gray;cursor:hand;font-size:26px;font-weight:bolder;margin-left:2px;font-size:20px;" >🗷</span>
		背景:
<img src="https://static.thenounproject.com/png/2616533-200.png" id="bgicon" alt="Background Preview" width="40" height="40" style="border:2px solid gray;display:inline" onclick="document.getElementById('add_menu').style.display=(document.getElementById('add_menu').style.display=='none')?'inline':'none';">
                底色:<input type="color" id="backgroundColor" onchange="window.setBackgroundColor()" title="底色" value="#ffffaa" class="h-5 w-10 border-none">
<span  title="透明" onclick="window.setBackgroundColor('t')"  style="color:red;cursor:hand;font-size:20px;" >🗷</span>
                
                圓角:
                <input type="range" id="borderRadius" oninput="window.setBorderRadius()" min="0" max="50" value="0" title="Border Radius"  style="width:40px">

                透明度:
                <input type="range" id="elementOpacity" min="0" max="100" value="100" title="Element Opacity" oninput="window.setElementOpacity(this.value)"  style="width:40px">
<button onclick="window.flip();" title="鏡像翻轉flip" class="px-3 py-2 text-gray-700 bg-white border border-gray-300 rounded-lg hover:bg-gray-100">⇄</button>
    <button onclick="window.turn(-15)" title="左轉Turn Left 15 Degrees" class="px-3 py-2 text-gray-700 bg-white border border-gray-300 rounded-lg hover:bg-gray-100">↺ 15°</button>
 <span id="angl" ></span>
<input type="range" id="rotateAngle" oninput="window.setRotation(this.value);document.getElementById('angl').textContent=this.value" min="0" max="359" step="1" value="0" title="旋轉" class="h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"  style="width:40px">
    <button onclick="window.turn(15)" title="右轉Turn Right 15 Degrees" class="px-3 py-2 text-gray-700 bg-white border border-gray-300 rounded-lg hover:bg-gray-100">↻ 15°</button>           

<!--
    <button onclick="window.rotateElement(-5)" title="Turn Left 15 Degrees" class="px-3 py-2 text-gray-700 bg-white border border-gray-300 rounded-lg hover:bg-gray-100">↺ 15°</button>
           <button onclick="window.rotateElement(5)" title="Turn Right 15 Degrees" class="px-3 py-2 text-gray-700 bg-white border border-gray-300 rounded-lg hover:bg-gray-100">↻ 15°</button>
-->

</span>

<div style="border-radius:12px;background-color:lightblue;padding:8px;">
    <label for="borderColor">框色:</label>

<input type="color" id="borderColor" onchange="window.applyBorderChanges()" title="框色" value="#ffffaa" class="h-5 w-10 border-none">
    <label for="borderWidth">粗細:</label>
    <select id="borderWidth" onchange="window.applyBorderChanges()">
        <option value="1px">1px</option>
        <option value="2px">2px</option>
        <option value="5px">5px</option>
        <option value="10px">10px</option>
    </select>

    <label for="borderStyle">樣式:</label>
    <select id="borderStyle" onchange="window.applyBorderChanges()">
        <option value="solid">____</option>
        <option value="dashed">------</option>
        <option value="dotted">..........</option>
        <option value="double">=====</option>
    </select>
</div>
| <button  title="頁面背景" onclick="window.dobg();" style="border:2px solid gray;padding:2px">設為頁面底色</button>
| <button  title="頁面背景" onclick="window.dobg('bk');"  style="border:2px solid gray;padding:2px">更換頁面底圖</button>


           <!-- Layer, Lock, Delete Controls -->       
<button onclick="window.deleteSelectedItem()" title="刪除選取物件" class="px-2 py-1 bg-red-500 text-white font-semibold rounded-lg hover:bg-red-600 transition duration-150 shadow-md">❎</button>

            <button onclick="window.bringForward()" title="上移圖層" class="px-3 py-2 text-gray-700 bg-white border border-gray-300 rounded-lg hover:bg-gray-100">⇧</button>
            <button onclick="window.sendBackward()" title="下移圖層" class="px-3 py-2 text-gray-700 bg-white border border-gray-300 rounded-lg hover:bg-gray-100">⇩</button>
<!-- Page Navigator -->
            <button id="lockToggleBtn" onclick="window.toggleLock()"  title="固定或解鎖位置" class="px-2 py-2 bg-yellow-500 text-white font-semibold rounded-lg hover:bg-yellow-600 transition duration-150 shadow-md">🔏固定/浮動🔒</button>

<select id="addAnimateType" onchange="window.toggleAnimate(this.value)"  class="px-1 py-1 bg-blue-500 text-white font-xssemibold rounded-lg hover:bg-blue-600 transition duration-150 shadow-md cursor-pointer" style="display:inline;width:">
                <option value="" disabled selected class="bg-gray-700 text-white">動畫</option>

                <option value="animate-spin"  class="bg-gray-700 text-white">旋轉</option>
                <option value="animate-bounce"  class="bg-gray-700 text-white">彈跳</option>

                <option value="animate-ping"  class="bg-gray-700 text-white">放大</option>
                <option value="animate-pulse"  class="bg-gray-700 text-white">閃爍</option>
                <option value="animate-none"  class="bg-gray-700 text-white">無</option>
                <option value="translate-y-full  transition-all duration-700 ease-out "  class="bg-gray-700 text-white">沖天</option>
                <option value="skewed-title"  class="bg-gray-700 text-white">立體字</option>
 
      <!-- 		//####-translate-x-full  translate-x-0 -translate-y-80 ,'-translate-y-80'
		//###animate-none .animate-ping animate-pulse animate-spin  animate-bounce animate-spin .animate-bounce
       -->
</select>



</div><!--End edit image -->









<!-- ########################################################-->

    <div id="main-container">
 
       <div id="page-manager" style="display:" >

            <div id="project-manager" style="display:" >
             <span id="currentProjectDisplay">classroom_master_file</span> 
             </div>

         <button onclick="window.addPageAfterActive()" class="px-1 py-1 bg-blue-500 text-white font-xssemibold rounded-lg hover:bg-blue-600 transition duration-150 shadow-md">插入頁面</button>
         <button onclick="window.createNewPage()"class="hidden px-1 py-1 bg-blue-500 text-white font-xssemibold rounded-lg hover:bg-blue-600 transition duration-150 shadow-md">新增頁面</button>
            <ul id="page-list">
                </ul>
        </div>
        
        <div id="editor-wrapper" id="editor-container" style="overflow: auto;"> 
            <div id="editor"  contenteditable="true" style="transform: scale(X); transform-origin: top left;">
<canvas id="drawingCanvas" ></canvas>
                Loading project data from Firestore...            
            </div> 

        </div>
    </div>
 <!-- ########################################################-->
   <div id="project-list-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000;">
        <div style="background: white; width: 800px; height:90%;margin: 50px auto; padding: 20px; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.2);">
            <h2 style="margin-top: 0;">專案選單</h2>
            
            輸入專案名稱:<input type="text" id="new-project-id-input" placeholder="Enter new project ID or select below" style="width: 50%; padding: 10px; margin-bottom: 15px; box-sizing: border-box;border:2px dotted gray">
            <button onclick="window.switchProjectAndCloseList(document.getElementById('new-project-id-input').value)" style="padding: 8px 15px; margin-right: 10px;background-color:cyan;border-radius:8px;border:1px solid black">新增專案</button>
            <button onclick="document.getElementById('project-list-modal').style.display = 'none';" style="padding: 8px 15px; margin-right: 10px;background-color:pink;border-radius:8px;border:1px solid black">Cancel</button>

            <hr style="margin: 15px 0;">
            <div id="all-projects-list" style="max-height: 350px; overflow-y: auto;">
                </div>
        </div>
    </div>

    <div   id="codeArea" style="display:none;">
        <button onclick="document.all.codeArea.style.display='none'; " title="close"  >❎</button>
            <input type="text" id="fname" value="default_file.json">
          <button onclick="document.all.codeArea.style.display=''; editor.innerHTML=document.getElementById('htmlPageCode').value;" title="export"  ><b>✅</b></button>
        <div id="pagelist"></div>
        <div id="Navi"></div>
      <textarea id="htmlPageCode" cols="150" rows="10" style="display:;border:1px dashed green" > </textarea>
         
        <textarea  id="temp"   ></textarea>
        <img id="coverpic" src="">
         
    </div>

<script>
        const diceElement = document.getElementById('dice');
        const resultElement = document.getElementById('rollResult');

        // Dot mapping: Index in the array corresponds to the roll number (1-6).
        // The value is an array of which dot IDs (1-9) should be visible (opacity: 1).
        // Note: Dots D2, D4, D6, D8 (Top/Bottom/Left/Right centers) are only used for the 6 face.
        const dotVisibilityMap = {
            1: [5], // Center only
            2: [1, 9], // Top-Left, Bottom-Right
            3: [1, 5, 9], // Top-Left, Center, Bottom-Right
            4: [1, 3, 7, 9], // All corners
            5: [1, 3, 5, 7, 9], // All corners and center
            6: [1, 3, 4, 6, 7, 9] // All corners and side centers
        };

        /**
         * Hides all dots on the dice face.
         */
        function hideAllDots() {
            for (let i = 1; i <= 9; i++) {
                const dot = document.getElementById(`dot-${i}`);
                // Use opacity to hide/show, making it smooth
                if (dot) dot.style.opacity = '0';
            }
        }

        /**
         * Renders the dice face based on the roll result.
         * @param {number} roll The number rolled (1-6).
         */
        function renderDiceFace(roll) {
            const visibleDots = dotVisibilityMap[roll] || [];
            
            // 1. Hide all dots first
            hideAllDots();

            // 2. Show only the necessary dots for the current roll
            visibleDots.forEach(dotId => {
                const dot = document.getElementById(`dot-${dotId}`);
                if (dot) dot.style.opacity = '1';
            });
        }

        /**
         * The main function triggered by touchstart or click.
         * @param {Event} event The touch or click event.
         */
        window.rollDice = function(event) {
            // Optional: Preventing default behavior on touchstart is handled by touch-action: none in CSS.
            // If you needed specific touch handling (like preventing scrolling only during a drag),
            // you might put event.preventDefault() here, but for a simple tap, it's often unnecessary
            // and can cause the click translation issue you saw before.
            
            // 1. Generate a random number between 1 and 6
            const newRoll = Math.floor(Math.random() * 6) + 1;

            // 2. Update the visual face
            renderDiceFace(newRoll);

            // 3. Update the result text
            resultElement.textContent = `Roll: ${newRoll}`;

            console.log(`Dice rolled: ${newRoll}`);

            // If the event is touchstart, we want to allow the subsequent click event
            // to fire, but since we're handling the action here, it's safe.
            // However, if you add more complex touch logic later, you might need to
            // re-evaluate where you use event.preventDefault().
        }

        // Initialize the dice to show '1' when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            renderDiceFace(1);
        });
</script>


<textarea id="diceSample" style="display:none">
<div class="draggable-image" style="z-index:50">
    <div id="dice" 
         class="dice rounded-xl"
         onclick="rollDice(event)"
         ontouchstart="rollDice(event)">

        <!-- 9 Dot Elements in a 3x3 Grid -->
        <div class="dot d1" id="dot-1"></div>
        <div class="dot d2" id="dot-2"></div>
        <div class="dot d3" id="dot-3"></div>
        <div class="dot d4" id="dot-4"></div>
        <div class="dot d5" id="dot-5"></div>
        <div class="dot d6" id="dot-6"></div>
        <div class="dot d7" id="dot-7"></div>
        <div class="dot d8" id="dot-8"></div>
        <div class="dot d9" id="dot-9"></div>
    </div>
<div class="resizer" ></div>
</div>
</textarea>



  <div id="toolbar"  style="position:;z-index:90;left:20px;top:88vh;justify-content: center;align-items: center;" class="flex flex-wrap items-center gap-2 p-3 bg-gray-50 rounded-lg border border-gray-200 mb-4">
 



  <!-- Teacher Backstage Editing-->


    
            <button  title="切換編輯工具列" onclick="window.DesignMode=!window.DesignMode;this.textContent=(window.DesignMode)?'📝設計模式':'✔️白板模式';window.toggleSpeak();document.getElementById('toolbar').style.position=(document.getElementById('toolbar').style.position='absolute')?'':'absolute';"   style="display:;font-size:15px" class=" gap-2 p-2 rounded-lg border border-gray-200 ">✔️白板模式</button>

 <button  title="切換編輯工具列" onclick="window.checkMode=!window.checkMode;this.textContent=(window.checkMode)?'配對模式':'滑鼠模式';" >[滑鼠模式]</button>


           <!-- Drawing Controls -->
 


<span  id="DWpentool" onclick="" style="position:relative;width:40px;font-size:20px" class="mx-2 text-gray-400 rounded-lg hover:bg-purple-600  shadow-md">✒️
            <span  id="DWpentool_menu" style="display:none;position:absolute;top:-10px;left:250px;z-index:30;width:900px;background:white;border-radius:16px;border:2px solid gray;padding:4px"    > 




     <div class="flex items-center space-x-2">
                    <button id="stopDrawingBtn" onclick="window.setDrawingMode('none');" class="p-2 rounded-full bg-gray-100 border transition hover:bg-gray-200" title="Eraser Tool">
	        🖱️
                    </button>
                    <button id="pen-tool" class="p-2 rounded-full bg-gray-100 border transition hover:bg-gray-200" title="Pen Tool">
                        <svg class="w-6 h-6 text-gray-800" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z"></path></svg>
                    </button>

                    <button id="eraser-tool" class="p-2 rounded-full bg-gray-100 border transition hover:bg-gray-200" title="Eraser Tool">
                        🧽
                    </button>

                    <label for="pen-color" class="flex items-center ring-2 ring-gray-300 rounded-full transition duration-200">
                        <input type="color" id="pen-color" value="#FF0000" class="w-8 h-8 rounded-full border-none p-0 cursor-pointer">
                    </label>
             <span onclick="window.setPenColor('black')" style="color:black;padding:1px;font-size:30px">■</span><span onclick="window.setPenColor('blue')" style="color:blue;padding:1px;font-size:30px">■</span><span onclick="window.setPenColor('green')" style="color:green;padding:1px;font-size:30px">■</span><span onclick="window.setPenColor('red')" style="color:green;padding:1px;font-size:30px">■</span>
                
                <!-- Size and Action Buttons -->
                <div class="flex items-center space-x-3">
                    <label for="pen-size" class="text-gray-600 font-medium whitespace-nowrap">Size: <span id="size-display" class="font-bold text-green-600">5</span>px</label>
                    <input type="range" id="pen-size" min="1" max="50" value="5" class="w-24 md:w-32 cursor-pointer appearance-none bg-gray-200 rounded-lg h-2 [&::-webkit-slider-thumb]:appearance-none [&::-webkit-slider-thumb]:w-4 [&::-webkit-slider-thumb]:h-4 [&::-webkit-slider-thumb]:bg-green-600 [&::-webkit-slider-thumb]:rounded-full">
                </div>
                
                <div class="flex items-center space-x-3">
                    <button id="clear-canvas-button" class="bg-blue-200 hover:bg-red-600 text-black font-semibold py-2 px-3 rounded-lg text-xl transition shadow">
                        🗑
                    </button>
	</div >
</div > 





         </span><!--pentool_menu-->
</span>  <!--pentool-->






            <!-- Style Controls - Border Radius -->
            <div id="styleControls" style="display:none;" class="flex flex-wrap items-center gap-2 p-3 bg-gray-50 rounded-lg border border-gray-200 mb-4">
 <!-- 文字編輯區 -->
              </div>



<div style="display:inline;width:45px;height:45px;font-size:20px;z-index:50;border:2px dotted gray;padding:0px;line-height: 80%;"  >
  <span onclick="window.addNewTextElement('sticker','yellow');"  style="color:yellow; display:inline;margin:2px" >■</span>
 <span onclick="window.addNewTextElement('sticker','pink');"   style="color:pink; display:inline;margin:2px; " >■</span>
  <span onclick="window.addNewTextElement('sticker','cyan');"  style="color:cyan; display:inline;margin:2px; " >■</span>
 <span onclick="window.addNewTextElement('sticker','lightgreen');"   style="color:lightgreen; display:inline;margin:2px; " >■</span>
</div>  

 

 <div style="display:inline;color:gray;font-size:30px" onclick="window.goToPreviousPage();"  ontouchstart="window.goToPreviousPage();">⬅️</div>
 <div style="display:inline;color:gray;font-size:30px" onclick="window.goToNextPage();"  ontouchstart="window.goToNextPage();">➡️</div>   

<div id="quizToolBar" style="border-left: 1px solid #ccc; display:inline;display:" >
 <button onclick="window.toggleGameTheme('quiz');">❓</button>
<button id="toggleQuizBtn" onclick="window.toggleGameTheme('slasher');window.QS_launchGame(document.getElementById('quizArea'),'slasher');window.QS_parseAndLoadQuiz(document.getElementById('quizArea'),'slasher');" title="切水果" >🎈</button>
<button id="startGameButton" title="雙打測驗" onclick="window.toggleGameTheme('dual');">🤼</button>
</div>
  <button onclick="window.FullScreen();"  title="全螢幕"  ><font size="6" title=="閃示卡" > 💻 </font></button>
  <button onclick="window.PicNav()">	<font size="6" title=="閃示卡" >🖼️</font></button>
       <button onclick="window.textSlider()"><font size="6" title=="動畫" >📽️</font></button>
        <div style="border-left: 1px solid #ccc; margin: 0 5px; padding-left: 10px;">
         <button onclick="document.getElementById('teamBoard').style.display=(document.getElementById('teamBoard').style.display=='none')?'':'none';" title="showScoreBoard"  >👨‍👨‍👧‍👧</button>
         </div>

<button onclick="window.pickNumber();" style="font-size:20px;border-radius:6px;padding:2px"  id="pickBtn"> 🙋‍♂️</button>


<button onclick="document.getElementById('picker-wrapper').classList.remove('hidden');" style="font-size:20px;border-radius:6px;padding:2px"  id="rstBtn"> 🔢</button>
<button onclick="window.insertDice();" style="font-size:25px" > 🎲</button>
<button onclick="window.restore();"  title=="還原頁面" style="font-size:25px" >♻</button>

<button onclick="window.dartMode();"  id="dartModeBtn" title="遊戲模式" style="font-size:20px;background-color:cyan;border-radius:8px;padding:2px"  >🎯on</button>


<div class="px-2 py-1 bg-blue-200 text-white font-semibold rounded-lg hover:bg-red-200 transition duration-150 shadow-md">
<button   onclick="window.stopSpeaking();" title="stop speaking">🔳</button>

<span>
<button" id="speakBtn" style="font-size:20px"  onclick="window.toggleSpeak()" >🔇</button>
</span>
</div>


<div id="voiceGameControls" class="flex flex-col items-center gap-1 p-1 font-xs bg-yellow-50 rounded-lg shadow-inner"  >

    <button id="voiceButton" onclick="window.startRandomVoiceGame();document.getElementById('speechResult').style.display='';" 
            title="語音辨識Start Random Voice Recognition Game" 
            class="px-2 py-1 bg-yellow-500 text-white font-semibold rounded-lg hover:bg-yellow-600 transition duration-150 shadow-md">
        🎙️  ▶️
    </button>
    <div id="OLDspeechResult" class="text-sm font-medium text-gray-500"     ontouchstart="this.style.display='none';" onclick="this.style.display='none';"   style="position:absolute;z-index:50;top:40px;left:100px;width:90%;height:80px;background:white;border-radius:16px;border:2px gray solid;padding:10px;font-size:30px;opacity:0.9;display:none">
        Click to start recognizing words by item ID.
    </div>

</div>

<div id="gameModeControls" class="flex flex-wrap items-center gap-2">

    <button id="toggleGameModeBtn" onclick="window.toggleGameMode();speakText('get'+window.randomItem());" 
            title="Start Continuous Background Animation" 
            class="px-2 py-1 bg-green-500 text-white font-semibold rounded-lg hover:bg-green-600 transition duration-150 shadow-md">
        ▶️ 🎮
    </button>
    <button onclick="window.animateAllRandomly(parseFloat(document.getElementById('goToTime').value))" 
            title="Animate all items to random locations" 
            class="px-2 py-1 bg-purple-500 text-white font-semibold rounded-lg hover:bg-purple-600 transition duration-150 shadow-md">
       💢散開
    </button>
</div>



<span class="mx-2 text-gray-400" onclick="document.getElementById('movementControls').style.display=(document.getElementById('movementControls').style.display=='none')?'':'none';" >🕹️</span>

<div id="movementControls"  style="position:absolute;z-index:30;width:90%;height:30px;top:80vh;left:10px;display:none;background:white;border-radius:16px" >
<span  title="關閉" onclick="document.getElementById('movementControls').style.display='none';"  style="color:gray;cursor:hand;font-size:26px;font-weight:bolder;margin-left:10px;font-size:30px;" >🗷</span>


    <button onclick="window.moveSteps(-100)" title="Move backward 10 Steps" class="px-4 py-2 bg-pink-500 text-white font-semibold rounded-lg hover:bg-pink-600 transition duration-150 shadow-md">🚶‍⬅️</button>
    <button onclick="window.moveSteps(100)" title="Move Forward 10 Steps" class="px-4 py-2 bg-pink-500 text-white font-semibold rounded-lg hover:bg-pink-600 transition duration-150 shadow-md">🕺➡️</button>    
    <button onclick="window.turn(-15)" title="Turn Left 15 Degrees" class="px-3 py-2 text-gray-700 bg-white border border-gray-300 rounded-lg hover:bg-gray-100">↺ 15°</button>
    <button onclick="window.turn(15)" title="Turn Right 15 Degrees" class="px-3 py-2 text-gray-700 bg-white border border-gray-300 rounded-lg hover:bg-gray-100">↻ 15°</button>
    
    <button onclick="window.pointInDirection(0)" title="Point Up" class="px-3 py-2 text-gray-700 bg-white border border-gray-300 rounded-lg hover:bg-gray-100">🕛</button>
      <button onclick="window.pointInDirection(90)" title="Point Right/Forward" class="px-3 py-2 text-gray-700 bg-white border border-gray-300 rounded-lg hover:bg-gray-100">🕒</button>


<span class="mx-2 text-gray-400">|</span>


 
    
    <button onclick="window.goTo(document.getElementById('goToTarget').value);" title="Go To Custom Position" class="px-4 py-2 bg-indigo-500 text-white font-semibold rounded-lg hover:bg-indigo-600 transition duration-150 shadow-md">Go To</button>
    <button onclick="window.goTo('center')" title="Go To Center" class="px-3 py-2 bg-indigo-500 text-white font-semibold rounded-lg hover:bg-indigo-600 transition duration-150 shadow-md">Center</button>
 
<span class="mx-2 text-gray-400">|</span>



<span class="mx-2 text-gray-400">🎮</span>
 java go to
    <input type="text" id="goToTarget" placeholder="X,Y or Element ID" class="w-32 p-2 border border-gray-300 rounded-lg text-sm">
    
    <input type="number" id="goToTime" value="1" min="0.1" step="0.1" title="Time (seconds)" class="w-16 p-2 border border-gray-300 rounded-lg text-sm text-center">
    
    <button onclick="window.glideTo(document.getElementById('goToTarget').value, parseFloat(document.getElementById('goToTime').value))" 
            title="Animate Go To Custom Position" 
            class="px-4 py-2 bg-indigo-500 text-white font-semibold rounded-lg hover:bg-indigo-600 transition duration-150 shadow-md">
        Slide To
    </button>
    
    <button onclick="window.glideTo('center', parseFloat(document.getElementById('goToTime').value))" 
            title="Animate Go To Center" 
            class="px-3 py-2 bg-indigo-500 text-white font-semibold rounded-lg hover:bg-indigo-600 transition duration-150 shadow-md">
        Center
    </button>
 


</div><!-- end movementControl menu-->












            <!-- Final Action -->
           

        </div>
</div>

 












    <script type="module">
        // Import Firebase v12 SDKs. Including getDocs, collection, and deleteDoc.
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.3/firebase-app.js";
        import { getFirestore, doc, setDoc,getDoc, onSnapshot, collection, getDocs, deleteDoc } from "https://www.gstatic.com/firebasejs/10.12.3/firebase-firestore.js";
//import { getFirestore, collection, getDocs, setDoc, deleteDoc } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore.js";
        // --- 1. FIREBASE CONFIGURATION ---
        const firebaseConfig = {
            apiKey: "AIzaSyA-psoCWI_u2iYoLXznb6kH_g3KTw00Qow",
            authDomain: "myebook-183ee.firebaseapp.com",
            projectId: "myebook-183ee",
            storageBucket: "myebook-183ee.firebasestorage.app",
            messagingSenderId: "531804725153",
            appId: "1:531804725153:web:469ed0e5ded02f72fcb5e0",
        };

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        
        // Firestore Constants
        const PROJECTS_COLLECTION = 'editor_projects'; 
        
        // --- 2. GLOBAL STATE ---
        const editor = document.getElementById('editor');
        const storageKey = 'canvasEditorProject'; 
        
        // Multi-Project Variable (DEFAULT ID)
        let currentProjectDocumentId = 'classroom_master_file'; 
        //let currentProjectDocumentId = 'NewProjcet';         
        // Core Project Data
        let projectData = []; 
        let currentPageId = null;
        
        // Existing Global Variables from your code
        let DesignMode = false;
        let gameTarget = "";
        let gameMode = false;
        let score = 0;
        let quizCount = 0;
        let checkMode = false; 
        let gameTimerInterval = null;
        const GAME_DURATION_SECONDS = 60;
        let recognition = null; 
        let requiredWord = '';
        let counter = 0; 
        let activeItem = null; // CRITICAL: This needs to be set by your drag/drop handlers
        let oldX = 0, oldY = 0; // Assuming these are used by drag/drop
        let speaking=true;
       // --- Globals ---
         const editToggleBtn = document.getElementById('editToggleBtn');
        const lockToggleBtn = document.getElementById('lockToggleBtn');

	let isPanModeActive = false;
	 let acitvePage=null;
            let  myinterval =null;	 
           let isFullScreen =false;
	// Get the element that acts as the scroll container (usually the body)
	const scrollContainer = document.body;


// --- NEW: Gesture State Variables ---
        let touchStartX = 0;
        let touchStartY = 0;
        //let isSwiping = false;
        const SWIPE_THRESHOLD = 80; // 判斷為有效滑動的最小水平距離 (pixels)
 // --- End of Gesture State Variables ---



// ADD THESE CRITICAL DRAG/RESIZE VARIABLES:
let isDragging = false; 
let isResizing = false;
let isSwiping = false; // Used in handleStart
let startX = 0;
let startY = 0;
let startLeft = 0;
let startTop = 0;
let startWidth = 0;
let startHeight = 0;
const lastClickPos = { x: 100, y: 100 }; // Used in handleStart

// ====================================================================
// GLOBAL/MODULE VARIABLES (PLACE AT THE TOP OF YOUR SCRIPT)
// ====================================================================

// --- Editor State ---
let initialX, initialY, initialWidth, initialHeight;

let isInitialLoad = true; // CRITICAL for Firebase stability

// --- Drawing & Canvas State ---

 let context = null;
let fillColorInput = null;
let penColorInput = null;
let lineWidthInput = null;
let currentDrawMode = 'stroke'; // 'stroke', 'fill', or 'stroke-fill'
let currentTool = null; // 'pen', 'line', 'rect', 'circle', 'arrow', 'eraser'
let isDrawing = false;
let drawStartX, drawStartY;

// Temporary canvas for drawing shapes (avoids flashing)
const tempCanvas = document.createElement('canvas');
const  tempCtx = tempCanvas.getContext('2d');
tempCanvas.id = 'tempCanvas';

let gameTheme=0;
        // --- 3. FIREBASE/PROJECT DATA MANAGEMENT ---
        
        /** Real-time Listener: Loads initial data and keeps projectData synced. */
 // Ensure this variable is defined outside the function, at the module scope
 
 isInitialLoad = true; // Define this globally or in the module scope

function startRealtimeProjectListener() {
    document.getElementById('currentProjectDisplay').textContent = currentProjectDocumentId;

    const projectRef = doc(db, PROJECTS_COLLECTION, currentProjectDocumentId);
    
    const projectListenerUnsubscribe = onSnapshot(projectRef, (docSnapshot) => {
        
        // --- 1. HANDLE DATA RECEIVED (SUCCESS PATH) ---
        if (docSnapshot.exists() && docSnapshot.data().pages) {
            const serverData = docSnapshot.data();
            const newProjectData = serverData.pages;

            // Protection: If the data structure is corrupt, stop here but keep the old data.
            if (!Array.isArray(newProjectData)) {
                console.warn("Server data structure is corrupt (pages is not an Array). Ignoring update.");
                return; 
            }
            
            projectData = newProjectData;
            
            // Logic to handle an empty project data array
            if (projectData.length === 0) {
                 // CRITICAL: Only initialize a blank project if it's the first time loading.
                 // This assumes a user wouldn't idle for 5 minutes and THEN load an empty project.
                 if (isInitialLoad) { 
                     initializeBlankProject();
                 } else {
                     // If it becomes empty later, assume the user cleared it, 
                     // but DON'T initialize a new one automatically during a sync.
                     // The user needs to manually add the first page.
                     console.log("Project list is empty after initial load. Awaiting user action.");
                 }
            }
            
            // Logic to switch page if the current one was deleted (always safe)
            const currentExists = projectData.some(p => p.id === currentPageId);
            if (!currentExists && projectData.length > 0) {
                currentPageId = projectData[0].id;
            }
            
            loadPageData(currentPageId);
            renderPageList();
            
            // Set flag to false after first successful data fetch
            isInitialLoad = false; 
            console.log("Project data synced from Firestore.");

        // --- 2. HANDLE DOCUMENT NOT FOUND (ERROR PATH) ---
        } else if (!docSnapshot.exists()) {
            
            if (isInitialLoad) {
                console.log(`Document '${currentProjectDocumentId}' not found. Initializing blank project.`);
                initializeBlankProject();
                isInitialLoad = false;
            } else {
                 // CRITICAL: The document disappeared AFTER a successful load.
                 // This is the common sign-out/session-expiry issue. DO NOT clear data.
                 console.warn("Document disappeared after initial load. Stopping action to protect local state.");
            }
        }
    }, (error) => {
        // --- 3. HANDLE LISTENER FAILURE (CONNECTION ERROR PATH) ---
        console.error("Firestore listener error (Connection Loss): ", error);
        // This runs on actual connection failure. Using local storage as backup is correct here.
        loadProjectFromLocalStorage(); 
    });
}













         window.exportProject=function() {
            saveCurrentPageData(); // Ensure the current page is saved before export
            const jsonContent = JSON.stringify(projectData, null, 2);
            const blob = new Blob([jsonContent], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            //a.download = 'editor-project.json';
            a.download = document.getElementById('fname').value;
            a.click();
            URL.revokeObjectURL(url);
        }

        window.importProject=function() {
            document.getElementById('importFile').click();
        }

       window.handleFileImport=function(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importedData = JSON.parse(e.target.result);
                    if (typeof importedData !== 'object' || importedData === null) {
                        throw new Error("Invalid format");
                    }
                    projectData = importedData;

  
                    currentPageId = Object.keys(projectData)[0] || null;
                    saveProject(); // Save the newly imported project to localStorage
                    renderPageList();
                    if (currentPageId) {
                        loadPageData(currentPageId);
                    }
                } catch (error) {
                    alert("Error: Could not import file. Please ensure it's a valid project JSON.");
                    console.error("Import failed:", error);
                }
            };
            
            reader.readAsText(file);
            event.target.value = ''; // Reset file input
        }














        /** Saves the current projectData array to Firestore. */
        window.saveProject = async function() {
            saveCurrentPageData();
            
            if (projectData.length === 0) return;

            const dataToSave = {
                pages: projectData,
            };

            try {
                const projectRef = doc(db, PROJECTS_COLLECTION, currentProjectDocumentId);
                await setDoc(projectRef, dataToSave);
                console.log("Project successfully saved to Firestore!");
	showModal(storageKey + '-' + currentProjectDocumentId,'已儲存:');
	//alert('儲存完成');
                localStorage.setItem(storageKey + '-' + currentProjectDocumentId, JSON.stringify(projectData)); 

            } catch (error) {
                console.error("Error writing document to Firestore: ", error);
	showModal('寫入錯誤','error');
            }
        }
        
        // --- Multi-Project Listing & Management Functions ---

        /** Fetches all document IDs and renders the list in the modal. */
        window.OLDrenderAllProjectsList = async function() {
            const listContainer = document.getElementById('all-projects-list');
            listContainer.innerHTML = 'Loading saved projects...';
            
            // Pre-fill the input field with the current ID
            document.getElementById('new-project-id-input').value = currentProjectDocumentId;

            try {
                const querySnapshot = await getDocs(collection(db, PROJECTS_COLLECTION));
                
                let html = '<ul style="list-style:none; padding:0;">';
                
                if (querySnapshot.empty) {
                    html += '<li style="padding: 10px; color: gray;">No saved projects found.</li>';
                } else {
                    querySnapshot.forEach((doc) => {
                        const projectId = doc.id;
                        const isActive = projectId === currentProjectDocumentId;
                        const status = isActive ? ' (ACTIVE)' : '';
                        
                        html += `<li style="display: flex; justify-content: space-between; align-items: center; padding: 10px; margin-bottom: 5px; border: 1px solid #ddd; border-radius: 4px; background: ${isActive ? '#e6f3ff' : '#fff'};">
                                    <span 
                                        onclick="window.switchProjectAndCloseList('${projectId}')" 
                                        style="cursor:pointer; flex-grow: 1; color: ${isActive ? '#007bff' : '#333'}; font-weight: ${isActive ? 'bold' : 'normal'};"
                                    >
                                        ${projectId}${status}
                                    </span>
                                    
                                    <button 
                                        onclick="window.deleteProject('${projectId}')" 
                                        style="margin-left: 10px; background: #f87171; color: white; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer;"
                                        title="Permanently delete this project"
                                    >
                                        🗑️ Delete
                                    </button>
                                </li>`;
                    });
                }
                html += '</ul>';
                
                listContainer.innerHTML = html;
                
                // Show the modal
                document.getElementById('project-list-modal').style.display = 'block';

            } catch (error) {
                listContainer.innerHTML = 'Error loading projects: Check console for details.';
                console.error("Error fetching project list:", error);
            }
        }



// --- Multi-Project Listing & Management Functions ---

/** Fetches all document IDs and renders the list in the modal, including management buttons. */
window.renderAllProjectsList = async function() {
    const listContainer = document.getElementById('all-projects-list');
    listContainer.innerHTML = 'Loading saved projects...';
    
    // Pre-fill the input field with the current ID
    document.getElementById('new-project-id-input').value = currentProjectDocumentId;

    try {
        const querySnapshot = await getDocs(collection(db, PROJECTS_COLLECTION));
        
        let html = '<ul style="list-style:none; padding:0;">';
        
        if (querySnapshot.empty) {
            html += '<li style="padding: 10px; color: gray;">No saved projects found.</li>';
        } else {
            querySnapshot.forEach((doc) => {
                const projectId = doc.id;
                const isActive = projectId === currentProjectDocumentId;
                const status = isActive ? ' (ACTIVE)' : '';
                
                html += `<li style="display: flex; justify-content: space-between; align-items: center; padding: 10px; margin-bottom: 5px; border: 1px solid #ddd; border-radius: 4px; background: ${isActive ? '#e6f3ff' : '#fff'};">
                            <span 
                                onclick="window.switchProjectAndCloseList('${projectId}')" 
                                style="cursor:pointer; flex-grow: 1; color: ${isActive ? '#007bff' : '#333'}; font-weight: ${isActive ? 'bold' : 'normal'};"
                            >
                                ${projectId}${status}
                            </span>
                            
                            <button 
                                onclick="window.renameProject('${projectId}')" 
                                style="margin-left: 5px; background: #ffc107; color: #333; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer; font-weight: bold;"
                                title="Rename this project"
                            >
                                ✏️ Rename
                            </button>
                            
                            <button 
                                onclick="window.duplicateProject('${projectId}')" 
                                style="margin-left: 5px; background: #17a2b8; color: white; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer; font-weight: bold;"
                                title="Create a copy of this project"
                            >
                                ➕ Duplicate
                            </button>

                            <button 
                                onclick="window.deleteProject('${projectId}')" 
                                style="margin-left: 5px; background: #f87171; color: white; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer; font-weight: bold;"
                                title="Permanently delete this project"
                            >
                                🗑️ Delete
                            </button>
                        </li>`;
            });
        }
        html += '</ul>';
        
        listContainer.innerHTML = html;
        
        // Show the modal
        document.getElementById('project-list-modal').style.display = 'block';

    } catch (error) {
        listContainer.innerHTML = 'Error loading projects: Check console for details.';
        console.error("Error fetching project list:", error);
    }
}


/** Renames an existing project document by duplicating it to a new ID and deleting the old one. */
window.renameProject = async function(oldProjectId) {
    if (!oldProjectId) return;

    // 1. Get New Project ID from User
    const newProjectId = prompt(`Rename Project "${oldProjectId}" to:`, oldProjectId + '_renamed');
    
    if (!newProjectId || newProjectId === oldProjectId) {
        if (newProjectId) alert("Rename canceled: The new name must be different from the old name.");
        return; // User cancelled or name is the same
    }

    try {
        // --- STEP 1: READ data from old document ---
        const oldProjectRef = doc(db, PROJECTS_COLLECTION, oldProjectId);
        const oldProjectSnapshot = await getDoc(oldProjectRef); // Assuming getDoc is available from your setup
        
        if (!oldProjectSnapshot.exists()) {
            alert(`Error: Project "${oldProjectId}" not found in Firestore.`);
            return;
        }

        const projectDataToMove = oldProjectSnapshot.data();

        // --- STEP 2: WRITE data to new document (the rename) ---
        const newProjectRef = doc(db, PROJECTS_COLLECTION, newProjectId);
        await setDoc(newProjectRef, projectDataToMove);
        console.log(`Project successfully duplicated to new name: "${newProjectId}"`);

        // --- STEP 3: DELETE old document ---
        await deleteDoc(oldProjectRef);
        console.log(`Original project "${oldProjectId}" successfully deleted.`);

        // --- STEP 4: UPDATE local state if necessary ---
        if (oldProjectId === currentProjectDocumentId) {
            // If the active project was renamed, switch to the new ID
            window.switchProject(newProjectId);
        }
        
        // --- STEP 5: REFRESH the list ---
        window.renderAllProjectsList();
        
        showModal('專案已更名', `Project **${oldProjectId}** successfully renamed to **${newProjectId}**.`);

    } catch (error) {
        alert("Error renaming project. See console for details.");
        console.error("Error renaming document:", error);
    }
};

/** Duplicates an existing project document to a new ID. */
window.duplicateProject = async function(originalProjectId) {
    if (!originalProjectId) return;

    // 1. Get New Project ID from User
    const newProjectId = prompt(`Duplicate Project "${originalProjectId}" as:`, originalProjectId + '_copy');

    if (!newProjectId || newProjectId === originalProjectId) {
        if (newProjectId) alert("Duplication canceled: The new name must be different from the original name.");
        return; // User cancelled or name is the same
    }

    try {
        // --- STEP 1: READ data from original document ---
        const originalProjectRef = doc(db, PROJECTS_COLLECTION, originalProjectId);
        const originalProjectSnapshot = await getDoc(originalProjectRef); // Assuming getDoc is available
        
        if (!originalProjectSnapshot.exists()) {
            alert(`Error: Project "${originalProjectId}" not found in Firestore.`);
            return;
        }

        const projectDataToCopy = originalProjectSnapshot.data();

        // --- STEP 2: WRITE data to new document ---
        const newProjectRef = doc(db, PROJECTS_COLLECTION, newProjectId);
        await setDoc(newProjectRef, projectDataToCopy);
        console.log(`Project successfully duplicated: "${newProjectId}"`);

        // --- STEP 3: REFRESH the list ---
        window.renderAllProjectsList();
        
        showModal('專案已複製', `Project **${originalProjectId}** successfully duplicated as **${newProjectId}**.`);

    } catch (error) {
        alert("Error duplicating project. See console for details.");
        console.error("Error duplicating document:", error);
    }
};









        /** Executes the project switch and closes the list modal. */
        window.switchProjectAndCloseList = function(rawNewProjectId) {
            const newProjectId = rawNewProjectId ? rawNewProjectId.trim().replace(/[^a-zA-Z0-9_-]/g, '_') : null;

            if (newProjectId && newProjectId !== currentProjectDocumentId) {
                window.switchProject(newProjectId);
            } else if (newProjectId === currentProjectDocumentId) {
                // If the user clicked the active project, just close the modal.
            }
            document.getElementById('project-list-modal').style.display = 'none';
        }

        /** Switches the project, saves old data, and loads new data. */
        window.switchProject = function(newProjectId) {
            if (!newProjectId) return;
            
            // 1. Save the project we are leaving
            window.saveProject(); 

            // 2. Change the global ID
            currentProjectDocumentId = newProjectId;
            
            // 3. Reset internal state and re-load
            projectData = []; 
            currentPageId = null; 
            renderPageList(); 
            startRealtimeProjectListener(); 
            
            console.log(`Switched to project: ${newProjectId}`);
        }
        
        /** Deletes a specific project document from Firestore. (NEW) */
        window.deleteProject = async function(projectIdToDelete) {
            if (!projectIdToDelete) return;

            const confirmation = confirm(`Are you absolutely sure you want to delete the project: "${projectIdToDelete}"? This action cannot be undone and will permanently free up storage space.`);

            if (confirmation) {
                try {
                    const projectRef = doc(db, PROJECTS_COLLECTION, projectIdToDelete);
                    await deleteDoc(projectRef);
                    
                    console.log(`Project "${projectIdToDelete}" successfully deleted from Firestore.`);
                    
                    // 1. If the active project was deleted, switch to the default project
                    if (projectIdToDelete === currentProjectDocumentId) {
                        // Switch to a known default to prevent errors
                        window.switchProject('classroom_master_file'); 
                    }
                    
                    // 2. Refresh the project list in the modal
                    window.renderAllProjectsList(); 

                } catch (error) {
                    alert("Error deleting project. See console for details.");
                    console.error("Error deleting document: ", error);
                }
            }
        }
        








        // --- Page Management Functions (Existing) ---

        window.loadProjectFromLocalStorage=function() {
             const savedProject = localStorage.getItem(storageKey + '-' + currentProjectDocumentId);
             if (savedProject) {
                 projectData = JSON.parse(savedProject);
                 currentPageId = projectData[0].id;
                 loadPageData(currentPageId);
                 renderPageList();
             } else {
                 initializeBlankProject();
             }
        }

        function initializeBlankProject() {
             projectData = [{
                 id: 'page-1',
                 name: 'Home Page',
                 html: `<div style="text-align: center; padding: 20px;" class="floating-div"><h2>TOPIC  ${currentProjectDocumentId}!</h2><p>Let's learn.</p></div>`,
                 drawingData: null
             }];
             currentPageId = 'page-1';
             loadPageData(currentPageId);
             renderPageList();
              window.saveProject(); 
        }

// 💡 NEW Recommended approach: Save the blank project only if the document truly didn't exist
// This should be done only once:
async function ensureProjectExists() {
    const projectRef = doc(db, PROJECTS_COLLECTION, currentProjectDocumentId);
    const docSnapshot = await getDoc(projectRef); // You need to import getDoc for this

    if (!docSnapshot.exists()) {
        initializeBlankProject();
        // Now, save it immediately once:
        window.saveProject(); 
    }
    // Now start the listener AFTER you've ensured the doc exists
    startRealtimeProjectListener(); 
}


function renderPageList() {
    // CRITICAL: Use the module's existing projectData variable
    const pages = projectData; 
    const pageListElement = document.getElementById('page-list'); 
    
    // Check for element existence and data integrity
    if (!pageListElement || !Array.isArray(pages) || pages.length === 0) {
        if(pageListElement) pageListElement.innerHTML = ''; // Clear if the element exists
        return;
    }

    pageListElement.innerHTML = ''; // Clear the existing list

    pages.forEach((page, index) => {
        const listItem = document.createElement('li');
        listItem.id = `list-item-${page.id}`;
        // Use an active class for styling
        if (page.id === currentPageId) {
            listItem.classList.add('active');
		acitvePage=page.id
        }
        
        // --- Page Name Span ---
        const nameSpan = document.createElement('span');
        nameSpan.textContent = page.name;
        nameSpan.style.cssText = 'cursor: pointer; flex-grow: 1;';
        nameSpan.onclick = () => window.switchPage(page.id);
        
        // --- Control Container ---
        const controlContainer = document.createElement('div');
        controlContainer.style.cssText = 'display: flex; gap: 5px;';

        // Up Button
        const upButton = document.createElement('button');
        upButton.textContent = '🔺';
        upButton.title = 'Move Up';
        upButton.onclick = (e) => { e.stopPropagation(); window.movePage(page.id, -1); };
        if (index === 0) upButton.disabled = true;

        // Down Button
        const downButton = document.createElement('button');
        downButton.textContent = '🔻';
        downButton.title = 'Move Down';
        downButton.onclick = (e) => { e.stopPropagation(); window.movePage(page.id, 1); };
        if (index === pages.length - 1) downButton.disabled = true;
        
        // Delete Button
        const deleteButton = document.createElement('button');
        deleteButton.textContent = '🗑️';
        deleteButton.title = '刪除 Delete Page';
        deleteButton.style.color = 'red';
        deleteButton.onclick = (e) => { e.stopPropagation(); window.deletePage(page.id); };


        // duplicate Button
        const duplicateButton = document.createElement('button');
        duplicateButton.textContent = '🗊';
        duplicateButton.title = '再製 duplicate Page';
        duplicateButton.style.color = 'blue';
        duplicateButton.onclick = (e) => { e.stopPropagation(); window.duplicatePage(page.id); };




        // Rename Button
        const RnButton = document.createElement('button');
        RnButton.textContent = 'R';
        RnButton.title = '更名 Rename Page';
        RnButton.style.color = 'green';
        //RnButton.onclick = (e) => { e.stopPropagation(); window.renamePage(page.id,prompt('輸入新名稱', page.name)); };
RnButton.onclick = (e) => { 
    e.stopPropagation(); 
    // Execute the prompt when the button is clicked!
    const newName = prompt('輸入新名稱', page.name); 
    if (newName !== null) { // Check if the user didn't cancel
        window.renamePage(page.id, newName); 
    }
};


        // --- Assemble and Append ---
        //controlContainer.append(upButton, downButton, deleteButton);
        controlContainer.append(upButton, downButton, deleteButton, RnButton, duplicateButton);
        listItem.append(nameSpan, controlContainer);
        
        listItem.style.cssText = 'display: flex; justify-content: space-between; align-items: center; padding: 5px;';
        
            pageListElement.appendChild(listItem);
    });
}







        function getCurrentPage() {
            return projectData.find(p => p.id === currentPageId);
        }

        window.switchPage = function(pageId) {
            if (pageId === currentPageId) return;

            saveCurrentPageData(); 
            currentPageId = pageId;
            loadPageData(pageId);
            renderPageList();
        }

        window.createNewPage = function() {
            const pageName = prompt("Enter new page name:", "New Page");
            if (!pageName) return;

            const newPageId = `page-${Date.now()}`;
            const newPage = {
                id: newPageId,
                name: pageName,
                html: `<div style="text-align: center; padding: 20px;" class="floating-div"><h1>${pageName}</h1><p>Let's learn!</p></div><div id="draggable-image" style="width:200px;height:200px;background-image(url('https://classroomclipart.com/image/content7/60315/thumb.gif');background-size:contain;z-index:10" ></div> `,
                drawingData: null
            };

            saveCurrentPageData(); 
            projectData.push(newPage); 
            
            switchPage(newPageId); 
            window.saveProject(); 
        }

        function saveCurrentPageData() {
            const page = getCurrentPage();
            if (!page) return;
// 2. Add the drawingCanvas if it's missing (it should be persistent)

            page.html = editor.innerHTML;
        }

function loadPageData(pageId) {
    const page = projectData.find(p => p.id === pageId);
    if (!page) return;
    
// 1. CLEAR THE EDITOR (This is correct for resetting page content)
    editor.innerHTML = page.html || '';
    
    // 2. CREATE, STYLE, APPEND, AND INITIALIZE CANVAS
    // We KNOW the canvas is gone because we just wiped editor.innerHTML.
    // So, we must create a new one every time.
    const canvasElement = document.createElement('canvas');
    canvasElement.id = 'drawingCanvas';

    // Set all necessary CSS properties
    canvasElement.style.position = 'absolute';
    canvasElement.style.top = '0';
    canvasElement.style.left = '0';
    canvasElement.style.width = '100%'; // Ensure it fills the editor area
    canvasElement.style.height = '100%'; 
    canvasElement.style.zIndex = '50';
    canvasElement.style.backgroundColor = 'transparent'; // Change to transparent after testing!
    
    // Add the element to the DOM
    editor.appendChild(canvasElement);
    
    // 3. Initialize drawing controls immediately with the valid object
    window.initDrawingCanvas(canvasElement);

    // 4. Initialize drag/resize elements for the HTML just loaded
    window.initElements();
}



        window.getPageIndex=function(pageId) {
            return projectData.findIndex(p => p.id === pageId);
        }
 

window.addPageAfterActive = function() {
            const pageName = prompt("Enter new page name:", "New Page");
            if (!pageName) return;

            const newPageId = `page-${Date.now()}`;
            const newPage = {
                id: newPageId,
                name: pageName,
                html: `<div style="text-align: center; padding: 20px;" class="floating-div"><h1>${pageName}</h1><p>Let's learn!</p></div><div id="draggable-image" style="width:200px;height:200px;background-image(url('https://classroomclipart.com/image/content7/60315/thumb.gif');background-size:contain;z-index:10" ></div> `,
                drawingData: null
            };

           // 1. Find the index of the active page
            const activeIndex = currentPageId ? getPageIndex(currentPageId) : -1;

            // 2. Insert the new page *after* the active one, or at the end if no active page
            if (activeIndex !== -1) {
                projectData.splice(activeIndex + 1, 0, newPage);
            } else {
                projectData.push(newPage);
            }

            // 3. Switch to the new page
            saveCurrentPageData(); // Save the page we are leaving (or the one before the insertion point)
            currentPageId = newPageId;
            loadPageData(newPageId); // Load the new blank page
            saveProject();
            renderPageList();
}

/** Duplicates a page and inserts the copy right after the original. */
window.duplicatePage = function(pageId) {
    // 1. Find the index of the page to duplicate
    const oldIndex = projectData.findIndex(p => p.id === pageId);

    if (oldIndex === -1) {
        console.error(`Page with ID ${pageId} not found.`);
        return;
    }

    // 2. Get the page data
    const pageToDuplicate = projectData[oldIndex];

    // 3. Create a deep copy of the page data.
    // We use JSON methods for a simple deep clone, assuming page data is safe to stringify.
    const newPage = JSON.parse(JSON.stringify(pageToDuplicate));

    // 4. Generate a new unique ID for the duplicated page
    // A simple method is to append ' Copy' or a timestamp, but here we use a simple counter/suffix.
    let newId = `${pageToDuplicate.id} Copy`;
    let suffix = 1;
    // Ensure the new ID is unique
    while (projectData.some(p => p.id === newId)) {
        newId = `${pageToDuplicate.id} Copy ${suffix++}`;
    }

    newPage.id = newId;

    // Optional: Reset any data that shouldn't be copied (e.g., last modified time)
    // newPage.lastModified = new Date().toISOString(); 

    // 5. Insert the new page right after the original page's index
    const newIndex = oldIndex + 1;
    projectData.splice(newIndex, 0, newPage);

    // 6. Re-render the page list and save the project to the database
    renderPageList();
    window.saveProject();

    console.log(`Duplicated page ${pageId} to ${newPage.id}`);
}


        

 
window.renamePage = function(pageId, newName) {
    // CRITICAL FIX: Use projectData
    const pageToRename = projectData.find(p => p.id === pageId);

    if (pageToRename) {
        pageToRename.name = newName.trim() || `Page ${pageId.split('-')[1]}`;
        renderPageList();
        window.saveProject(); 
    }
}

 
window.deletePage = function(pageId) {
    if (!confirm("Are you sure you want to delete this page?")) {
        return; 
    }
    
    // CRITICAL FIX: Use projectData instead of the undefined 'pages'
    projectData = projectData.filter(p => p.id !== pageId);

    // 2. Handle current page selection
    if (projectData.length === 0) {
        // Since all pages are gone, re-initialize a blank project
        initializeBlankProject(); 
    } else if (currentPageId === pageId) {
        // If current page was deleted, switch to the first remaining page
        window.switchPage(projectData[0].id);
    }
    
    // 3. Re-render and save
    renderPageList();
    window.saveProject(); // Ensure data is persisted
}

 
window.movePage = function(pageId, direction) {
    // CRITICAL FIX: Use projectData
    const oldIndex = projectData.findIndex(p => p.id === pageId);

    if (oldIndex === -1) return;
    const newIndex = oldIndex + direction;
    if (newIndex < 0 || newIndex >= projectData.length) return;

    // 1. Remove and get the page
    const [pageToMove] = projectData.splice(oldIndex, 1);
    
    // 2. Insert at the new position
    projectData.splice(newIndex, 0, pageToMove);

    // 3. Re-render and save
    renderPageList();
    window.saveProject(); 
}

 

        window.toggleEditMode = function() {
            DesignMode = !DesignMode; 
            const isEditable = editor.getAttribute('contenteditable') === 'true';
            editor.setAttribute('contenteditable', !isEditable);
	speaking=!speaking;
	speakBtn.textContent=(!speaking)?'🔇':'🔈';
        }


        window.applyForeColor = function(color) {
             document.execCommand('styleWithCSS', false, true); 
             document.execCommand('foreColor', false, color); 
             document.execCommand('styleWithCSS', false, false);
        }
        window.rgbToHex=function(rgb) {
            // 從 'rgb(r, g, b)' 或 'rgba(r, g, b, a)' 字串中提取 r, g, b
            const parts = rgb.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d*\.?\d*))?\)$/);
            if (!parts) return '#ffffff'; // 如果格式不符，返回白色
            
            const r = parseInt(parts[1]);
            const g = parseInt(parts[2]);
            const b = parseInt(parts[3]);
            
            // 將 RGB 轉換為十六進制
            const toHex = (c) => {
                const hex = c.toString(16);
                return hex.length === 1 ? "0" + hex : hex;
            };

            return "#" + toHex(r) + toHex(g) + toHex(b);
        }


              //############################ INSERT ELEMENT      Dynamic Element ####################

        // --- Dynamic Element Creation ---



window.addDivWithImageBackgroundElement = function() {
     const imageUrl = document.getElementById('Xurl').value;
 
     if (!imageUrl) return;

    const imgDiv = document.createElement('div');
    
    // 1. Assign a unique ID (Required for saving and selection)
    imgDiv.id = `img-${Date.now()}`; 
    
    imgDiv.className = 'draggable-image';
    
    // Set positioning explicitly (CRITICAL for draggable)
    imgDiv.style.position = 'absolute'; 
    imgDiv.style.left = `${lastClickPos.x}px`;
    imgDiv.style.top = `${lastClickPos.y}px`;
    
    imgDiv.style.width = '150px';
    imgDiv.style.height = '150px';
    imgDiv.style.backgroundImage = `url('${imageUrl}')`;
    imgDiv.style.backgroundSize = 'cover';
    imgDiv.style.backgroundPosition = 'center';
    imgDiv.style.backgroundRepeat = 'no-repeat';
    imgDiv.style.borderRadius = '0px'; 
    
    editor.appendChild(imgDiv);
    
    // 2. Initialize ALL necessary properties and handlers
    window.initElement(imgDiv); // Adds resizer, z-index
    window.initElementForMovement(imgDiv); // Adds data-degree for rotation
    
    window.saveProject();
    window.showModal('Image element added.', 'Success');
}




 window.insertCode=function(htmlString) {

  
  const selection = window.getSelection();  
             const url = prompt("Enter the URL for the link (e.g., https://www.google.com):"); 
	     const myH= Number(activeItem.style.height.replace('px',''))*0.8;
    
    if (selection.rangeCount > 0) {
        const range = selection.getRangeAt(0);

            //const htmlString="<a href=\""+url+"\" target=\"_blank\" >"+range+"</a>";
	    
        // Create a temporary div to parse the HTML string into DOM nodes
        const tempDiv = document.createElement('span');
 
        if(htmlString=='iframe'){

	   tempDiv.innerHTML=`<iframe src="${url}" style="height:${myH}px;width:100%" ></iframe>`;
	}else if(htmlString=='img'){

	   tempDiv.innerHTML=`<image src="${url}" style="height:auto;width:200px;display:inline" ondblclick="window.dealme(this);" alt="按兩下調整尺寸" ></image>`;
        }else{
        tempDiv.innerHTML = htmlString;
        }

        const fragment = document.createDocumentFragment();
        while (tempDiv.firstChild) {
            fragment.appendChild(tempDiv.firstChild);
        }

        range.deleteContents(); // Optional: remove selected text
        range.insertNode(fragment);

        // Optionally, collapse the selection after insertion
        selection.collapseToEnd();
     
  } else {
    // If no selection, append to the end
    contentEditableElement.appendChild(document.createTextNode(htmlString));
  }
}

         window.addNewTextElement=function(type,mycolor) {
            if (!type) return;
	 
            let defaultContent = "";
            let tagName = type.toLowerCase();
		let randomNumber = Math.random();
		randomNumber =Math.floor(randomNumber*1000);            
            // Reset the dropdown after selection  
            document.getElementById('addElementType').value = ""; 

            if (type === 'P') {
                defaultContent = "<p>按兩下後在此打字</p>";
            } else if (type === 'H1') {
                defaultContent = "<h1>按兩下後在此打字</h1>";
            } else if (type === 'H2') {
                defaultContent = "<h2>按兩下後在此打字</h2>";
            } else if (type === 'H3') {
                defaultContent = "<h3>按兩下後在此打字</h3>";
            } else if (type === 'sticker') {
                defaultContent = `<div id="hinder${randomNumber}" style="padding-left:40px;color:blue;font-size:30px">memo </div><div class="resizer"></div>`;

            } else if (type === 'Animateout') {

                defaultContent = "<h3>按兩下後在此打字</h3>";
		window.addTextElementAnimated();
                return;
            } else if (type === 'Hinter') {
               defaultContent = `<div id="hinder${randomNumber}"   ontouchstart="dropmenu('hinder${randomNumber}_menu')"  onclick="dropmenu('hinder${randomNumber}_menu')" style="position:relative;background-size:contain;padding-left:40px;color:blue;font-size:30px;display:inline"><b>按兩下後在此打字，白板模式中按一下顯示V或X<BR>作為答案結果(進設計模式下可刪除)</b><span id="hinder${randomNumber}_menu" style="display:none;position:absolute;top:-10px;left:-20px;background:;border:1px solid gray;border-radius:25px;padding:4px;width:100%px;height:50px;background-size:contain" ><font color="black" size="6" >✔️❌</font></span> </div>`;

            } else if (type === 'DropMenu') {
                defaultContent = `<h1 id="hinder${randomNumber}"   ontouchstart="dropmenu()"  onclick="dropmenu()" style="position:relative;background-size:contain"><b>按兩下後在此打字</b><span id="hinder${randomNumber}_menu" style="display:none;position:absolute;top:50px;left:10px;background:white;border:2px solid gray;border-radius:25px;padding:4px;width:100%;background-size:contain" ><font color="black" size="6"  ontouchstart="this.style.display='none';" >說明:</font></span></h1> `;
            } else if (type === 'Poke') {
                defaultContent = `<div id="hinder${randomNumber}"   ontouchstart="showCard(this)"  onclick="showCard(this)" style="border-radius:16px;background-size:contain;background-repeat:no-repeat;background-position-y: center;border:10px solid white;box-shadow:4px 4px 2px gray"> <img id="coverpic" src="https://opengameart.org/sites/default/files/styles/medium/public/card%20back%20red.png" style="display:none;"></div> `;

            } else if (type === 'TTS') {
                defaultContent = `<div  id=\"TTS"+randomNumber+"\"   class="TTS" ontouchstart="speakText(this.textContent)"  onclick="speakText(this.textContent)" style="background-size:contain" >按兩下在此打字電腦報讀語音</div>`;
            } else if (type === 'VRS') {
	 
                defaultContent = `<div  id="template" class="VRS" onclick="javascripot:window.randomItem();this.textContent=this.textContent.substring(0,this.textContent.lastIndexOf('(')) +'(' + document.getElementById('temp').value+ ')' + this.textContent.substring(this.textContent.lastIndexOf(')')+1,this.textContent.length);startVoiceRecognition(this.textContent);"     style="background-size:contain" > ( ) is my favorite.</div>`;
           } else if (type === 'Quiz') {
            window.createQuizFloatingDiv(mycolor);
            return;
 

            } else {
                return;
            }

            const textDiv = document.createElement('div');
            textDiv.className = 'floating-div';  // fly-in-animated transition-all duration-700 ease-out
            textDiv.style.left = `${lastClickPos.x}px`;
            textDiv.style.top = `${lastClickPos.y}px`;
            textDiv.setAttribute('contenteditable', 'false');
            textDiv.style.backgroundSize = 'contain';
            textDiv.style.backgroundColor=`${mycolor}`;
            textDiv.style.borderRadius = '0px'; // Initialize with 0 radius
            textDiv.style.padding = '5px';
            textDiv.style.minWidth = '10px'; // Give headings some space
            //textDiv.style.fontSize = '30pt';  
            textDiv.innerHTML = defaultContent;
            
            editor.appendChild(textDiv);
            window.initElement(textDiv);
        }



       //插入動畫文字
         window.addTextElementAnimated=function() {
            const textDiv = document.createElement('div');
            // Start text elements VISIBLE, but include the animation utility class
            textDiv.className = 'floating-div fly-in-animated transition-all duration-700 ease-out opacity-100';
            textDiv.style.left = `${lastClickPos.x}px`;
            textDiv.style.top = `${lastClickPos.y}px`;
            textDiv.setAttribute('contenteditable', 'false'); 
            textDiv.style.backgroundColor = '#ffffaa';
            textDiv.style.borderRadius = '12px';
            textDiv.innerHTML = "Click the 'Toggle Animation' button to fly me in/out, then use the Gemini AI Tools!";
            editor.appendChild(textDiv);
            window.initElement(textDiv);
        }


 // --- FLY-IN ANIMATION LOGIC ---
      window.toggleFlyIn=function(element) {

            if (!element || !element.classList.contains('fly-in-animated')) {
                //showModal('Please select a text element to animate.', 'Info');
                return;
            }
            
            if (element.classList.contains('locked')) {
                window.showModal("Item is locked and cannot be animated.", 'Info');
                //return;
            }
            if (element.classList.contains('editing')) {
                window.showModal("Item is editing and cannot be animated.", 'Info');
                //return;
            }

            const isHidden = element.classList.contains('opacity-0');
        if (DesignMode==false) {
            if (isHidden) {
                element.classList.add('opacity-100', 'translate-x-0');
                element.classList.remove('opacity-0', '-translate-x-full');
		window.speakText(element.innerText);
		flag=false;
            } else {

                 element.classList.add('opacity-0', '-translate-x-full');
                 element.classList.remove('opacity-100', 'translate-x-0');
            }
		

         }else{
                
 		 const items = document.querySelectorAll('.fly-in-animated');
		items.forEach(item => {
		//showModal('item number'+items.length,'end phase');
					item.classList.remove('opacity-0', '-translate-x-full');
					item.style.display='';
					item.classList.remove('opacity-100', '-translate-x-0');
		});
	}



        }

 window.textSlider=function(){

 //const playlist=[];
  const sliders = editor.querySelectorAll('.fly-in-animated');

  sliders.forEach((slider,i)=>{
 
   //if(sliders[i].classList.contains('fly-in-animated')){
         //playlist.push(sliders[i]);
         //playlist.reverse();
   //}
  });



        window.showModal(counter,'slider number');

       //playlist[i].classList.add('activeItem');
        window.toggleFlyIn(sliders[counter]);
	 counter +=1;

        if (counter==sliders.length || counter>sliders.length){            
		counter=0;
	}
}



//回傳隨機圖片名稱
   window.randomItem=function(){
	 //alert('wtf');
	  let seeds = document.getElementById('editor').querySelectorAll('.draggable-image');
	   
	let seedx=Math.floor(Math.random()*seeds.length);
		gameTarget=seeds[seedx].id;
		document.getElementById('temp').value=gameTarget;
		quizCount +=1;
                           window.showModal(gameTarget,'get')
		return gameTarget

        }


//-----------------------加入動畫
     window.toggleAnimate=function(animate){
           activeItem.classList.remove('.animate-ping', '.animate-pulse', '.animate-spin',  '.animate-bounce','.translate-y-full');
             if(activeItem.classList.contains(animate)){
	 activeItem.classList.remove(animate);
           }else{
	activeItem.classList.add(animate);
          }
         
	 //####-translate-x-full  translate-x-0 -translate-y-80 ,'-translate-y-80'
	 //###animate-none .animate-ping animate-pulse animate-spin  animate-bounce animate-spin .animate-bounce


        }








     //套用id名稱，隱藏資訊        到選取的圖層
       window.applyMyInfo=function() {
            const myID = document.getElementById('MyID').value;
		
                activeItem.setAttribute("id",myID);

                if (activeItem.getElementsByTagName("span")){
		       if(activeItem.getElementsByTagName("span")[0]){
		           activeItem.getElementsByTagName("span")[0].innerText=document.getElementById('MyInfo').value;
		       }else{

		           const mytag = document.createElement('span');
			   mytag.style.display="none";
			   mytag.innerText=document.getElementById('MyInfo').value;
                           activeItem.appendChild(mytag);

                       }
		 } 
 
		 	
	}

 
 window.duplicateActiveItem=function() {
    // 檢查是否有選中的元素 (activeItem 應該是您用來儲存當前選中元素的變數)
    if (!activeItem) {
        console.warn("No item selected for duplication.");
        return;
    }

    // 1. 執行深層複製 (Deep Clone)
    //    傳入 true 確保複製所有子節點、屬性和樣式
    const newItem = activeItem.cloneNode(true);
        document.getElementById('temp').value=activeItem.outerHTML;
    // 2. 清除不需要的屬性或 ID
    //    確保每個元素都有唯一的 ID (如果您的設計需要 ID)
    if (newItem.id) {
        // 假設您有一個 generateUniqueId() 函數來創建新的 ID
        // newItem.id = generateUniqueId(); 
    }
    
    // 3. 調整新元素的位置 (避免與原元素完全重疊)
    //    複製後的元素樣式和位置通常會被複製過來，我們微調 left 和 top
    const currentLeft = parseInt(activeItem.style.left) || 0;
    const currentTop = parseInt(activeItem.style.top) || 0;

    const offset = 10; // 偏移量，讓複製的元素在右下方可見
    
    newItem.style.left = (currentLeft + offset) + 'px';
    newItem.style.top = (currentTop + offset) + 'px';
 
 
    // 4. 將新元素插入 DOM
   // const editor = document.getElementById('editor');
    editor.appendChild(newItem);

    // 5. 重新初始化 (關鍵步驟)
    //    新複製的元素沒有拖曳事件，需要重新綁定
    window.initElements();
    
    // 6. 設置新元素為當前選中項
    setActiveItem(newItem); // 假設您有一個 setActiveItem 函數來處理選中狀態
   showModal('已再製','')
    console.log("Item duplicated successfully.");    

}



 window.pasteClone=function(){
       
    const editor = document.getElementById('editor');
    const tempdiv=document.createElement('div');
    tempdiv.innerHTML=document.getElementById('temp').value;
    editor.appendChild(tempdiv);

    // 5. 重新初始化 (關鍵步驟)
    //    新複製的元素沒有拖曳事件，需要重新綁定
    window.initElements();
}






 window.expand=function(){
 if (""!=event.srcElement.id) {	   

		let ch=event.srcElement.id + "_0"; 
        	//var target=document.all[ch] 

		let target=document.getElementById(ch);
  
		if (null!=target){target.style.display =(target.style.display=="none" ) ? "" : "none";} 
		

 }
           //alert(window.randomItem());

 if (event.srcElement.getElementsByTagName("span") && event.srcElement.classList.contains('draggable-image')){
       const imgpool=event.srcElement.querySelectorAll("img");
	if(DesignMode){
	activeItem.getElementsByTagName("span")[0].style.display='';
		event.srcElement.setAttribute('contentEditable','true');
		//showModal(imgpool.length,'');
		
	        if(imgpool){
		 imgpool.forEach(sw=>{
			sw.style.display='';
		         });
                }
	}else{
	activeItem.getElementsByTagName("span")[0].style.display='none';
		activeItem.setAttribute('contentEditable','false');

	        if(imgpool){
		 if(imgpool.length>3){activeItem.style.transform = 'translateY(-250px)';}		
		 imgpool.forEach(sw=>{
			sw.style.display='none';
		         });
                }

	
		window.swapImg(activeItem);

	}//end if design mode

		

      }//end if span exits

		
}




 window.dropmenu=function(target){
        	 
         if(target){		 
	 const targetx=document.getElementById(target);
                   if (null!=targetx && DesignMode==false){targetx.style.display =(targetx.style.display=="none" ) ? "flex" : "none";}
       }else{

                         if (""!=event.srcElement.id) {
                                   let ch=event.srcElement.id + "_menu"; 
		const mytarget=document.getElementById(ch);

		   if (null!=mytarget){
			mytarget.style.display =(mytarget.style.display=="none" ) ? "flex" : "none";
			
			if(mytarget.innerText=='' && mytarget.classList.contains('floating-div')){showCard(event.srcElement,mytarget);}//==========需要再加條件
		   }

                      }
	}
		 


}



//撲克牌模式===🃏
  let cardflag=false;
 window.showCard=function(mytarget){
   cardflag=!cardflag
      let coverpic=document.getElementById('coverpic').src; 
      let mybk=document.getElementById(window.randomItem()).style.backgroundImage;
      let act=Math.floor(Math.random()*10);

  if(cardflag==false){
       mytarget.style.cssText=`  font-size:30px;color:blue;display: flex;align-items: center;justify-content: center;width:120px;height:160px;background-size:contain;background-repeat:no-repeat;background-position-y:center;background-color:;border:10px white solid;border-radius:15px;box-shadow:4px 4px 6px gray`;
       mytarget.style.backgroundImage=`url('${coverpic}')`;
       let bnr=document.createElement('span');
        if(act>5){
           window.showModal('Say ','Do');
       }else{
           window.showModal('Act ','Do');      
       }
  }else{
  mytarget.style.cssText=`width:120px;height:160px;background-size:contain;background-repeat:no-repeat;background-position-y:center;background-color:;border:10px white solid;border-radius:15px;box-shadow:4px 4px 6px gray`;
  mytarget.style.backgroundImage=document.getElementById(window.randomItem()).style.backgroundImage;
   //mytarget.inneText='';
  window.startVoiceRecognition(gameTarget);

  }
 
}




window.swapImg=function(targetElement){


		const imgpool=targetElement.querySelectorAll("img");
		//showModal(imgpool.length,'total images');

		if(imgpool.length==1){
			const swapimg=imgpool[0].src;
			targetElement.style.backgroundImage=`url('${swapimg}')`;

		}else{
 	               //targetElement.style.transform ='rotate(45deg)';
			


 	           setTimeout(() => {
			
			let x=Math.floor(Math.random()*imgpool.length);
			const swapimg=imgpool[x].src;	
			targetElement.style.backgroundImage=`url('${swapimg}')`;

	                //activeItem.style.transform = 'translateY(-80px)';
	                targetElement.style.transform = 'rotate(45deg)';


 	      setTimeout(() =>{ targetElement.style.transform = 'rotate(90deg)';}, 100);
	            }, 100);
			 targetElement.style.transform = 'rotate(360 deg)';
			//activeItem.style.transform = 'translateY(-20px)';

				
		}		
			//const bg=`background-image:url('${swapimg}'); background-size: cover;`;
}


//---paste as file without uploading免上傳的本機圖片貼上 
   window.handlePaste=function(event) {
        //if (!isEditing) return; 


        const items = event.clipboardData.items;
        let imagePasted = false;

        for (let i = 0; i < items.length; i++) {
            // Look for an image item (kind === 'file' is crucial for image data)
            if (items[i].type.indexOf('image') !== -1 && items[i].kind === 'file') {
                event.preventDefault(); // Stop the default paste action
                imagePasted = true;
                const file = items[i].getAsFile();

                if (file) {
 
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        const base64Image = e.target.result;

           const imgDiv = document.createElement('div');
            imgDiv.className = 'draggable-image';
            imgDiv.style.left =  `${lastClickPos.x}px`;;
            imgDiv.style.top =  `${lastClickPos.y}px`;;
            imgDiv.style.maxWidth = '100%';
            imgDiv.style.width = '150px';
            imgDiv.style.height = '150px';
            imgDiv.style.backgroundImage = `url('${base64Image}')`;
            imgDiv.style.backgroundSize = 'cover';
            imgDiv.style.backgroundPosition = 'center';
            imgDiv.style.backgroundRepeat = 'no-repeat';
            imgDiv.style.borderRadius = '0px'; // Initialize with 0 radius
            editor.appendChild(imgDiv);
            window.initElement(imgDiv); 

                        // Create an IMG element
                        const img = document.createElement('img');
                         img.src = base64Image;
                         
                        // Add the draggable class and initial positioning
                        //img.className = 'draggable-content'; 

                        //editor.insertNode(img); // Insert into the editor~~~~Not working

  //--selection pasting
  const selection = window.getSelection();

    if (selection.rangeCount > 0 && activeItem.classList.contains('editing')) {
        const range = selection.getRangeAt(0);
             const htmlString=`<img src='${base64Image}' style="display:inline;width:150px;height:auto" alt="按兩下調整尺寸" ondblclick="dealme(this);" >`;	    
        // Create a temporary div to parse the HTML string into DOM nodes
        const tempDiv = document.createElement('span');
        tempDiv.innerHTML = htmlString;
        const fragment = document.createDocumentFragment();
        while (tempDiv.firstChild) {
            fragment.appendChild(tempDiv.firstChild);
        }

        range.deleteContents(); // Optional: remove selected text
        range.insertNode(fragment);

        // Optionally, collapse the selection after insertion
        selection.collapseToEnd();
     
  } else {
    // If no selection, append to the end
    contentEditableElement.appendChild(document.createTextNode(htmlString));
  }
//--selection pasting



                    };
                    reader.readAsDataURL(file);
                    break; 
                }
            }
        }
    }

 window.insertDice=function(){

	 const dicecode=document.getElementById('diceSample').innerText;
	document.getElementById('temp').value=dicecode;
	window.pasteClone();

}


 window.OLDinsertDice=function(){

	 const dicecode=`<div class="draggable-image " style="background-image: url('https://www.emojiall.com/images/120/samsung/2685.png'); background-size: cover; z-index: 10; left: 439px; top: 161px; width: 76px; height: 72px; border-radius: 8px;padding:0px;margin:0px;box-shadow:2px 2px  gray" id="" contenteditable="true" data-listener-added_4520328c="true"><span style="" contenteditable="true">AAAA<img src="https://www.emojiall.com/images/120/samsung/2681.png" style="height: auto; width: 200px;" ondblclick="window.dealme(this);" alt="按兩下調整尺寸"><img src="https://www.emojiall.com/images/120/samsung/2682.png" style="height: auto; width: 200px;" ondblclick="window.dealme(this);" alt="按兩下調整尺寸"><img src="https://www.emojiall.com/images/120/samsung/2683.png" style="height: auto; width: 200px;" ondblclick="window.dealme(this);" alt="按兩下調整尺寸"><img src="https://www.emojiall.com/images/120/samsung/2684.png" style="height: auto; width: 200px;" ondblclick="window.dealme(this);" alt="按兩下調整尺寸"><img src="https://www.emojiall.com/images/120/samsung/2685.png" style="height: auto; width: 200px;" ondblclick="dealme(this);" alt="按兩下調整尺寸"></span><img src="https://www.emojiall.com/images/120/samsung/2680.png" style="width: 200px;" alt="按兩下調整尺寸"><div class="resizer"></div></div>`;

	document.getElementById('temp').value=dicecode;
	window.pasteClone();

}

 window.dealme=function(ele){
 	const p = prompt("輸入尺寸如60(\%)");
 
 	const w=ele.style.width.substring(0,ele.style.width.length-2);
 

	ele.style.width=p*(w/100)+'px';
 
}




        // #########################  Styling Functions (Scoped to activeItem) ################################3

        /**
         * Generic runner for simple text formatting commands (bold, italic, underline).
         */
      window.runTextCommand=function(command) {
            // Check if active item is a text div AND is editable
            if (!activeItem || activeItem.getAttribute('contenteditable') !== 'true' || !activeItem.classList.contains('floating-div')) {
                console.error(`Cannot run command '${command}': Select a text item and click 'Edit Text' first.`);
                return;
            }
            activeItem.focus();
            document.execCommand(command, false, null);
        }

        // formatBlock function removed as the feature is now handled by the addNewTextElement dropdown

       window.setFontColor=function() {
             if (!activeItem || activeItem.getAttribute('contenteditable') !== 'true' || !activeItem.classList.contains('floating-div')) return;
            activeItem.focus(); 
            document.execCommand('foreColor', false, document.getElementById('fontColor').value);
        }

     window.setFontSize=function() {
            // Font size command works with index values 1-7
            if (!activeItem || activeItem.getAttribute('contenteditable') !== 'true' || !activeItem.classList.contains('floating-div')) return;
            const sizeValue = document.getElementById('fontSize').value;
            activeItem.focus(); 
            document.execCommand('fontSize', false, sizeValue);
        }

   window.changeFont=function() {
    const fontName = document.getElementById('fontSelector').value;
    document.execCommand('fontName', false, fontName);
  }

      window.setBackgroundColor=function(cmd) {
            // Background color can be applied to both text and image elements

            if (!activeItem || (!activeItem.classList.contains('floating-div') && !activeItem.classList.contains('draggable-image'))) return;
	if(cmd=='t'){activeItem.style.backgroundColor ='';}else{
            const color = document.getElementById('backgroundColor').value;
            activeItem.style.backgroundColor = color;}

        }

     window.dobg=function(url) {
            const color = document.getElementById('backgroundColor').value;
	
           if(document.getElementById('main')){
                document.getElementById('main').style.backgroundColor = color;
	let urlx=document.getElementById('main').style.backgroundImage;
                if(url){ document.getElementById('main').style.backgroundImage='url('+prompt('貼上底圖網址',urlx)+')';}
           }else{
 
                const bg=document.createElement('div');
                bg.style.cssText=`width:100%;height:100%;background-size: contain;backgroundColo:${color}`;
	let urlx='';
                if(url){ document.getElementById('main').style.backgroundImage='url('+prompt('貼上底圖網址')+')';}
                //if(url !==null){ document.getElementById('main').style.backgroundImage=`url('${urlx}')`;}
                bg.id='main';
	editor.prepend(bg);
	//editor.appendChild(bg);
 
           }
        }



         window.applyBorderChanges=function() {

           //const borderColor = document.getElementById('backgroundColor').value;
           const borderColor = document.getElementById('borderColor').value;
           const borderWidth = document.getElementById('borderWidth').value;
            const borderStyle = document.getElementById('borderStyle').value;

            activeItem.style.borderColor = borderColor;
            activeItem.style.borderWidth = borderWidth;
           activeItem.style.borderStyle = borderStyle;
        }

        // Apply initial changes on page load
       // document.addEventListener('DOMContentLoaded', applyBorderChanges);




        // --- MODIFIED: Opacity Control Function ---
        window.setElementOpacity= function(value) {
            if (!activeItem) return;
            
            // 1. 執行 Opacity 變更
            const opacityValue = value / 100;
            activeItem.style.opacity = opacityValue;
            
            // 2. 清除前一個計時器
            if (opacityTimer) {
                clearTimeout(opacityTimer);
            }
            
            // 3. 設定一個新的計時器，在 500ms 後儲存歷史狀態
            // 這稱為 "Debounce"，能防止連續滑動時產生過多的歷史紀錄
            opacityTimer = setTimeout(() => {
                pushHistoryState();
            }, 500);
        }

        

        /**
         * Sets the border radius of the active item (for both text and image divs).
         */
        window.setBorderRadius= function() {
            if (!activeItem) return;

            // Check if the item is a text element OR a draggable image
            const isStylable = activeItem.classList.contains('floating-div') || activeItem.classList.contains('draggable-image');
            
            if (isStylable) {
                const radius = document.getElementById('borderRadius').value;
                activeItem.style.borderRadius = `${radius}px`;
            }
        }



 window.insertLink=function() {
  const selection = window.getSelection();  

    
    if (selection.rangeCount > 0) {
        const range = selection.getRangeAt(0);
            const url = prompt("Enter the URL for the link (e.g., https://www.google.com):"); 
            const htmlString="<a href=\""+url+"\" target=\"_blank\" ><b>"+range+"</b></a>";
	    
        // Create a temporary div to parse the HTML string into DOM nodes
        const tempDiv = document.createElement('span');
        tempDiv.innerHTML = htmlString;
        const fragment = document.createDocumentFragment();
        while (tempDiv.firstChild) {
            fragment.appendChild(tempDiv.firstChild);
        }

        range.deleteContents(); // Optional: remove selected text
        range.insertNode(fragment);

        // Optionally, collapse the selection after insertion
        selection.collapseToEnd();
     
  } else {
    // If no selection, append to the end
    contentEditableElement.appendChild(document.createTextNode(htmlString));
  }
}





         window.removeLink=function() {
            if (!activeItem || activeItem.getAttribute('contenteditable') !== 'true' || !activeItem.classList.contains('floating-div')) {
                console.error("Please select a text item and click 'Edit Text' first.");
                return;
            }
            activeItem.focus();
            document.execCommand('unlink', false, null);
        }



        // --- 5. YOUR EXISTING MODULE CODE (INTEGRATED PLACEHOLDERS) ---
        // ------------------------------------------------------------------
        // *** CRITICAL STEP: REPLACE THESE PLACEHOLDERS WITH YOUR FULL CODE ***
        // ------------------------------------------------------------------

// Add these empty definitions near your other window.functions

 window.updateLockButtonState=function() {
             if (activeItem && activeItem.classList.contains('locked')) {
                lockToggleBtn.textContent = '🔒off';
            } else {
                lockToggleBtn.textContent = '🔏on';
            }
 }
window.updateEditButtonState=function() { 

           if (!editToggleBtn) return;

            const isTextElement = activeItem && activeItem.classList.contains('floating-div');
            const isEditing = activeItem && activeItem.getAttribute('contenteditable') === 'true';

            if (isTextElement) {
                editToggleBtn.disabled = activeItem.classList.contains('locked');
                editToggleBtn.textContent = isEditing ? '停止編輯' : '編輯文字';
            } else {
                editToggleBtn.disabled = true;
                editToggleBtn.textContent = '編輯文字';
            }

 }

window.selectItem = function(item) {
    if (activeItem && activeItem !== item) {
        activeItem.classList.remove('selected');
        // IMPORTANT: Also disable contenteditable on the previously selected item
        if (activeItem.getAttribute('contenteditable') === 'true') {
            activeItem.setAttribute('contenteditable', 'false');
            activeItem.classList.remove('editing');
        }
    }
    activeItem = item;
    activeItem.classList.add('selected');
    window.updateLockButtonState();
    window.updateEditButtonState();
}


        // ########################## Element Controls #########################
        window.bringForward= function() {
            if (!activeItem || activeItem.id === 'editor') return;
            // Max z-index for normal elements is 14 (canvas is 15)
            const currentZIndex = parseInt(activeItem.style.zIndex) || 20;
            activeItem.style.zIndex = Math.min(14, currentZIndex + 1);
        }

      window.sendBackward= function() {
            if (!activeItem || activeItem.id === 'editor') return;
            const currentZIndex = parseInt(activeItem.style.zIndex) || 20;
            activeItem.style.zIndex = Math.max(10, currentZIndex - 1);
        }

     window.deleteSelectedItem= function() {
            if (activeItem) {
                activeItem.remove();
                activeItem = null;
                updateLockButtonState();
                updateEditButtonState();
            }
        }






         window.toggleContentEditable=function() {
	//showModal(activeItem.outerHTML);
            if (!activeItem || !activeItem.classList.contains('floating-div')) {
                console.error("Cannot edit: No text item selected.");
                return;
            }

            if (activeItem.classList.contains('locked')) {
               // console.warn("Item is locked and cannot be edited.");
                //return;
            }

            const isEditable = activeItem.getAttribute('contenteditable') === 'true';

            if (isEditable) {
                // Stop editing
                activeItem.setAttribute('contenteditable', 'false');
                activeItem.classList.remove('editing'); 
                activeItem.blur();
	        pushHistoryState(); 
             
            } else {
                // Start editing
                activeItem.setAttribute('contenteditable', 'true');
                activeItem.classList.add('editing');
                activeItem.focus();
             
            }
            updateEditButtonState();

        }

window.resetSlides = function() {
    // 1. Select all elements that use the sliding animation
    const sliders = document.querySelectorAll('#editor .fly-in-animated'); 
    // Using document.querySelectorAll is safer than editor.querySelectorAll 
    // if the editor content is briefly cleared or swapped.
    
    if (sliders.length === 0) {
        // Safe exit if no elements are found
        return;
    }

    sliders.forEach(slider => {
        // Ensure the element exists before attempting to manipulate its classes
        if (slider && slider.classList) {
            
            // Remove the final, visible state classes (opacity: 100, translate-x: 0)
            slider.classList.remove('opacity-100', 'translate-x-0');
            
            // Add the initial, hidden state classes (opacity: 0, translate-x: -full)
            // This prepares the element to "fly in" when the page is viewed again.
            slider.classList.add('opacity-0', '-translate-x-full');
            
            // Optional: Force a reflow/re-paint if needed to ensure the slide hides immediately
            void slider.offsetWidth; 
        }
    });
    console.log("Slide animations reset for new page load.");
}



window.handleStart=function(e){ 

            isSwiping = false; // <-- 新增: 拖曳開始時取消滑動狀態
 	    if (currentTool !== null) return; // Prevent interaction with elements when a drawing tool is active
            //if (isDrawingEnabled) return;
            const clientX = e.clientX || e.touches[0].clientX;
            const clientY = e.clientY || e.touches[0].clientY;

            // Calculate position relative to editor for new elements
            const editorRect = editor.getBoundingClientRect();
            lastClickPos.x = clientX - editorRect.left;
            lastClickPos.y = clientY - editorRect.top;
            
            const targetElement = e.target.closest('.draggable-image, .floating-div, .resizer');

            // Handle clearing selection if clicking on the main editor area
            if (e.target.id === 'editor' || (e.target.tagName === 'DIV' && e.target.id !== 'drawingCanvas' && !targetElement)) {
                if (activeItem) {
                    activeItem.classList.remove('selected');
                    if (activeItem.getAttribute('contenteditable') === 'true') {
                        activeItem.setAttribute('contenteditable', 'false');
                        activeItem.classList.remove('editing');
                    }
                }
                activeItem = null;
                updateLockButtonState();
                updateEditButtonState();
                return;
            }

            if (targetElement) {
                const movableElement = targetElement.closest('.draggable-image, .floating-div');
                
                if (movableElement) {
                    selectItem(movableElement); 
                    
                    const isLocked = movableElement.classList.contains('locked');
                    const isEditable = movableElement.getAttribute('contenteditable') === 'true'; 
                    
                    // Block drag/resize if locked OR currently being edited
                    if (isLocked || isEditable) { 
                        return; 
                    }

                    // Allow Resizing
                    if (e.target.classList.contains('resizer')) {
                        isResizing = true;
                        isDragging = false;
                        startX = clientX;
                        startY = clientY;
                        startWidth = activeItem.offsetWidth;
                        startHeight = activeItem.offsetHeight;
                        e.preventDefault();
                    } 
                    // Allow Dragging
                    else { 
                        isDragging = true;
                        isResizing = false;
                        startX = clientX;
                        startY = clientY;
                        startLeft = activeItem.offsetLeft;
                        startTop = activeItem.offsetTop;
                        e.preventDefault();

                    }
                }
                e.stopPropagation();
            }
        }
window.handleMove=function(e){ 
 
            if (!activeItem || activeItem.classList.contains('locked') || activeItem.getAttribute('contenteditable') === 'true' || (!isDragging && !isResizing)) return;

            const clientX = e.clientX || e.touches[0].clientX;
            const clientY = e.clientY || e.touches[0].clientY;

            if (isResizing) {
                const newWidth = startWidth + (clientX - startX);
                const newHeight = startHeight + (clientY - startY);
                activeItem.style.width = `${Math.max(50, newWidth)}px`;
                activeItem.style.height = `${Math.max(50, newHeight)}px`;
            } else if (isDragging) {
                const newLeft = startLeft + (clientX - startX);
                const newTop = startTop + (clientY - startY);
                activeItem.style.left = `${newLeft}px`;
                activeItem.style.top = `${newTop}px`;
	if(window.checkMode){
	  window.checkOverlap(activeItem); 
	}
             //======================================  一碰到就有反應 

            }
            e.preventDefault();
        }

 window.handleEnd=function() { 
    if (isDragging || isResizing) {
       // pushHistoryState(); // <-- 新增: 拖曳/縮放結束
    }
    isDragging = false; 
    isResizing = false; 

}



   
// MOUSE EVENTS: The main actions should fire globally
window.addEventListener('mousemove', handleMove);
window.addEventListener('mouseup', handleEnd);

// TOUCH EVENTS: The main actions should fire globally
window.addEventListener('touchmove', handleMove);
window.addEventListener('touchend', handleEnd);
window.addEventListener('touchcancel', handleEnd);

// The start events MUST remain on the editor/document to detect the start of a drag/resize
editor.addEventListener('mousedown', handleStart);
editor.addEventListener('touchstart', handleStart);

 editor.addEventListener('dblclick',toggleContentEditable);
editor.addEventListener('paste', handlePaste);

//-----OLD listener

        editor.addEventListener('mousedown', handleStart);
        editor.addEventListener('mousemove', handleMove);
        editor.addEventListener('mouseup', handleEnd);
        editor.addEventListener('mouseleave', handleEnd);
//-----OLD listener 


/**
 * Toggles the 'locked' class on the active element and updates the UI button.
 */
window.toggleLock = function() {
    if (!activeItem) {
        window.showModal('No item selected to lock/unlock.', 'Error');
        return;
    }
           if(activeItem.classList.contains('locked')){
                    activeItem.classList.remove('opacity-50', 'animate-bounce');
          }
    // Toggle the 'locked' class
    activeItem.classList.toggle('locked');

    // Update the button and save the project state
    window.updateLockButtonState();
    window.saveProject();
    
    window.showModal(
        activeItem.classList.contains('locked') ? 'Element Locked 🔏' : 'Element Unlocked🔒 ', 
        'Success'
    );
}

// Ensure the button state function is working correctly (you had this as a placeholder)
window.updateLockButtonState = function() {
    if (!lockToggleBtn) return;
    
    if (activeItem && activeItem.classList.contains('locked')) {
        lockToggleBtn.textContent = '  🔏';
        // Disable editing/resizing features if needed
    } else {
        lockToggleBtn.textContent = ' 🔒';
        // Enable editing/resizing features
    }
}


/**
 * Rotates the active element by the given degree value.
 * @param {number} degrees - The amount to rotate by (e.g., 90 for a quarter turn).
 */
window.rotateElement = function(degrees) {
    if (!activeItem) {
        window.showModal('No item selected to rotate.', 'Error');
        return;
    }
    
    // 1. Read current degree value from the data attribute (initElementForMovement sets this)
    let currentDegree = parseInt(activeItem.getAttribute('data-degree') || 0);

    // 2. Calculate the new degree
    let newDegree = currentDegree + degrees;
    
    // Normalize rotation (optional, but keeps numbers manageable)
    newDegree = newDegree % 360; 
    if (newDegree < 0) newDegree += 360;

    // 3. Apply the rotation style and update the data attribute
    activeItem.style.transform = `rotate(${newDegree}deg)`;
    activeItem.setAttribute('data-degree', newDegree);
    
    // 4. Save the project
    window.saveProject();
    
    window.showModal(`Rotated to ${newDegree}°`, 'Info');
}



/**
 * Helper function to select an item and update the UI controls.
 */
 window.selectItem=function(element) {
    // ... (Existing code for selecting, deselecting, and setting activeItem) ...

    activeItem = element;
    activeItem.classList.add('selected');
    window.updateLockButtonState(); 
    window.updateEditButtonState();

    // --- PROPERTY SYNC START ---


    // 1. 同步 Border Radius
    // Use getComputedStyle for robustness, but activeItem.style is faster if set inline.
    document.getElementById('borderRadius').value = parseInt(activeItem.style.borderRadius) || 0; 
    document.getElementById('borderWidth').value = parseInt(activeItem.style.borderWidth) || 0; 
    document.getElementById('borderColor').value = activeItem.style.borderColor;
    document.getElementById('borderStyle').value = activeItem.style.borderStyle;
    // 2. 同步 Opacity 滑桿的值
    // Check both inline style and computed style for better accuracy
    const currentOpacity = parseFloat(activeItem.style.opacity || getComputedStyle(activeItem).opacity) || 1.0;
    // UI slider usually goes from 0-100, so multiply by 100
    document.getElementById('elementOpacity').value = Math.round(currentOpacity * 100);

    // 3. 同步 Background Color
    // Use getComputedStyle to retrieve the computed color (often RGB)
    let bgColor = activeItem.style.backgroundColor || getComputedStyle(activeItem).backgroundColor;
    document.getElementById('backgroundColor').value = bgColor ? 
        window.rgbToHex(bgColor) : '#ffffff';


    // 4. NEW/REVISED: 同步 Background Image URL
    let fullUrl = activeItem.style.backgroundImage || getComputedStyle(activeItem).backgroundImage;
    let imageUrl = '';
    
    // Check if a background image URL exists and extract it safely
    if (fullUrl && fullUrl !== 'none') {
        // Regex to extract the URL from 'url("...")' or 'url(...)'
        // The URL is typically captured in the second group ($2)
        const match = fullUrl.match(/url\(['"]?(.*?)['"]?\)/);
        
        if (match && match[1]) {
            imageUrl = match[1];
        }
    }

    const xurlInput = document.getElementById('Xurl');
    const bgiconImg = document.getElementById('bgicon');
    let myinfo;
    // Set the input field value
    xurlInput.value = imageUrl;

    // Set the preview icon
    if (imageUrl) {
        bgiconImg.src = imageUrl;
    } else {
        // If no background image, set the preview icon to your default SVG placeholder
        bgiconImg.src = 'data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23ffffff%22%20d%3D%22M287%2069.9%20146.2%20205.9%205.4%2069.9c-2.3-2.3-5.3-3.5-8.5-3.5h-10.7c-3.2%200-6.2%201.2-8.5%203.5-4.7%204.7-4.7%2012.3%200%2017l148.6%20148.6c4.7%204.7%2012.3%204.7%2017%200l148.6-148.6c4.7-4.7%204.7-12.3%200-17z%22%2F%3E%3C%2Fsvg%3E';
    }
    
             //@@@@@@@@@@@@取得 ID名稱或內文
	    document.getElementById('MyID').value=activeItem.id;
                if (activeItem.getElementsByTagName("span")){
		    if(activeItem.getElementsByTagName("span")[0]){
		     document.getElementById('MyInfo').value=activeItem.getElementsByTagName("span")[0].innerText;
		    }else{document.getElementById('MyInfo').value='';}
		 } 
		      

		if(gameMode==true){
                   if(activeItem.id==gameTarget){
		           window.speakText("correct");
		          score +=1;
                          if(document.getElementById('gameInfo')){
			    let mytext=	document.getElementById('gameInfo').innerText;
				myinfo=mytext.split('*');
				document.getElementById('gameInfo').innerHTML=myinfo[0]+'*<b>'+window.randomItem()+'</b>*'+myinfo[2];
                                window.speakText(document.getElementById('gameInfo').innerText.replace('*',''));				
			  }else{
                           window.speakText('find '+window.randomItem());
			  }

                       }else{
			showModal(gameTarget,'error');
			// window.speakText("No,it's "+gameTarget); 
			score -=1;
                       }
		}
}




// ---  Gesture Handling Functions ---

     window.handleGestureStart=function(e) {
            // 只有在 'Select/Move' 模式下，且沒有選中任何元素時，才啟用滑動
            if (currentTool !== null || activeItem !== null) return;
            
            // 確保只處理單點觸摸或滑鼠點擊
            const clientX = e.clientX || e.touches[0].clientX;
            const clientY = e.clientY || e.touches[0].clientY;

            touchStartX = clientX;
            touchStartY = clientY;
            isSwiping = true;
        }

        window.handleGestureMove=function(e) {
            if (!isSwiping) return;

            const clientX = e.clientX || e.touches[0].clientX;
            const clientY = e.clientY || e.touches[0].clientY;

            const diffX = clientX - touchStartX;
            const diffY = clientY - touchStartY;
            
            // 優先考慮水平滑動，並防止頁面垂直滾動被鎖定
            if (Math.abs(diffX) > 300 || Math.abs(diffY) > 300) {
                // 如果水平移動明顯大於垂直移動，則阻止瀏覽器預設行為
                if (Math.abs(diffX) > Math.abs(diffY)) {
                    e.preventDefault(); 
                }
            }
        }

      window.handleGestureEnd=function(e) {
            if (!isSwiping) return;
            
            const clientX = e.clientX || e.changedTouches[0].clientX;
            // 不需要 finalY，因為我們只關心水平移動
            
            const diffX = clientX - touchStartX;
            isSwiping = false;

            // 檢查是否超過滑動閾值
            if (Math.abs(diffX) > SWIPE_THRESHOLD) {
                if (diffX >600) {
                    // 向右滑動 (X 增加) -> 切換到下一頁
                    window.goToNextPage();
                } else {
                    // 向左滑動 (X 減少) -> 切換到上一頁
                    window.goToPreviousPage();
                }
            }
        }



// --- NEW: Page Navigation Functions ---



         window.switchPage=function(pageId) {
            if (pageId === currentPageId) return; // Don't reload if it's the same page

            // 1. Save current page's state
             saveCurrentPageData();

            // 2. Set new current page
            currentPageId = pageId;

            // 3. Load new page's content
            loadPageData(pageId);
            
            // 4. Update UI
            renderPageList();
		//tempHTML=====htmlPageCode
		document.getElementById('htmlPageCode').value=document.getElementById('editor').innerHTML;
                //alert(tempHTML);=============換頁後產生暫存頁以供復原
        }


 window.goToPreviousPage = function() {
     window.resetSlides();
    // Get the index of the current page object
    const currentIndex = projectData.findIndex(p => p.id === currentPageId); 
    
    if (currentIndex > 0) {
        window.switchPage(projectData[currentIndex - 1].id);
    } else {
        window.showModal('已是第一頁', '頁數');
    }
}

window.goToNextPage = function() {
     window.resetSlides();
    // Get the index of the current page object
    const currentIndex = projectData.findIndex(p => p.id === currentPageId);
    
    if (currentIndex !== -1 && currentIndex < projectData.length - 1) {
        window.switchPage(projectData[currentIndex + 1].id);
    } else {
        window.showModal('已是最後一頁', '頁數');
    }
}
        // --- End of Page Navigation Functions ---



window.pushHistoryState=function() {
    // For now, we will save the project to persist the change immediately.
    // In a full implementation, this would push the current editor.innerHTML
    // onto an undo stack.
    window.saveProject();
    console.log("Element position/size saved to history (and Firestore).");
}





        window.initElements= function() {
            const elements = editor.querySelectorAll('.draggable-image, .floating-div');
            elements.forEach(el => initElement(el));
             editor.querySelectorAll('.draggable-image, .floating-div').forEach(window.initElementForMovement);
        }



/**
 * Displays a self-removing floating notification without Tailwind CSS.
 * @param {string} message - The message content.
 * @param {string} type - The type ('Info', 'Success', 'Error') to determine color.
 */
window.showModal = function(message, type = 'Info',target) {
    const modal = document.createElement('div');
    
    // 1. Determine background color based on type
    let bgColor;
    if (type === 'Error') {
        bgColor = '#dc2626'; // Red-600 equivalent
    } else if (type === 'Success') {
        bgColor = '#16a34a'; // Green-600 equivalent
    } else {
        bgColor = '#3b82f6'; // Blue-500 equivalent (Info)
    }

    // 2. Apply fixed positioning, styling, and color===OLD: right: 20px;
    modal.style.cssText = `
        position: fixed;
        top: 40px; /* Adjusted to 40px for better placement */
      right: 50vw;
        font-size:20px;
        padding: 12px 20px;
        border-radius: 8px;
        color: white;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        z-index: 9999;
        background-color: ${bgColor};
        opacity: 1; /* Start visible */
        transition: opacity 0.5s ease-out, transform 0.5s ease-out;
        transform: translateY(0);
        font-family: sans-serif;
    `;
    
    modal.textContent = `${type}: ${message}`;
    document.body.appendChild(modal);

    // 3. Set timeout to start fade-out transition after 3 seconds
    setTimeout(() => {
        // Start the transition (fade out and move up)
        modal.style.opacity = '0';
        modal.style.transform = 'translateY(-20px)';
        
        // 4. Remove the element from the DOM after the transition is complete (0.5s)
        setTimeout(() => modal.remove(), 500);
    }, 3000); // Wait 3 seconds before starting the fade-out
};


       //=====================================復原HTML檔案

        window.restore=function(command) {

	   if(command){
	    const mypages=document.getElementById('htmlPageCode').value;

	    tempHTML=mypages;
		window.showModal('temp HTML loades','Info');
           		 const pageName = document.getElementById('fname').value;
	   }

             const canvasElement = document.getElementById('drawingCanvas');
 	  
            document.getElementById('editor').innerHTML = document.getElementById('htmlPageCode').value;
	
	  
            editor.prepend(canvasElement);

             clearCanvas();
   
            window.initElements();
            window.updateEditButtonState();
            window.updateLockButtonState();

	 }


















/**
 * Sets the rotation of the active item based on an ABSOLUTE angle
 * provided by the range slider.
 * * @param {string|number} newAngle - The absolute angle (0 to 359).
 */
window.setRotation = function(newAngle) {
    if (!activeItem) return;
    
    // Ensure the input is treated as an integer (from the slider)
    const angle = parseInt(newAngle);

    // If you need the rotation to only apply to the visual element, 
    // you only need the last three lines.
    
    // 1. Update the MOVEMENT axis (for movement logic)
    activeItem.setAttribute('data-degree', angle); 
    
    // 2. Update the VISUAL rotation
    activeItem.setAttribute('data-visual-degree', angle); 
    
    // 3. Apply the visual rotation
    activeItem.style.transform = `rotate(${angle}deg)`;
}


// --- NEW: Element Direction and Movement Functions ---

/**
 * Extends the existing initElement function to ensure a degree attribute exists.
 * @param {HTMLElement} el The element to initialize.
 */
window.zzzzzzzzzzinitElementForMovement =function(el) {
    // Call your existing initialization logic first
    // For example: initElement(el); 

    if (!el.hasAttribute('data-degree')) {
        el.setAttribute('data-degree', '0'); // Start facing 0 degrees (Up/North by default)
    }
    // Apply initial rotation based on the attribute
    el.style.transform = `rotate(${el.getAttribute('data-degree')}deg)`;
}

//------##################        Game MoveMent   ###################################################----------

/**
 * Sets the direction (movement axis) of the active item without changing its visual rotation.
 * @param {number} degrees The absolute degree to face (e.g., 90 for East, 180 for South).
 */
 window.pointInDirection=function(degrees) {
    if (!activeItem) return;

    // Normalize degrees and update the movement axis attribute only.
    const normalizedDegrees = degrees % 360; 
    activeItem.setAttribute('data-degree', normalizedDegrees);
    
    // NO CSS rotation is applied here.
}

/**
 * Changes the direction (rotation) of the active item by a relative amount.
 * This function now explicitly handles the VISUAL rotation.
 * @param {number} changeDegrees The amount to turn.
 */
 window.turn=function(changeDegrees) {
    if (!activeItem) return;

    // A. Update the MOVEMENT axis (data-degree)
    let currentMovementDegree = parseInt(activeItem.getAttribute('data-degree')) || 0;
    let newMovementDegree = currentMovementDegree + changeDegrees;
    // Set the new axis for 'move forward'
    activeItem.setAttribute('data-degree', newMovementDegree); 
    
    // B. Update the VISUAL rotation (data-visual-degree)
    let currentVisualDegree = parseInt(activeItem.getAttribute('data-visual-degree')) || 0;
    let newVisualDegree = currentVisualDegree + changeDegrees;
    
    // Store the new visual rotation
    activeItem.setAttribute('data-visual-degree', newVisualDegree); 
    
    // Apply the visual rotation
    activeItem.style.transform = `rotate(${newVisualDegree}deg)`;
}

 window.moveSteps=function(steps) {
    if (!activeItem) return;

    const currentX = activeItem.offsetLeft;
    const currentY = activeItem.offsetTop;
    
    // CRITICAL: This uses the data-degree (the movement axis)
    const degree = parseInt(activeItem.getAttribute('data-degree')) || 0; 

    // Convert degrees to radians (90 is subtracted because 0 deg movement axis should face right/East)
    const radians = (degree - 90) * (Math.PI / 180); 

    // Calculate new position
    const newX = currentX + (steps * Math.cos(radians));
    const newY = currentY + (steps * Math.sin(radians));

    // Update the element's position
    activeItem.style.left = `${newX}px`;
    activeItem.style.top = `${newY}px`;
}




 window.initElementForMovement=function(el) {
    // Call your existing initialization logic first
    // For example: initElement(el); 
    
    // --- 1. MOVEMENT DEGREE (Axis for 'move forward') ---
    if (!el.hasAttribute('data-degree')) {
        // Always default the movement axis to 90 (Right/East) for new/legacy items
        el.setAttribute('data-degree', '90'); 
    }

    // --- 2. VISUAL DEGREE (The saved CSS rotation) ---
    
    // A. Check if the element already has a CSS rotation saved from the JSON/HTML
    let visualDegreeMatch = el.style.transform.match(/rotate\(([-+]?\d+)deg\)/);
    let initialVisualDegree = 0;
    
    if (visualDegreeMatch) {
        // If rotation is found in the CSS style, use it.
        initialVisualDegree = parseInt(visualDegreeMatch[1]);
    } else if (el.hasAttribute('data-visual-degree')) {
        // If no rotation in CSS but the attribute exists (a newly saved file), use the attribute.
        initialVisualDegree = parseInt(el.getAttribute('data-visual-degree'));
    }

    // B. Check the `data-visual-degree` attribute state (for untouched legacy files)
    if (!el.hasAttribute('data-visual-degree')) {
        // If the element is from an OLD, UNTOUCHED file (no attributes),
        // we set the visual degree to 0. This PREVENTS the 90-degree default rotation.
        el.setAttribute('data-visual-degree', '0'); 
        
        // CRITICAL: We also need to apply the initial visual state.
        // For old files with no rotation, the CSS transform is missing.
        // We set it to 0 to prevent the browser from assuming a default of 90.
        el.style.transform = `rotate(0deg)`;
        
    } else {
        // For new files or files that have been rotated and saved, ensure the visual degree
        // attribute matches the rotation applied from the saved HTML content's style.
        el.setAttribute('data-visual-degree', initialVisualDegree); 
        el.style.transform = `rotate(${initialVisualDegree}deg)`;
    }
}


/**
 * Moves the active item to a target position over a specified duration using an animation loop. (   animateGoToPosition)
 * @param {string} targetValue The target: 'x,y' string or 'center' or Element ID.
 * @param {number} durationSeconds The time (in seconds) the animation should take (e.g., 2 for 2 seconds).
 */
 window.glideTo=function(targetValue, durationSeconds) {
    if (!activeItem) {
        window.showModal('Please select an item to move first.', 'Warning');
        return;
    }

    // --- 1. Calculate Target Position (Same as before) ---
    let targetX, targetY;
    
    if (targetValue.includes(',')) {
        // Case 1: X,Y coordinate
        const parts = targetValue.split(',').map(n => parseInt(n.trim()));
        if (parts.length === 2 && !isNaN(parts[0]) && !isNaN(parts[1])) {
            targetX = parts[0];
            targetY = parts[1];
        } else {
            window.showModal('Invalid coordinate format. Use "X,Y" (e.g., 100, 50).', 'Error');
            return;
        }
    } else if (targetValue === 'center') {
        // Case 2: Center
        const editor = document.getElementById('editor');
        targetX = (editor.offsetWidth / 2) - (activeItem.offsetWidth / 2);
        targetY = (editor.offsetHeight / 2) - (activeItem.offsetHeight / 2);
    } else {
        // Case 3: Element ID
        const targetElement = document.getElementById(targetValue);
        if (!targetElement) {
            window.showModal(`Target element "${targetValue}" not found.`, 'Error');
            return;
        }
        targetX = targetElement.offsetLeft;
        targetY = targetElement.offsetTop;
    }

    // --- 2. Initialize Animation Variables ---
    const startX = activeItem.offsetLeft;
    const startY = activeItem.offsetTop;
    const durationMs = durationSeconds * 1000;
    let startTime;
    
    // Check if movement is even necessary
    if (startX === targetX && startY === targetY) return;

    // --- 3. The Animation Loop ---
     window.step=function(timestamp) {
        if (!startTime) {
            startTime = timestamp;
        }

        // Calculate time elapsed since start
        const elapsed = timestamp - startTime;

        // Calculate progress (0.0 to 1.0)
        let progress = elapsed / durationMs;

        // Clamp progress to a maximum of 1.0
        if (progress > 1) {
            progress = 1;
        }

        // Linear Interpolation (Lerp)
        // new_value = start_value + (end_value - start_value) * progress
        const currentX = startX + (targetX - startX) * progress;
        const currentY = startY + (targetY - startY) * progress;

        // Apply new position
        activeItem.style.left = `${currentX}px`;
        activeItem.style.top = `${currentY}px`;

        // If animation is not finished, request the next frame
        if (progress < 1) {
            window.requestAnimationFrame(step);
        }
    }

    // Start the animation
    window.requestAnimationFrame(step);
}





/**
 * Moves the activeItem to a specific (X, Y) position or the position of another selected element. ( goToPositionOrElement(targetValue) )
 * @param {string} targetValue The target: either 'x,y' string (e.g., '100,50') or the ID/index of another element.
 */
 window.goTo=function(targetValue) {
    if (!activeItem) {
        window.showModal('Please select an item to move first.', 'Warning');
        return;
    }

    let targetX, targetY;

    if (targetValue.includes(',')) {
        // Case 1: Target is an X,Y coordinate (e.g., '100,50')
        const parts = targetValue.split(',').map(n => parseInt(n.trim()));
        if (parts.length === 2 && !isNaN(parts[0]) && !isNaN(parts[1])) {
            targetX = parts[0];
            targetY = parts[1];
        } else {
            window.showModal('Invalid coordinate format. Use "X,Y" (e.g., 100, 50).', 'Error');
            return;
        }
    } else {
        // Case 2: Target is another element (e.g., an item ID or the special 'center' value)
        if (targetValue === 'center') {
            const editor = document.getElementById('editor');
            // Calculate the center of the editor minus half the size of the active item
            targetX = (editor.offsetWidth / 2) - (activeItem.offsetWidth / 2);
            targetY = (editor.offsetHeight / 2) - (activeItem.offsetHeight / 2);
        } else {
            // Target is another element's ID (or another unique identifier, if you use them)
            const targetElement = document.getElementById(targetValue);
            
            if (!targetElement) {
                // Try to find the element by class/name if ID wasn't set.
                // NOTE: Using a simple querySelectorAll may not be reliable in your complex setup.
                // A reliable way is to ensure all floating/draggable items have unique IDs.
                window.showModal(`Target element "${targetValue}" not found.`, 'Error');
                return;
            }

            // Get the target element's position
            targetX = targetElement.offsetLeft;
            targetY = targetElement.offsetTop;
        }
    }
    
    // Apply the movement
    activeItem.style.left = `${targetX}px`;
    activeItem.style.top = `${targetY}px`;
}


//-----------####################### End GameMovement#########################################-----------

//---------########################      Speech Game    ###################################------------------

/**
 * Starts the speech recognition process for the given word.
 * @param {string} word The word the user is expected to say.
 */
// Global variable to store the currently spoken word the user is aiming for


// NOTE: Assuming these variables are declared in the global or outer scope:
// let recognition = null;
// let requiredWord = '';

 window.startVoiceRecognition=function(word) {

    if (!('webkitSpeechRecognition' in window)) {
        window.showModal('Your browser does not support Web Speech Recognition.', 'Error');
        return;
    }

    // 1. CRITICAL SCOPE FIX: Declare the flag locally so the nested event handlers can use it.
    let resultProcessed = false; 

    // 2. Setup the recognition object
    recognition = new webkitSpeechRecognition();
    recognition.lang = 'en-US'; 
    recognition.interimResults = false;
    recognition.maxAlternatives = 1;
    
    // --- COMPARISON & DISPLAY LOGIC ---
    
    // 3. Display Word: Store the original word (e.g., "RED-APPLE") for the user prompt.
    const displayWord = word; 

    // 4. Comparison Data: Clean and store the final comparison string in the shared 'requiredWord' variable.
    // This removes punctuation and sets it to lowercase for the robust check.
    const tempRequiredWord = word.toLowerCase(); 
    requiredWord = tempRequiredWord
        .trim()
        .replace(/[.,\/#!$%\^&\*;:{}=\-_`~()]/g, "") 
        .replace(/\s{2,}/g, " "); 
    // requiredWord is now ready for comparison.

    // Update UI to show what's required and listening state
    document.getElementById('speechResult').textContent = `Say: "${displayWord}"`;
    document.getElementById('speechResult').className = 'text-lg font-bold text-blue-600';
    document.getElementById('speechResult').style.display = '';
    document.getElementById('voiceButton').textContent = '🗣️ Listening... Say it now!';
    document.getElementById('voiceButton').disabled = true;

    // --- ON RESULT HANDLER ---
    recognition.onresult = function(event) {
         resultProcessed = true; // Flag indicates a result was received
        
        const rawTranscript = event.results[0][0].transcript;
        
        // Clean the SPOKEN transcript for comparison
        const cleanedTranscript = rawTranscript
            .toLowerCase()
            .trim()
            .replace(/[.,\/#!$%\^&\*;:{}=\-_`~()]/g, "")
            .replace(/\s{2,}/g, " ");
        
        // Compare the aggressively cleaned strings
        // NOTE: The comparison uses the global/shared 'requiredWord'
        let isCorrect = (cleanedTranscript === requiredWord); 
        
        // Display result
       // document.getElementById('speechResult').textContent = `You said: "${cleanedTranscript}" `;
        
        if (isCorrect) {
            document.getElementById('speechResult').className = 'text-lg font-bold text-green-600';
      document.getElementById('speechResult').textContent = `✅ Correct!You said: "${cleanedTranscript}" `;
            window.showModal(`✅ Correct! You said: ${cleanedTranscript}`, 'Success');
	window.speakText(` Correct! You said: ${cleanedTranscript}`);
        } else {
            document.getElementById('speechResult').className = 'text-lg font-bold text-red-600';
      document.getElementById('speechResult').textContent = `❌ Incorrect. You said: "${cleanedTranscript}" `;
            //showModal(`❌ Incorrect. You said: ${cleanedTranscript}. Try again.`, 'Error');
                 window.speakText(` Incorrect. You said: ${cleanedTranscript}. Try again.`);
        }
    };

    // --- ON END HANDLER (Crucial for state reset) ---
    recognition.onend = function() {
        // Reset button state
        document.getElementById('voiceButton').textContent = '🎙️ ▶️ ';
        document.getElementById('voiceButton').disabled = false;
        
        // Check the flag: If resultProcessed is false, no speech was successfully captured.
        if (!resultProcessed) {
             document.getElementById('speechResult').textContent = '...沒有偵測到聲音 或 超過等待時間';
             document.getElementById('speechResult').className = 'text-lg font-bold text-gray-500';
        }
    };

     recognition.start();
}


 
/**
 * Asynchronously requests microphone access to force device selection.
 * This should be called before starting the Web Speech Recognition.
 * @returns {Promise<boolean>} True if access was granted and a stream opened.
 */
 window.ensureMicrophoneControl=async function() {
    try {
        // 1. Request access to the audio device only.
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        
        // 2. Access granted! Stop the stream immediately to release the device, 
        // but the browser/OS has now settled on the correct microphone.
        stream.getTracks().forEach(track => track.stop());
        
        return true;
    } catch (error) {
        // If the user denies permission, or no mic is found/working.
        console.error("Microphone access failed:", error);
        if (error.name === "NotAllowedError" || error.name === "PermissionDeniedError") {
            window.popBox("Microphone permission was denied. Please check your browser's site settings.", 'Error');
        } else {
            window.popBox("Could not access a microphone device. Please check your connections.", 'Error');
        }
        return false;
    }
}


/**
 * Finds all draggable images and starts the random recognition game.
 */
 window.startRandomVoiceGame= async function() {

// 💥 STEP 1: Ensure microphone access is secured 💥
    const micReady = await window.ensureMicrophoneControl();
    if (!micReady) {
        // Stop the function if access failed
       window.popBox('Mic is not ready','error');
        return; 
    }



    // 1. Find all potential target elements (draggable images and floating divs)
   // const possibleTargets = Array.from(document.getElementById('editor').querySelectorAll('.draggable-image, .floating-div'));
    const possibleTargets = Array.from(document.getElementById('editor').querySelectorAll('.draggable-image'));
    // 2. Filter elements that have a proper ID (which we'll use as the word)
    const candidates = possibleTargets.filter(el => el.id && el.id.trim() !== '');

    if (candidates.length === 0) {
        window.showModal('Please ensure your items have unique IDs (e.g., id="APPLE") to be part of the game.', 'Warning');
        document.getElementById('speechResult').textContent = 'No labeled items found.';
        return;
    }

    // 3. Select one candidate randomly
    const randomIndex = Math.floor(Math.random() * candidates.length);
    const selectedElement = candidates[randomIndex];
    
    // Use the ID as the word to be spoken
    const wordToSay = selectedElement.id;

    // Optional: Visually highlight the element that was chosen
    highlightElement(selectedElement);

    // 4. Start recognition for that word
    window.startVoiceRecognition(wordToSay);
}

/**
 * Simple function to highlight the target element.
 */
 window.highlightElement=function(el) {
    // Remove previous highlights
    document.getElementById('editor').querySelectorAll('.highlight-target').forEach(item => {
        item.classList.remove('highlight-target');
        item.style.border = 'none'; // Clear inline style if necessary
    });

    // Apply new highlight
    el.classList.add('highlight-target');
    el.style.border = '5px solid orange'; // Visible border highlight
    setTimeout(() => {
        el.style.border = 'none'; // Remove highlight after a moment
    }, 2000); 
}
//---------------##########################   End Speech Game     ################################################ 

         //頁面的題本傳到共用的測驗數據區供其他遊戲取用
  	 let quizSource=null;
 window.toggleGameTheme = function(theme, command) {
	//alert('old---textarea---'+document.querySelector('#quizData').innerText);
 	// alert('editor-----'+editor.querySelector('#quizArea').querySelector('#quizData').innerText);
        quizSource=editor.querySelector('#quizArea').querySelector('#quizData');
	//alert('source----'+quizSource.innerText);

         document.getElementById('quizData').innerText=quizSource.innerText;
	//alert('new---textarea---'+document.getElementById('quizData').innerText);

let cleanQuizText = document.getElementById('quizData').innerHTML.replace(/<br\s*\/?>/gi, '\n'); 
        

 //document.getElementById('question-bank-input').value=document.getElementById('quizData').innerHTML;
 document.getElementById('question-bank-input').value=cleanQuizText;


 //document.getElementById('question-bank-input').innerText=document.getElementById('quizData').innerText;
 //alert('source:-------'+document.getElementById('quizData').innerText);
// alert('target---'+document.getElementById('question-bank-input').innerText);
  
 document.getElementById('gamebody').style.display='';

        if (!theme){ return;}

              document.getElementById('cannonGame').classList.add('hidden');
                 
        if (theme== 'none') {
              document.getElementById('gamebody').style.display='none';
              document.getElementById('cannonGame').classList.add('hidden');	
            return;
         }

        if (theme === 'flasher') {
               //alert('target---'+document.getElementById('question-bank-panel').innerText);
                document.getElementById('gamebody').style.display='';                 
              document.getElementById('cannonGame').classList.add('hidden');

        }
        if (theme === 'dual') {
 document.getElementById('gamebody').style.display='none';
	window.dual_startGame();
               document.getElementById('cannonGame').classList.remove('hidden');
                document.getElementById('gamebody').style.display='none';	
        }     
        if (theme === 'quiz') { 
	       window.parsePsvAndLoadQuiz(editor.querySelector('#quizArea'));
                //launchWrapper.style.display = 'none';
              // appContainer.style.display = 'none';
             // dualGameContainer.style.display = 'none';
              document.getElementById('gamebody').style.display='none';
              document.getElementById('cannonGame').classList.add('hidden');
		//return;
        }       
    }







//---------------##########################  測驗狀態管理     ################################################### 
    // 測驗狀態管理
    let quizData = [];
    let currentQuestionIndex = 0;
    //let score = 0;
    let isAnswered = false;
    let timerInterval = null; 
    let incorrectAnswers = []; 

 	//let quizDataElementX=document.getElementById('quizArea').querySelector('#quizData');

 

    window.createQuizFloatingDiv = function(color) {
        const textDiv = document.createElement('div');
        textDiv.className = 'floating-div quiz-instance'; 
        textDiv.style.left = `${lastClickPos.x}px`;
        textDiv.style.top = `${lastClickPos.y}px`;
        textDiv.setAttribute('contenteditable', 'false'); 
        textDiv.style.backgroundColor = color;
        textDiv.style.borderRadius = '16px'; 
        textDiv.style.padding = '5px';
        textDiv.style.minWidth = '300px'; 
        textDiv.style.cursor = 'grab'; 

        textDiv.innerHTML = window.getQuizUIHTML();
        
        editor.appendChild(textDiv);
        
        window.toggleEditMode(textDiv.querySelector('#quizArea'), true); 
        window.initElement(textDiv); 
    };

    window.initElement = function(element) {
        element.addEventListener('mousedown', (e) => {
            const isInteractive = e.target.closest('#quizData') || e.target.closest('.option-button') || e.target.closest('button');
            if (isInteractive) {
                element.style.cursor = 'default';
                return;
            } else {
                 element.style.cursor = 'grab';
            }
            // ... 您的拖動邏輯 ...
        });
    };













    /**
     * @brief 核心 UI 結構
     */
    window.getQuizUIHTML = function() {
        const htmlArray = [
            '<div id="quizArea" class="quiz-container flex flex-col items-center justify-center bg-white  rounded-lg " style="z-index:50" >',
             '<button style="position:absolute;top:-10px;left:-20px;width:40px;height:40px;z-index:10;border-radius:25px;background-color:red;color:white" onclick="document.getElementById(\'editor\').querySelector(\'#edit_view\').style.display=(document.getElementById(\'editor\').querySelector(\'#edit_view\').style.display==\'none\')?\'\':\'none\';document.getElementById(\'quizToolBar\').style.display=(document.getElementById(\'quizToolBar\').style.display==\'\')?\'none\':\'\';showModal(\'測驗遊戲按鈕顯示於工具列\',\'\')" >❔</button>',
            // --- 編輯數據模式 (Edit View) ---
            '<div id="edit_view" class="w-full" style="display: none;">',
             '<h2 style="color:orange;font-size:16pt;padding-left:30px">            編輯測驗題目 </h2>',
            // 修正：答案索引提示為 1-4
            '<p class="text-sm text-gray-600 mb-3 text-left font-bold"> 題號|問題(含圖片)|正確答案索引(1-4)|選項A|選項B|選項C|選項D (換行:shift+Enter，支援試算表貼上)</p>',
            
            // 新增按鈕群組
            '<div class="flex space-x-2 mb-3">',
            '<button onclick="window.insertImageTag(this.closest(\'#quizArea\'))" class="flex-1 px-2 py-2 text-white bg-orange-500 rounded-lg hover:bg-orange-600 transition duration-150">🖼️ 插入圖片標籤</button>',
            '<button onclick="window.copyPsvToClipboard();document.getElementById(\'quizDataSource\').value=document.getElementById(\'quizData\').value" class="flex-1 px-2 py-2 text-white bg-green-600 rounded-lg hover:bg-green-700 transition duration-150">📋 複製測驗數據</button>',
            '</div>',

            '<div ',
            'id="quizData" ',
            'contenteditable="true" ',
            'onpaste="window.handlePastedData(event)"', 
            'class="w-full border border-gray-300 p-2 rounded-lg mb-4 focus:ring-blue-500 focus:border-blue-500"',
            'style="min-height: 200px; cursor: text; text-align: left;"',
            '>',
            // 預設數據使用垂直線分隔，以供參考，答案索引已改為 1 (代表選項 A)
            "1|Which fruit is red?|1|apple|banana|guava|orang" +
            "<br>2|Who's she？|2|my brother|my sister|Mr.Bean|my pen" +
            "<br>3|Where's my bag？<img src='https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTZf50Vs-UpWo_OfaGbqQbe_a1rhdfQ9zMqeg&s' style='max-height: 50px; display: inline-block; border-radius: 4px; vertical-align: middle;'>|2|on the desk|on the bed|in the box|under the table",
            '</div>',
            
            "    <button onclick=\"window.parsePsvAndLoadQuiz(this.closest('#quizArea'))\" class=\"w-full px-4 py-2 text-white bg-blue-600 rounded-lg hover:bg-blue-700\">載入並開始測驗</button>",
  '<div class="flex space-x-2 mb-3">',
//" <button onclick=\"window.toggleGameTheme('quiz');\">❓</button>",
"<button id=\"toggleQuizBtn\"  title=\"打氣球測驗\" class=\"flex-1 px-2 py-2 text-white bg-orange-500 rounded-lg hover:bg-orange-600 transition duration-150\" onclick=\"window.toggleGameTheme('slasher');window.QS_launchGame(document.getElementById('quizArea'),'slasher');window.QS_parseAndLoadQuiz(document.getElementById('quizArea'),'slasher');\"   >🎈打氣球遊戲</button>",
"<button id=\"startGameButton\" title=\"雙打測驗\" class=\"flex-1 px-2 py-2 text-white bg-orange-500 rounded-lg hover:bg-orange-600 transition duration-150\" onclick=\"window.toggleGameTheme('dual');\">🤼雙打射擊</button>", 
            '</div>',

          
            '<p id="errorMsg" class="text-red-500 mt-3 hidden">數據格式錯誤。</p>',
            '</div>',

            // --- 測驗顯示模式 (Quiz View) ---
            '<div id="quiz_view" class="w-full" style="display: none;">',
            //'<h3 class="text-3xl font-bold mb-4 text-blue-600">互動式測驗</h3>',


            '<div class="text-left mb-6">',
            '<p class="text-gray-600 mb-2"><span class="text-2xl font-extrabold mb-4 text-red-600" id="timerDisplay" style="margin-left:20px;display:inline">15s</span>',
            '問題 <span id="currentQIndex" class="font-bold">0</span> / <span id="totalQuestions" class="font-bold">0</span></p>',
            '<div class="w-full bg-gray-200 rounded-full h-2.5"><div id="progress" class="bg-blue-600 h-2.5 rounded-full" style="width: 0%"></div></div>',
            '</div>',

            '<div class="bg-blue-50 p-6 rounded-lg mb-6 shadow-md min-h-[150px] flex flex-col justify-center text-left">',
            '<div class="flex justify-between items-start mb-2">',
            '<p class="text-xl font-medium text-gray-800" id="questionText"   style="font-size:45px" >點擊「編輯數據」按鈕載入測驗</p>',
            " <button onclick=\"window.speakQuestion(this.closest('#quizArea'))\" class=\"text-2xl ml-3 text-blue-500 hover:text-blue-700 transition\">🔊</button>",

            '</div>',
            '</div>',

            '<div id="optionsContainer" class="space-y-3" style="font-size:35px" ></div>',
            
            '<div class="mt-6 flex justify-between space-x-4">',
            " <button id=\"editButton\" onclick=\"window.toggleEditMode(this.closest('#quizArea'), true)\" class=\"px-4 py-2 text-md font-semibold text-white bg-gray-600 rounded-xl hover:bg-gray-700 transition duration-150\">編輯數據</button>",
            " <button id=\"nextButton\" onclick=\"window.nextQuestion(this.closest('#quizArea'))\" class=\"hidden px-6 py-3 text-lg font-semibold text-white bg-green-600 rounded-xl hover:bg-green-700 transition duration-150 shadow-lg shadow-green-500/50\">下一題</button>",
            '</div>',
            '</div>',
            '</div>'
        ];
        return htmlArray.join('\n');
    };
    
    // =========================================================================
    // IMAGE INSERT FUNCTION (FIXED with Selection API)
    // =========================================================================
    
    /**
     * @brief 提示用戶輸入圖片 URL 並插入標準化的 <img> 標籤到光標位置。
     * 使用 Selection API 確保精確插入和替換選區。
     */
    window.insertImageTag = function(quizArea) {
         const quizDataElement = quizArea.querySelector('#quizData');
        if (!quizDataElement) return;

        quizDataElement.focus(); // 確保元素獲得焦點

        const selection = window.getSelection();
        
        if (selection.rangeCount === 0 || !quizDataElement.contains(selection.anchorNode)) {
            // 如果沒有選區或選區不在 quizData 內，將光標設置到內容末尾
            const range = document.createRange();
            range.selectNodeContents(quizDataElement);
            range.collapse(false); // 塌陷到末尾
            selection.removeAllRanges();
            selection.addRange(range);
        }
        
        // 此時 selection 內一定有一個有效的 range
        const range = selection.getRangeAt(0);

        const url = prompt("請輸入圖片的 URL 地址 (例如: https://placehold.co/50x50):");
        if (!url) {
            window.popBox('圖片 URL 為空，已取消操作。', '取消');
            return;
        }

        const alt = prompt("請輸入圖片的簡短描述 (Alt Text):", "圖例");
        
        // 創建一個帶有 inline style 的標準化 <img ...> 標籤
        const imgHtml = `<img src='${url}' alt='${alt}' style='max-height: 50px; display: inline-block; border-radius: 4px; vertical-align: middle;'>`;

        // 1. 創建臨時 div 來解析 HTML 字符串
        const tempDiv = document.createElement('span');
        tempDiv.innerHTML = imgHtml;
        const fragment = document.createDocumentFragment();
        while (tempDiv.firstChild) {
            fragment.appendChild(tempDiv.firstChild);
        }

        // 2. 刪除選區內容 (這將替換任何選中的文本或元素)
        range.deleteContents(); 
        
        // 3. 插入新的節點
        range.insertNode(fragment);

        // 4. 將光標移動到插入內容之後
        selection.collapseToEnd();

        window.showModal('圖片標籤已成功插入到光標位置。', '圖片插入成功');
    };
    
    // =========================================================================
    // PASTE HANDLING FUNCTION
    // =========================================================================

    window.handlePastedData = function(event) {
        event.preventDefault();

        const text = event.clipboardData.getData('text/plain');
        const targetElement = event.target;

        let processedText = text.replace(/\t/g, '|');
        processedText = processedText.replace(/(\r\n|\n|\r)/g, '<br>');

        // 這裡我們仍然使用 innerHTML/execCommand 配合定位，因為貼上大量數據時效率更高
        targetElement.innerHTML = ''; 
        targetElement.focus();        
        document.execCommand('insertHTML', false, processedText);
        
        const selection = window.getSelection();
        const range = document.createRange();
        range.selectNodeContents(targetElement);
        range.collapse(false);
        selection.removeAllRanges();
        selection.addRange(range);

        window.showModal('試算表數據已貼上並轉換為 | 垂直線分隔格式。', '貼上成功');
    };

    // =========================================================================
    // QUIZ LOGIC (FIXED INDEXING)
    // =========================================================================

    window.speakQuestion = function(quizArea) {
        if ('speechSynthesis' in window) {
            const questionTextElement = quizArea.querySelector('#questionText');
            if (!questionTextElement) return;

            const textToSpeak = window.convertHtmlToText(questionTextElement.innerHTML);
            
            if (!textToSpeak) return;

            window.speechSynthesis.cancel(); 

            const utterance = new SpeechSynthesisUtterance(textToSpeak);
            
            const voices = window.speechSynthesis.getVoices();
            const zhVoice = voices.find(voice => voice.lang === 'zh-TW' || voice.lang === 'zh-CN');
            if (zhVoice) {
                utterance.voice = zhVoice;
            } else {
                utterance.lang = 'zh-TW'; 
            }
            
            utterance.rate = 1.0; 
            utterance.pitch = 1.0;

            window.speechSynthesis.speak(utterance);
        } else {
            window.popBox("您的瀏覽器不支持語音合成 (TTS) 功能。", "TTS 錯誤");
        }
    };

    window.popBox = function(content, title = '通知') {
        const modalTitle = document.getElementById('modalTitle');
        const modalBody = document.getElementById('modalBody');
        const modalOverlay = document.getElementById('modalOverlay');

        if (modalTitle) modalTitle.textContent = title;
        if (modalBody) modalBody.innerHTML = content;
        if (modalOverlay) modalOverlay.classList.remove('hidden');
    };

    window.toggleEditMode = function(quizArea, showEdit) {
        if (!quizArea) return;
        window.stopTimer(); 
        window.speechSynthesis.cancel(); 

        const editView = quizArea.querySelector('#edit_view');
        const quizView = quizArea.querySelector('#quiz_view');
        
        if (showEdit) {
            if (editView) editView.style.display = 'block';
            if (quizView) quizView.style.display = 'none';
        } else {
            if (editView) editView.style.display = 'none';
            if (quizView) quizView.style.display = 'block';
            window.renderQuestion(quizArea); 
        }
    };
    
    window.stopTimer = function() {
        if (timerInterval) {
            clearInterval(timerInterval);
            timerInterval = null;
        }
    };

    window.handleTimeout = function(quizArea) {
        window.stopTimer();
        window.speechSynthesis.cancel(); 
        const q = quizData[currentQuestionIndex];
        
        if (q && !isAnswered) { 
            isAnswered = true;
            
            incorrectAnswers.push({
                question: q.question, 
                correctAnswer: q.options[q.correctIndex] 
            });

            const correctText = q.options[q.correctIndex];
            const questionTextElement = quizArea.querySelector('#questionText');
            if (questionTextElement) questionTextElement.innerHTML = '時間到！這題的正確答案是：' + correctText;
            
            const optionsContainer = quizArea.querySelector('#optionsContainer');
            if (optionsContainer) {
                optionsContainer.querySelectorAll('button').forEach(btn => {
                    btn.disabled = true;
                    btn.classList.remove('hover:bg-blue-100');
                });
            }

            const nextButton = quizArea.querySelector('#nextButton');
            if (nextButton) nextButton.classList.remove('hidden');

            window.popBox('時間到！這題的答案是：' + window.convertHtmlToText(correctText), '自動跳過');
        }
    };
       
    window.startTimer = function(quizArea) {
        window.stopTimer(); 
        let timeLeft = 15;
        const timerDisplay = quizArea.querySelector('#timerDisplay');
        if (timerDisplay) timerDisplay.textContent = `${timeLeft}s`;

        timerInterval = setInterval(() => {
            timeLeft--;
            if (timerDisplay) timerDisplay.textContent = `${timeLeft}s`;

            if (timeLeft <= 0) {
                window.handleTimeout(quizArea);
            }
        }, 1000);
    };

                         let lines='';
			 
    window.parsePsvAndLoadQuiz = function(quizArea) {
         const quizDataElement = quizArea.querySelector('#quizData');
        const errorMsgElement = quizArea.querySelector('#errorMsg');
        document.getElementById('quizData').value=quizDataElement.innerHTML;
//alert('parsing:'+quizDataElement.innerHTML);
document.getElementById('quizArea').querySelector('#quizData').innerText=quizDataElement.innerText.trim();
//alert('DOM Xtextarea value:'+document.getElementById('quizArea').querySelector('#quizData').innerText);
        const rawHtmlText = quizDataElement.innerHTML.trim(); 
        let cleanedText = rawHtmlText.replace(/<br\s*\/?>/gi, '\n'); 
        cleanedText = cleanedText.replace(/<\/?(p|div|span)[^>]*>/gi, '\n');
        cleanedText = cleanedText.replace(/\s*\n\s*/g, '\n').trim();

          lines = cleanedText.split('\n').filter(line => line.trim() !== '');
 
        let validQuestions = [];
        let parsingError = false;
        let errorLine = -1;

        lines.forEach((line, index) => {
            const parts = line.split('|').map(part => part.trim()); 

            if (parts.length !== 7) { 
                errorLine = index + 1; 
                parsingError = true; 
                return; 
            }

            // 修正：從 1-based 索引開始解析 (1 到 4)
            const correctIndex1Based = parseInt(parts[2].trim()); 

            if (isNaN(correctIndex1Based) || correctIndex1Based < 1 || correctIndex1Based > 4) {
                 errorLine = index + 1; 
                 parsingError = true; 
                 return;
            }
            
            // 轉換為 0-based 索引供內部使用 (0 到 3)
            const correctIndex0Based = correctIndex1Based - 1; 

            validQuestions.push({
                id: parseInt(parts[0].trim()),
                question: parts[1].trim(),
                correctIndex: correctIndex0Based, 
                options: [parts[3].trim(), parts[4].trim(), parts[5].trim(), parts[6].trim()]
            });
        });
        
        if (parsingError || validQuestions.length === 0) {
            if (errorMsgElement) errorMsgElement.classList.remove('hidden');
            // 修正：更新錯誤訊息以反映 1-4 索引
            let message = '數據格式錯誤。請檢查每行是否有 **7 個欄位**，並以 **`|` 垂直線** 分隔，且正確答案索引在 **1-4 範圍內 (1=A, 4=D)**。';
            if (errorLine !== -1) { message = '**第 ' + errorLine + ' 行** 數據欄位數不正確或答案索引無效。請修正該行。'; }
            window.popBox(message, '解析錯誤');
            return;
        }
//alert(JSON.stringify(validQuestions));
        quizData = window.shuffleArray(validQuestions); 
        currentQuestionIndex = 0;
        score = 0;
        isAnswered = false;
        incorrectAnswers = []; 
        
        const totalQuestions = quizArea.querySelector('#totalQuestions');
        if (totalQuestions) totalQuestions.textContent = quizData.length;
        if (errorMsgElement) errorMsgElement.classList.add('hidden');
        
        window.toggleEditMode(quizArea, false); 
    };
    
    window.renderQuestion = function(quizArea) {
        window.stopTimer(); 
        window.speechSynthesis.cancel(); 

        if (currentQuestionIndex >= quizData.length) {
            window.showScore(quizArea);
            return;
        }

        const q = quizData[currentQuestionIndex];
        isAnswered = false;
        
        const nextButton = quizArea.querySelector('#nextButton');
        const questionText = quizArea.querySelector('#questionText');
        const currentQIndex = quizArea.querySelector('#currentQIndex');
        const progress = quizArea.querySelector('#progress');
        const optionsContainer = quizArea.querySelector('#optionsContainer');
        
        if (nextButton) nextButton.classList.add('hidden');
        
        const displayQuestion = q.question.trim() || "問題文本遺失或格式錯誤。";

        if (questionText) questionText.innerHTML = q.id + '. ' + displayQuestion;
        
        if (currentQIndex) currentQIndex.textContent = currentQuestionIndex + 1;
        
        const progressPercent = ((currentQuestionIndex) / quizData.length) * 100;
        if (progress) progress.style.width = `${progressPercent}%`;

        if (optionsContainer) optionsContainer.innerHTML = '';
        
        const optionLabels = ['A', 'B', 'C', 'D'];

        let optionsWithStatus = q.options.map((text, originalIndex) => ({
            text: text,
            isCorrect: originalIndex === q.correctIndex
        }));

        const shuffledOptions = window.shuffleArray(optionsWithStatus);
        
        shuffledOptions.forEach((option, index) => {
            const button = document.createElement('button');
            button.className = 'option-button w-full text-left p-4 rounded-lg bg-gray-100 hover:bg-blue-100 text-gray-800 font-medium shadow-sm';
            
            const optionText = option.text.trim() || "此選項數據遺失";
            
            const renderedOption = '<span class="font-bold mr-3">' + optionLabels[index] + '.</span> ' + optionText;
            
            button.innerHTML = renderedOption;
            
            button.onclick = () => window.checkAnswer(option.isCorrect, button, optionsContainer, shuffledOptions, quizArea);
            
            if (optionsContainer) optionsContainer.appendChild(button);
        });

        window.startTimer(quizArea); 
    };

    window.checkAnswer = function(isCorrect, button, container, shuffledOptions, quizArea) {
        if (isAnswered) return;
        isAnswered = true;
        window.stopTimer(); 
        window.speechSynthesis.cancel(); 

        const buttons = container.querySelectorAll('button');
        
        buttons.forEach(btn => {
            btn.disabled = true;
            btn.classList.remove('hover:bg-blue-100');
            btn.style.cursor = 'default';
        });

        if (isCorrect) {
            score++;
            button.classList.remove('bg-gray-100', 'hover:bg-blue-100');
            button.classList.add('bg-green-500', 'text-white', 'font-extrabold', 'ring-4', 'ring-green-400');
        } else {
            button.classList.remove('bg-gray-100', 'hover:bg-blue-100');
            button.classList.add('bg-red-500', 'text-white', 'font-extrabold', 'ring-4', 'ring-red-400');

            const q = quizData[currentQuestionIndex];
            incorrectAnswers.push({
                question: q.question,
                correctAnswer: q.options[q.correctIndex]
            });

            const correctOption = shuffledOptions.find(opt => opt.isCorrect);
            
            const correctOptionHtml = correctOption.text;
            
            const correctButton = Array.from(buttons).find(btn => btn.innerHTML.includes(correctOptionHtml));
            
            if (correctButton) {
                correctButton.classList.remove('bg-gray-100', 'hover:bg-blue-100');
                correctButton.classList.add('bg-green-200', 'text-green-800', 'border-4', 'border-dashed', 'border-green-600');
            }
        }

        const nextButton = quizArea.querySelector('#nextButton');
        if (nextButton) nextButton.classList.remove('hidden');
    };

    window.nextQuestion = function(quizArea) {
        currentQuestionIndex++;
        window.renderQuestion(quizArea);
    };
    
    /**
     * @brief 顯示最終分數
     */
    window.showScore = function(quizArea) {
        window.stopTimer(); 
        const total = quizData.length;
        
        const progress = quizArea.querySelector('#progress');
        const currentQIndex = quizArea.querySelector('#currentQIndex');
        const nextButton = quizArea.querySelector('#nextButton');
        const questionText = quizArea.querySelector('#questionText');
        const optionsContainer = quizArea.querySelector('#optionsContainer');
        
        const finalProgress = 100;
        if (progress) progress.style.width = `${finalProgress}%`;
        if (currentQIndex) currentQIndex.textContent = total;
        
        if (nextButton) nextButton.classList.add('hidden');
        if (questionText) questionText.textContent = `測驗完成！`;

        let reviewHTML = '';
        if (incorrectAnswers.length > 0) {
            reviewHTML += '<h4 class="text-xl font-bold mt-6 mb-3 text-red-600">❌ 錯題回顧:</h4>';
            reviewHTML += '<div class="space-y-4 text-left">';
            incorrectAnswers.forEach((item, index) => {
                reviewHTML += `<div class="p-3 bg-red-50 rounded-lg border border-red-200">`;
                
                const reviewQuestion = item.question;
                reviewHTML += '<p class="font-semibold text-gray-800">Q' + (index + 1) + ': ' + reviewQuestion + '</p>';
                
                const reviewAnswer = item.correctAnswer;
                reviewHTML += '<p class="text-sm text-green-700 mt-1">✓ 正確答案: ' + reviewAnswer + '</p>';
                reviewHTML += '</div>';
            });
            reviewHTML += '</div>';
        } else {
             reviewHTML += '<div class="text-2xl font-extrabold text-green-700 mt-4 mb-4">🎉 全部答對！表現優異！</div>';
        }
        
        if (optionsContainer) {
            optionsContainer.innerHTML = [
                '<div class="text-3xl font-extrabold text-blue-600 mt-4 mb-4">最終分數: ' + score + ' / ' + total + '</div>',
                '<div class="text-2xl font-bold text-gray-700 mb-6">得分率: ' + (((score / total) * 100).toFixed(1)) + '%</div>',
                reviewHTML
            ].join('\n');
        }
    };
    
    // =========================================================================
    // UTILITY FUNCTIONS 
    // =========================================================================
    
    window.shuffleArray = function(array) {
        let currentIndex = array.length, randomIndex;
        while (currentIndex != 0) {
            randomIndex = Math.floor(Math.random() * currentIndex);
            currentIndex--;
            [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
        }
        return array;
    };
    
    window.convertHtmlToText = function(htmlString) {
        const tempDiv = document.createElement('div');
        const cleanHtml = htmlString.replace(/<img[^>]*>/gi, '');
        tempDiv.innerHTML = cleanHtml;
        return tempDiv.textContent || tempDiv.innerText || '';
    };

    window.copyPsvToClipboard = function() {
        const quizDataElement = document.getElementById('quizData');

        if (!quizDataElement) return;

        try {
            const rawHtmlText = quizDataElement.innerHTML.trim(); 
            let cleanedText = rawHtmlText
                .replace(/<br\s*\/?>/gi, '\n')
                .replace(/<\/?(div|p|span)[^>]*>/gi, '\n') 
                .replace(/\s*\n\s*/g, '\n')
                .trim();

            const tempInput = document.createElement('textarea');
            tempInput.value = cleanedText;
            document.body.appendChild(tempInput);
            tempInput.select(tempInput);

            let success = false;
            try {
                success = document.execCommand('copy');
            } catch (err) {
                console.error('execCommand failed:', err);
            }
            document.body.removeChild(tempInput);

            if (success) {
                 window.showModal('測驗數據（垂直線分隔格式）已複製到剪貼簿！', '複製成功');
            } else {
                 window.popBox('無法自動複製，請手動選取並複製內容。', '複製失敗');
            }

        } catch (err) {
            console.error('Failed to copy text: ', err);
            window.popBox('無法自動複製，請手動選取並複製內容。', '複製失敗');
        }
document.getElementById('quizDataSource').value=rawHtmlText;
    };
    
    // =========================================================================
    // UTILITY FUNCTIONS 
    // =========================================================================
    
    window.shuffleArray = function(array) {
        let currentIndex = array.length, randomIndex;
        while (currentIndex != 0) {
            randomIndex = Math.floor(Math.random() * currentIndex);
            currentIndex--;
            [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
        }
        return array;
    };
    
    window.convertHtmlToText = function(htmlString) {
        const tempDiv = document.createElement('div');
        const cleanHtml = htmlString.replace(/<img[^>]*>/gi, '');
        tempDiv.innerHTML = cleanHtml;
        return tempDiv.textContent || tempDiv.innerText || '';
    };

    window.copyPsvToClipboard = function() {
        const quizDataElement = document.getElementById('quizData');
        if (!quizDataElement) return;

        try {
            const rawHtmlText = quizDataElement.innerHTML.trim(); 
            let cleanedText = rawHtmlText
                .replace(/<br\s*\/?>/gi, '\n')
                .replace(/<\/?(div|p|span)[^>]*>/gi, '\n') 
                .replace(/\s*\n\s*/g, '\n')
                .trim();

            const tempInput = document.createElement('textarea');
            tempInput.value = cleanedText;
            document.body.appendChild(tempInput);
            tempInput.select();
            
            let success = false;
            try {
                success = document.execCommand('copy');
            } catch (err) {
                console.error('execCommand failed:', err);
            }
            document.body.removeChild(tempInput);

            if (success) {
                 window.showModal('測驗數據（垂直線分隔格式）已複製到剪貼簿！', '複製成功');
            } else {
                 window.popBox('無法自動複製，請手動選取並複製內容。', '複製失敗');
            }

        } catch (err) {
            console.error('Failed to copy text: ', err);
            window.popBox('無法自動複製，請手動選取並複製內容。', '複製失敗');
        }
    };



//=========================================================== Dual player Game


//=========================================================== Start Cannon Game



        // --- 全域變數和常數 (已更新前綴) ---
        const dualGameCanvas = document.getElementById('game-canvas');
        const dualGameCtx = dualGameCanvas.getContext('2d'); 
        const dual_WIDTH = dualGameCanvas.width;
        const dual_HEIGHT = dualGameCanvas.height;
        const dual_GROUND_Y = dual_HEIGHT - 50;
        const dual_GRAVITY = 0.05; 

        let dual_QUIZ_DATA = [];
        let dual_MAX_ROUNDS = 0; 
        
        let dual_gameActive = false; 
        let dual_currentPlayer = 2; 
        let dual_bullet = null;

        let dual_roundNumber = 0; 
        let dual_currentQuizCorrectIndex = -1; // 0-based index
        
        let dual_targets = []; 

        const dual_players = {
            1: { 
                id: 1, 
                x: 50, 
                y: dual_GROUND_Y, 
                angleDeg: 45, 
                score: 0, 
                color: '#f87171' // Red
            },
            2: { 
                id: 2, 
                x: dual_WIDTH - 50, 
                y: dual_GROUND_Y, 
                angleDeg: 135, 
                score: 0, 
                color: '#34d399' // Green
            }
        };

        const dual_BULLET_RADIUS = 5;
        const dual_MUZZLE_VELOCITY = 13;
        
        // --- 核心函數 (已更新前綴) ---

        /**
         * 簡單的陣列亂序函數 (Shuffling)
         */
        function dual_shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        /**
         * 核心解析函數：從 #quizData 元素中提取並結構化測驗資料。
         * @returns {Array<Object>} 結構化後的測驗題目陣列。
         */
        function dual_getQuizDataArray() {
            const quizDataElement = document.getElementById('quizData');
            if (!quizDataElement) {
                console.error("Quiz data element not found.");
                return [];
            }
            
            let externalQuizSet = [];
            
            try {
                const rawHtmlText = quizDataElement.innerHTML.trim();
                
                let cleanedText = rawHtmlText.replace(/<br\s*\/?>/gi, '\n'); 
                cleanedText = cleanedText.replace(/<\/?(p|div|span)[^>]*>/gi, '\n'); 
                cleanedText = cleanedText.replace(/\s*\n\s*/g, '\n').trim(); 

                const lines = cleanedText.split('\n').filter(line => line.trim() !== '');

                externalQuizSet = lines.map((item, index) => {
                    const parts = item.split('|').map(p => p.trim());
                    
                    if (parts.length < 7) { 
                        console.warn(`Skipping malformed quiz item at line ${index + 1}. Expected minimum 7 parts, got ${parts.length}. Data:`, item);
                        return null;
                    }
                    
                    const correctIndex1Based = parseInt(parts[2]);
                    
                    if (isNaN(correctIndex1Based) || correctIndex1Based < 1 || correctIndex1Based > 4) {
                        console.error(`Invalid correct index for item ID ${parts[0]} on line ${index + 1}: ${parts[2]}. Must be 1, 2, 3, or 4.`);
                        return null;
                    }
                    
                    return {
                        id: parts[0],
                        question: parts[1],
                        correctIndex: correctIndex1Based - 1, 
                        options: [parts[3], parts[4], parts[5], parts[6]] 
                    };
                }).filter(q => q !== null);
                
                return externalQuizSet;

            } catch(e) {
                console.error("CRITICAL QUIZ PARSING ERROR:", e);
                return [];
            }
        }

        /**
         * 載入測驗資料 (使用核心解析函數)
         */
        function dual_loadQuizData() {
            dual_QUIZ_DATA = dual_getQuizDataArray();

            if (dual_QUIZ_DATA.length > 0) {
                 dual_shuffleArray(dual_QUIZ_DATA); 
            }

            dual_MAX_ROUNDS = dual_QUIZ_DATA.length * 2;
            console.log(`Quiz data loaded. Total questions: ${dual_QUIZ_DATA.length}. Total rounds: ${dual_MAX_ROUNDS}`);
        }

        window.dual_startGame = function() {
            dual_loadQuizData();

            if (dual_QUIZ_DATA.length === 0) {
                 document.getElementById('start-screen').classList.add('hidden');
                 document.getElementById('game-elements').classList.remove('hidden');
                 document.getElementById('game-status').innerHTML = '<span class="text-red-400">🚨 錯誤：無法載入測驗資料！請檢查 #quizData 的格式是否正確。</span>';
                 document.getElementById('question-text').textContent = '';
                 return;
            }
            
            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('game-elements').classList.remove('hidden');

            // --- 新增: 重置分數狀態和 DOM 顯示 ---
            dual_players[1].score = 0;
            dual_players[2].score = 0;
            document.getElementById('score-p1').textContent = 0;
            document.getElementById('score-p2').textContent = 0;
            // ------------------------------------

            dual_gameActive = true;
            
            document.getElementById('angle-slider-p2').value = dual_players[2].angleDeg;
            document.getElementById('angle-p1').textContent = dual_players[1].angleDeg;
            document.getElementById('angle-p2').textContent = dual_players[2].angleDeg;
            
            dual_roundNumber = 0; 
            dual_switchTurn(); 

            dual_gameLoop();
        }

        // --- 測驗/目標函式 (已更新前綴) ---

        function dual_setupTargets() {
            // FIX: 統一索引計算 (使用 (roundNumber - 1) / 2)
            const questionIndex = Math.floor((dual_roundNumber - 1) / 2); 
            
            if (questionIndex >= dual_QUIZ_DATA.length) return; 
            
            const question = dual_QUIZ_DATA[questionIndex];
            dual_targets = []; // 每次設置新問題時都清空
            
            const TARGET_WIDTH = 360;
            const TARGET_HEIGHT = 90;
            const SPACING = 15;
            
            dual_currentQuizCorrectIndex = question.correctIndex; 

            const totalHeight = question.options.length * TARGET_HEIGHT + (question.options.length - 1) * SPACING;
            let currentY = dual_HEIGHT / 2 - totalHeight / 2; 

            question.options.forEach((optionText, index) => {
                const x = dual_WIDTH / 2 - TARGET_WIDTH / 2;
                const y = currentY;
                dual_targets.push({
                    x: x,
                    y: y,
                    width: TARGET_WIDTH,
                    height: TARGET_HEIGHT,
                    text: `${index + 1}. ${optionText}`,
                    isCorrect: index === dual_currentQuizCorrectIndex,
                    hit: false
                });
                currentY += TARGET_HEIGHT + SPACING; 
            });
        }

        function dual_drawTargets() {
            dual_targets.forEach(target => {
              //  dualGameCtx.fillStyle = target.hit ? '#ef4444' : (target.isCorrect ? 'lime' : '#ef4444'); 
               //dualGameCtx.fillStyle = target.hit ? '#ef4444' :  '#3b82f6'; 
               dualGameCtx.fillStyle = target.hit ? 'lime' :  'cyan'; 
                dualGameCtx.fillRect(target.x, target.y, target.width, target.height);
                
                dualGameCtx.fillStyle = target.hit ? 'green' : 'black';
                dualGameCtx.font = '30px Inter';
                dualGameCtx.textAlign = 'center';
                dualGameCtx.textBaseline = 'middle';
                dualGameCtx.fillText(target.text, target.x + target.width / 2, target.y + target.height / 2);

                dualGameCtx.strokeStyle = '#1f2937';
                dualGameCtx.lineWidth = 1;
                dualGameCtx.strokeRect(target.x, target.y, target.width, target.height);
            });
        }


        function dual_displayQuestionAndEnableFire() {
            const questionIndex = Math.floor((dual_roundNumber - 1) / 2);
            if (questionIndex >= dual_QUIZ_DATA.length) return; 

            const question = dual_QUIZ_DATA[questionIndex];

            const statusText = document.getElementById('game-status');
            const questionText = document.getElementById('question-text');

            statusText.textContent = `回合 ${dual_roundNumber}/${dual_MAX_ROUNDS} - 🎯 輪到玩家 ${dual_currentPlayer}：請射擊正確答案方塊！`;
            // 每次都更新問題文字
            questionText.textContent = `問題 ${question.id}: ${question.question}`;
            
            // FIX: 僅在靶子陣列為空時（新問題回合開始時）才設定靶子
            if (dual_targets.length === 0) {
                 dual_setupTargets(); 
            }
            
            document.getElementById('fire-btn-p1').disabled = (dual_currentPlayer !== 1);
            document.getElementById('fire-btn-p2').disabled = (dual_currentPlayer !== 2);
            document.getElementById('angle-slider-p1').disabled = (dual_currentPlayer !== 1);
            document.getElementById('angle-slider-p2').disabled = (dual_currentPlayer !== 2);
        }

        function dual_showResults() {
            document.getElementById('fire-btn-p1').disabled = true;
            document.getElementById('fire-btn-p2').disabled = true;
            document.getElementById('angle-slider-p1').disabled = true;
            document.getElementById('angle-slider-p2').disabled = true;
            
            const p1Score = dual_players[1].score;
            const p2Score = dual_players[2].score;
            let resultMessage = "";

            if (p1Score > p2Score) {
                resultMessage = `🎉 恭喜玩家 1 (紅方) 獲勝！分數：${p1Score} vs ${p2Score}`;
            } else if (p2Score > p1Score) {
                resultMessage = `🎉 恭喜玩家 2 (綠方) 獲勝！分數：${p2Score} vs ${p1Score}`;
            } else {
                resultMessage = `🤝 遊戲平手！雙方分數都是 ${p1Score}。`;
            }
            
            document.getElementById('game-status').innerHTML = `<span class="text-2xl">${resultMessage}</span>`;
            document.getElementById('question-text').textContent = "遊戲已結束。請重新載入頁面開始新遊戲。";
            
            dual_targets = []; 
        }

        function dual_switchTurn() {
            dual_roundNumber++;

            if (dual_roundNumber > dual_MAX_ROUNDS) {
                dual_gameActive = false;
                dual_showResults();
                return;
            }
            
            dual_currentPlayer = (dual_roundNumber % 2 !== 0) ? 1 : 2;
            
            // 只有在 P1 啟動一個新測驗項目時，才清空靶子
            if (dual_roundNumber % 2 !== 0 && dual_roundNumber > 1) {
                dual_targets = [];
                dual_currentQuizCorrectIndex = -1;
            }
            
            dual_displayQuestionAndEnableFire();
        }

        // --- 遊戲物理與繪圖函式 (已更新前綴) ---

        const dual_toRadians = (degrees) => degrees * (Math.PI / 180);

        window.dual_updateAngle = function(playerId, value) {
            const angle = parseInt(value);
            dual_players[playerId].angleDeg = angle;
            document.getElementById(`angle-p${playerId}`).textContent = angle;
        }

        window.dual_fireBullet = function(playerId) {
            const player = dual_players[playerId];
            if (!dual_gameActive || playerId !== dual_currentPlayer || dual_bullet) {
                return;
            }

            const angleRad = dual_toRadians(player.angleDeg);
            const barrelLength = 30;
            
            const startX = player.x + barrelLength * Math.cos(angleRad);
            const startY = player.y - barrelLength * Math.sin(angleRad);

            const vx = dual_MUZZLE_VELOCITY * Math.cos(angleRad);
            const vy = -dual_MUZZLE_VELOCITY * Math.sin(angleRad);

            dual_bullet = {
                x: startX,
                y: startY,
                vx: vx,
                vy: vy,
                player: playerId,
                color: player.color
            };
            
            document.getElementById('fire-btn-p1').disabled = true;
            document.getElementById('fire-btn-p2').disabled = true;
            document.getElementById('angle-slider-p1').disabled = true;
            document.getElementById('angle-slider-p2').disabled = true;
            document.getElementById('game-status').textContent = `玩家 ${playerId} 發射了！`;
        }

        function dual_drawGround() {
            dualGameCtx.fillStyle = '#4F9D28';
            dualGameCtx.fillRect(0, dual_GROUND_Y, dual_WIDTH, dual_HEIGHT - dual_GROUND_Y);
        }

        function dual_drawCannon(player) {
            dualGameCtx.fillStyle = player.color;
            dualGameCtx.beginPath();
            dualGameCtx.fillRect(player.x - 15, player.y - 10, 30, 10);
            dualGameCtx.arc(player.x, player.y, 10, 0, Math.PI * 2);
            dualGameCtx.fill();

            const angleRad = dual_toRadians(player.angleDeg);
            const barrelLength = 30;
            const barrelWidth = 6;
            
            dualGameCtx.save();
            dualGameCtx.translate(player.x, player.y);
            dualGameCtx.fillStyle = player.color;
            
            if (player.id === 1) {
                dualGameCtx.rotate(-angleRad); 
                dualGameCtx.fillRect(0, -barrelWidth / 2, barrelLength, barrelWidth);
            } else {
                const visualAngleFromLeft = Math.PI - angleRad; 
                dualGameCtx.rotate(visualAngleFromLeft); 
                dualGameCtx.fillRect(-barrelLength, -barrelWidth / 2, barrelLength, barrelWidth);
            }
            
            dualGameCtx.restore();
        }

        function dual_drawBullet() {
            if (dual_bullet) {
                dualGameCtx.fillStyle = dual_bullet.color;
                dualGameCtx.beginPath();
                dualGameCtx.arc(dual_bullet.x, dual_bullet.y, dual_BULLET_RADIUS, 0, Math.PI * 2);
                dualGameCtx.fill();
            }
        }

        function dual_updateBullet() {
            if (!dual_bullet) return;

            dual_bullet.x += dual_bullet.vx;
            dual_bullet.y += dual_bullet.vy;
            dual_bullet.vy += dual_GRAVITY;

            // 檢查命中目標
            if (dual_targets.length > 0) {
                for (let i = 0; i < dual_targets.length; i++) {
                    const target = dual_targets[i];
                    
                    if (
                        dual_bullet.x > target.x &&
                        dual_bullet.x < target.x + target.width &&
                        dual_bullet.y > target.y &&
                        dual_bullet.y < target.y + target.height
                    ) {
                        target.hit = true; 
                        const hitCorrect = target.isCorrect;
                        
                        if (hitCorrect) {
                            dual_players[dual_bullet.player].score++;
                            document.getElementById(`score-p${dual_bullet.player}`).textContent = dual_players[dual_bullet.player].score;
                            document.getElementById('game-status').textContent = `🏆 完美！玩家 ${dual_bullet.player} 擊中正確答案！`;
                        } else {
                            document.getElementById('game-status').textContent = `❌ 擊中錯誤答案 "${target.text}"，無得分。`;
                        }
                        
                        dual_bullet = null;
                        setTimeout(() => dual_switchTurn(), 2000); 
                        return;
                    }
                }
            }

            // 落地或越界處理
            if (dual_bullet.y + dual_BULLET_RADIUS >= dual_GROUND_Y || dual_bullet.x < -10 || dual_bullet.x > dual_WIDTH + 10) {
                if (dual_bullet) { 
                    document.getElementById('game-status').textContent = `玩家 ${dual_currentPlayer} 射失了！`;
                }
                dual_bullet = null;
                setTimeout(() => dual_switchTurn(), 2000); 
                return;
            }
        }

        /**
         * 主要遊戲迴圈。
         */
        function dual_gameLoop() {
            dualGameCtx.clearRect(0, 0, dual_WIDTH, dual_HEIGHT);
            
            dual_drawGround();
            dual_drawCannon(dual_players[1]);
            dual_drawCannon(dual_players[2]);
            dual_drawTargets(); 

            if (dual_bullet) { 
                dual_updateBullet();
            }
            dual_drawBullet();

            if (dual_gameActive) {
                requestAnimationFrame(dual_gameLoop);
            }
        }






//================================================================End Cannon Game
//============================================================End Dual player Game
//==========================================Random Number




    // 全域變數用於儲存號碼狀態
    let MAX_NUMBER = 30; 
    let availableNumbers = [];
    let pickedNumbers = [];
    let isFlipping = false; // Prevent multiple clicks during animation
 
    // =========================================================================
    // MODAL AND SPEECH FUNCTIONS (Used for non-alert communication)
    // =========================================================================

    window.popMSG = function(content, title = '通知') {

        document.getElementById('modalTitle').textContent = title;
        document.getElementById('modalBody').textContent = content;
        document.getElementById('modalOverlay').classList.remove('hidden');
    }



    // =========================================================================
    // PICKER LOGIC
    // =========================================================================

    window.initializeNumbers = function() {
	let r=parseInt(document.getElementById('maxClassNumber').value);
        	 MAX_NUMBER=r;
           // showModal(r,'');
        availableNumbers = [];
        pickedNumbers = [];

        for (let i = 1; i <= MAX_NUMBER; i++) {
            availableNumbers.push(i);

        }
        updateDisplay();
        document.getElementById('pickBtn').disabled = false;
        document.getElementById('pickBtn').textContent = '抽號碼';
        // Ensure card starts on the front side
        document.getElementById('flipper').classList.remove('is-flipped');
        document.getElementById('resultDisplay').textContent = '';
        console.log("號碼池已重置。");
    }

    function updateDisplay() {
        const listElement = document.getElementById('pickedList');
        const countElement = document.getElementById('countDisplay');
        
        listElement.innerHTML = pickedNumbers
            .sort((a, b) => a - b)
            .map(num => `<span class="px-2 py-1 bg-green-100 text-green-800 rounded-full text-xs font-semibold">${num}</span>`)
            .join('');

        countElement.textContent = pickedNumbers.length;
        	MAX_NUMBER=parseInt(document.getElementById('maxClassNumber').value);
        if (pickedNumbers.length === MAX_NUMBER) {
            document.getElementById('pickBtn').disabled = true;
            document.getElementById('pickBtn').textContent = '號碼已抽完';
            // Do not update resultDisplay here to allow '完' to show on the card back
        }
    }

    window.pickNumber = function() {
        if (availableNumbers.length === 0 || isFlipping) {
            if (availableNumbers.length === 0) {
                window.popMSG('所有號碼已抽出。請重置號碼池。', '提示');
                window.speakText('所有號碼已抽出。');
            }
            return;
        }
        
        // 1. Reset card to front side if it was flipped
        const flipper = document.getElementById('flipper');
        
        if (flipper.classList.contains('is-flipped')) {
            // If already flipped, reset to front quickly, then draw
            flipper.classList.remove('is-flipped');
            // Use a short delay before drawing the number
            setTimeout(() => drawAndFlip(), 500); 
        } else {
            drawAndFlip();
        }
    }

    function drawAndFlip() {
        isFlipping = true;
        
        // 1. Get Draw Number
        const randomIndex = Math.floor(Math.random() * availableNumbers.length);
        const drawNumber = availableNumbers[randomIndex];
        availableNumbers.splice(randomIndex, 1);
        pickedNumbers.push(drawNumber);

        // 2. Prepare the back of the card with the new number
        document.getElementById('resultDisplay').textContent = drawNumber;

        // 3. Perform the flip (will show the back side)
        document.getElementById('flipper').classList.add('is-flipped');
        
        const speechText = `抽到 ${drawNumber} 號，請上台`;

        // 4. Wait for animation, then show modal and speak
        setTimeout(() => {
            window.speakText(speechText);
            //window.popMSG(drawNumber + ' 號', '抽中的是');
            updateDisplay();
            isFlipping = false;
        }, 850); // Delay slightly longer than CSS transition time (0.8s)
    }

    window.resetPicker = function() {
        window.initializeNumbers();
        document.getElementById('flipper').classList.remove('is-flipped');
        window.popMSG('號碼池已重置，現在可以重新抽籤了！', '重置成功');
    }

    document.addEventListener('DOMContentLoaded', window.initializeNumbers);

    if ('speechSynthesis' in window) {
        window.speechSynthesis.onvoiceschanged = () => {
            console.log("語音列表已載入。");
        };
    }








//=======================================End Random Number
//===============================  core logic =================================================================
        window.initElement = function(element) {
            let resizer = element.querySelector('.resizer');
            if (!resizer) {
                resizer = document.createElement('div');
                resizer.className = 'resizer';
                element.appendChild(resizer);
            }
            
            if (!element.style.zIndex || parseInt(element.style.zIndex) < 10) {
                element.style.zIndex = '10'; 
            }

            if (element.classList.contains('floating-div') && element.getAttribute('contenteditable') !== 'true') {
                element.setAttribute('contenteditable', 'false');
            }

        }















        window.pageNav = function() {
           
            const div1 = document.getElementById("pagelist");
            const pagex = div1.getElementsByTagName("a");
            const num = pagex.length;
            const Currentpage=document.getElementById("fname").value;
            const cpn=Currentpage.substr(0,Currentpage.lastIndexOf('.'));
            let x=0;
            let navbar ="";
            for (i=0;i<num;i++){
                if (cpn==pagex[i].innerText){
                    x=i;
                    navbar ="<div id=\"pager\" style=\"display:inline;position:relative;border:1px solid blue;background:white;width:40px;height:25px;padding:10px;cursor:hand\" onclick=\"document.getElementById('pagelist').style.display=(document.getElementById('pagelist').style.display=='none')?'':'none';\" >P"+i+"頁</div>";
                }
            }
            if(x>0){
                navbar ="<button onclick=\"window.location.href='"+pagex[x-1].href+"';\"><font size=6 >⬅️</font></button>"+navbar;
            }
            if(x<pagex.length-1){
                navbar += "<button onclick=\"window.location.href='"+pagex[x+1].href+"';\"><font size=6 >➡️</font></button>";
            }
            document.getElementById("Navi").innerHTML=navbar;
        }

        window.PicNav = function() {
            // *** PASTE YOUR FULL window.PicNav FUNCTION BODY HERE ***
            const items = document.querySelectorAll('.draggable-image');
            const titles = document.querySelectorAll('.floating-div, locked');
            titles.forEach( title  =>{title.classList.toggle('hidden');});

            if(null==document.getElementById('Flashcards')){
                
                let piclist='<img id=\"previewx\" src=\"'+items[0].style.backgroundImage.substring(5,items[0].style.backgroundImage.length-2)+'\" style=\"width:auto;height:400px\" ><div id=\"picTitle\" style=\"display: none\" >'+items[0].id+'</div><BR>';

                items.forEach((item, i) => {
                    piclist +='<img id=\"p_'+i+'\" style=\"display:none\" src=\"'+items[i].style.backgroundImage.substring(5,items[i].style.backgroundImage.length-2)+'\" width=\"400px\" height=\"auto\" >';
                    item.style.display=(item.style.display=='none')?'':'none';
                });
                
                const buttonx='<button onclick=\"window.showPic(\'Previous\')\" style=\"width:100px;font-size:50px\" >⬅️ </button><div id=\"picCount\" style=\"display:inline;border:2px solid black;minWidth:120px;font-size:40px\" >01</div><button  onclick=\"window.showPic(\'Next\')\"  style=\"width:100px;font-size:50px\">➡️</button><button onclick=\"window.showPic(\'random\')\" title=\"隨機\"  > 🎲</button><HR><button onclick=\"window.SlidePic(\'Next\')\" title=\"自動播放\"  > ▶️</button><button onclick=\"window.SlidePic(\'stop\')\" title=\"停止播放\"  > ⏹️</button><button onclick=\"window.SlidePic(\'random\')\" title=\"隨機播放\"  > 🔀</button><button onclick=\"window.exitFlash();\" title=\"離開\"  > ❎</button>';
                const tts=`<BR><button onclick="window.speakText(document.getElementById('picTitle').innerText)" title="唸讀" style="width:200px;font-size:50px;background:yellow;border:4px solid black" > 🔊</button> <HR><button style="width:100px;font-size:20px;background: ;border:2px dotted black;padding:4px"><input id="mute" type="checkbox"     ><BR>靜音</button> <button style="width:100px;font-size:20px;background: ;border:2px dotted black;padding:4px"><input id="picInfomation" type="checkbox"    checked><BR>中文</button>`;
                
                const textDiv = document.createElement('div');
                textDiv.className = 'p-4 bg-white shadow-lg rounded-xl'; 
                textDiv.style.position = 'absolute';
                textDiv.style.left = '50px';
                textDiv.style.top = '20px';
                textDiv.style.width = '95%'; 
                textDiv.style.height = '95%'; 
                textDiv.id='Flashcards';
                textDiv.style.display='';
                textDiv.style.backgroundColor = 'white';
                textDiv.style.border ='solid gray 4px'; 
                textDiv.style.padding = '10px';
                textDiv.style.minWidth = '500px'; 
                textDiv.style.fontSize = '30pt'; 
                
                textDiv.innerHTML ='<div id=\"picZone\" style=\"width:70%;height:90%;border:2px dashed gray;float:left;display: grid ;place-content: center\" ><span id=\"picTitle\" style=\"display:none;align-item:center;font-size:120px\" >====</span>'+piclist+'</div><div style=\"width:30%;height:90%;border:2px dashed gray;padding:10px;float:right\" >'+buttonx+tts+'</div>';               
                document.getElementById('editor').appendChild(textDiv);
            }else{
                document.getElementById('Flashcards').style.display='none'; 
                items.forEach((item, i) => {
                    item.style.display='';
                });
                document.getElementById('Flashcards').remove();
            }
            window.showPic('Previous');
        }

        let flag=true;
        window.showPic = function(way){
            // *** PASTE YOUR FULL window.showPic FUNCTION BODY HERE ***
            const items = document.querySelectorAll('.draggable-image');
            let num=items.length;
            flag=!flag;
        
            if(flag==true && counter< num ){
                document.getElementById('previewx').style.display='';
                if(way=='Next' && counter<(items.length-1)){
                    counter +=1;	
                }
                if(way=='Previous' && counter>0){
                    counter -=1;
                }
                if(way=='random'){
                    counter = Math.floor( Math.random() * num );
                }
                if(items[counter].classList.contains('locked')){counter+=1;flag=true;}
                document.getElementById('previewx').src=items[counter].style.backgroundImage.substring(5,items[counter].style.backgroundImage.length-2);
                document.getElementById('picCount').innerText=counter;
                document.getElementById('picTitle').style.display='none';
                document.getElementById('picTitle').innerText=items[counter].id;
                document.getElementById('previewx').style.display='';
            }
            
            if(flag==false && counter< num ){
                let banner=document.getElementById('picTitle');
                let picInfo='';
                if(items[counter].id && document.getElementById('picInfomation').checked==true){
                    picInfo= items[counter].innerText;	    	   
                }
                if(items[counter].id){
                    banner.innerHTML=items[counter].id+'<br><font style=\"font-size:50px;line-height:20%;\" >'+picInfo.replace(/(?:\r\n|\r|\n)/g, '<br>')+'</font>';
                }else{
                    banner.innerText='請幫圖片輸入ID名稱';
                }
                banner.style.display='';
                document.getElementById('previewx').style.display='none';
            }
            if(items[counter].id){ 
                if(document.getElementById('mute').checked==false){
                      
                window.speakText(items[counter].id); 
	} 
            }
        }

        window.exitFlash = function(){
            // *** PASTE YOUR FULL window.exitFlash FUNCTION BODY HERE ***
            document.getElementById('Flashcards').style.display='none';
         
            window.PicNav(); 
        }
            
        window.SlidePic = function(action){

            if(action=='stop'){
             showModal(myinterval,'action');
                clearInterval(myinterval);
                window.clearInterval(myinterval);

            }
            else{
                counter=0;
                  myinterval =setInterval(() => {
                    window.showPic(action); 
                }, 3000);
            }

        }
//================================================   人工語音 =========================

       window.toggleSpeak = function(){
	speaking=!speaking;
	if(!speaking){speakBtn.textContent=  '🔈';}else{speakBtn.textContent= '🔇' ;}
        }

        window.speakText = function(textToSpeak) {
            if(speaking==false){return;}
		   let seed=Math.floor(Math.random()*2);
		   let lan=4;
		if (textToSpeak.charCodeAt() > 255) {

		   //showModal('Chinese',seed);

		   lan=seed;
		}else{
		  if(textToSpeak.substring(0,1)=='*'){lan=5}else{lan=4;}
		  //lan=4;
		}
            if ('speechSynthesis' in window) {
                //const textToSpeak = document.getElementById('textInput').value;
                const utterance = new SpeechSynthesisUtterance(textToSpeak);

                // Optional: Customize properties   5:en-US   female    6:UK-GB Female 7 :en-UK-GB-Male   1國女~2國男:zh-TW
                utterance.lang = 'en-US';
                utterance.pitch = 1;
                utterance.rate = 0.8;
                utterance.volume = 1;
		// To select a specific voice:
		  const voices = speechSynthesis.getVoices();
 		 utterance.voice = voices[lan]; // Choose a voice from the available list   4:en-US   female 5:en-GB  male 5:en-GB   1~3:zh-TW
                speechSynthesis.speak(utterance);
            } else {
                alert("Your browser does not support Web Speech API.");
            }
 
	//Text to speech-----------https://developer.mozilla.org/en-US/docs/Web/API/SpeechSynthesis/getVoices
        }

        const synth = window.speechSynthesis;
       // const statusEl = document.getElementById('status-message');

        window.stopSpeaking = function() {
            if (synth.speaking || synth.pending) {
                synth.cancel();
               // statusEl.textContent = "Status: Speech stopped manually.";
            } else {
                // statusEl.textContent = "Status: Not currently speaking.";
            }
           // updateButtonState(false);
        }




  window.SimplepickNumber= function(){
      const drawNumber=Math.floor(Math.random()*30);
      speakText('抽到'+drawNumber+'號，請上台');
      showModal(drawNumber,'抽中的是');
 }

   window.dartMode = function() {
            gameMode = !gameMode;
          const ebtn = document.getElementById('dartModeBtn');

            if (gameMode) {
                ebtn.textContent = 'stop🎯';
	window.speakText('get'+window.randomItem());
            }else{
                ebtn.textContent = ' 🎯';	
          }
     }

        window.toggleGameMode = function() {
            // *** PASTE YOUR FULL window.toggleGameMode FUNCTION BODY HERE ***
            gameMode = !gameMode;
            window.restore();
            const btn = document.getElementById('toggleGameModeBtn');
            
            if (gameMode) {
                btn.textContent = '🛑 🎮';
                btn.className = 'px-4 py-2 bg-red-600 text-white font-semibold rounded-lg hover:bg-red-700 transition duration-150 shadow-md';
                
                window.startGameTimer(GAME_DURATION_SECONDS);
                window.startContinuousAnimation();
                console.log("Game Mode ON");
document.getElementById('tmBar').style.display='';
            } else {
                if (gameTimerInterval !== null) {
                    clearInterval(gameTimerInterval);
                    gameTimerInterval = null;

                }
                
                btn.textContent = '▶️ 🎮';
                btn.className = 'px-4 py-2 bg-green-500 text-white font-semibold rounded-lg hover:bg-green-600 transition duration-150 shadow-md';
                
                window.updateTimerDisplay(GAME_DURATION_SECONDS);
                console.log("Game Mode OFF");
document.getElementById('tmBar').style.display='none';
            }
        }
        
        // --- Game Helper Functions (Existing) ---

        window.updateTimerDisplay = function(totalSeconds) {
             const minutes = Math.floor(totalSeconds / 60);
             const seconds = totalSeconds % 60;
             const timeString = `${minutes}:${seconds.toString().padStart(2, '0')}`;
             document.getElementById('gameTimerDisplay').textContent = timeString;
        }

        window.startGameTimer = function(durationSeconds) {
             let timeLeft = durationSeconds;
             window.updateTimerDisplay(timeLeft);
             score=0;
             quizCount=0;
             document.getElementById('speechResult').style.display='none';
             if (gameTimerInterval !== null) {
                 clearInterval(gameTimerInterval);
             }

             gameTimerInterval = setInterval(() => {
                 timeLeft--;
                 window.updateTimerDisplay(timeLeft);

                 if (timeLeft <= 0) {
                     clearInterval(gameTimerInterval);
                     gameTimerInterval = null;
                     window.updateTimerDisplay(0);
                     
                     if (gameMode) {
                         window.toggleGameMode();
                         document.getElementById('speechResult').style.display='';
                         document.getElementById('speechResult').innerHTML="<font color=red >Time's up!</font> ------- sore:"+Math.floor((score/quizCount)*100)+'-----'+score+'/'+(quizCount-1);
                             score=0;quizCount=0;
                     }
                 }
             }, 1000); 
        }

        window.animateAllRandomly = function(durationSeconds) {
     const editor = document.getElementById('editor');
    const targets = editor.querySelectorAll('.draggable-image');
   //const targets = editor.querySelectorAll('.draggable-image, .floating-div');

    if (targets.length === 0) {
        return Promise.resolve(); // Nothing to animate, resolve immediately
    }

    const editorWidth = editor.offsetWidth;
    const editorHeight = editor.offsetHeight;
    const durationMs = durationSeconds * 1000;

    let itemsToComplete = targets.length;
    
    // Create a new Promise that will resolve when all items are done moving
    return new Promise(resolve => {
        targets.forEach(item => {
            // --- Generate Random Target Coordinates (same as before) ---
            const maxRandX = Math.max(0, editorWidth - item.offsetWidth);
            const maxRandY = Math.max(0, editorHeight - item.offsetHeight);

            const targetX = Math.floor(Math.random() * maxRandX);
            const targetY = Math.floor(Math.random() * maxRandY);

            // --- Animation Variables ---
            const startX = item.offsetLeft;
            const startY = item.offsetTop;
            let startTime;

            // Define a completion callback
            const onComplete = () => {
                itemsToComplete--;
                if (itemsToComplete === 0) {
                    resolve(); // All items have finished this cycle
                }
            };

            // If item is already at target, resolve its cycle immediately
            if (startX === targetX && startY === targetY) {
                onComplete();
                return;
            }

            // --- The Animation Loop (step function) ---
            function step(timestamp) {
                if (!startTime) {
                    startTime = timestamp;
                }

                const elapsed = timestamp - startTime;
                let progress = elapsed / durationMs;


                if (progress >= 1) {
                    progress = 1;
                    // Ensure the item lands exactly on the target coordinates
                    item.style.left = `${targetX}px`;
                    item.style.top = `${targetY}px`;
                    onComplete(); // Mark this item as complete
                    return;
                }

                // Linear Interpolation
                const currentX = startX + (targetX - startX) * progress;
                const currentY = startY + (targetY - startY) * progress;

                item.style.left = `${currentX}px`;
                item.style.top = `${currentY}px`;

                // Continue the animation loop
                requestAnimationFrame(step);
            }

            requestAnimationFrame(step);
        });
    });

        }
        
        let isAnimationRunning = false; 
        window.startContinuousAnimation = async function() {
    if (isAnimationRunning) return; // Already running
    isAnimationRunning = true;

    // Use a duration between 1.5 and 2.5 seconds for a fluid, continuous motion
    const DURATION = 2; 

    // Loop continues as long as the gameMode flag is true
    while (gameMode) {
        // Wait for ALL items to finish their current random movement
        await animateAllRandomly(DURATION);

        // Optional: Add a brief pause between cycles for effect (e.g., 200ms)
        await new Promise(r => setTimeout(r, 200)); 
    }
    
    isAnimationRunning = false;
    console.log("Continuous animation stopped.");

        }


        // --- Final Utility Functions (Existing) ---

        window.checkOverlap = function(item) {
            // *** PASTE YOUR FULL window.checkOverlap FUNCTION BODY HERE ***
            const itemRect = item.getBoundingClientRect();
            const items = document.querySelectorAll('.draggable-image, .floating-div');
            
            items.forEach(otherItem => {
                if (otherItem !== item) {
                    const otherRect = otherItem.getBoundingClientRect();
                    if (!(itemRect.right < otherRect.left || itemRect.left > otherRect.right || 
                          itemRect.bottom < otherRect.top || itemRect.top > otherRect.bottom)) {
                        //console.log('Overlap detected!');
                        if(!otherItem.classList.contains('locked') && window.checkMode==true){
                            window.handleOverlap(otherItem);
                        }
                    }
                }
            });
        }

        window.handleOverlap = function(otherItem) {
            // *** PASTE YOUR FULL window.handleOverlap FUNCTION BODY HERE ***
            let ch=activeItem.id+"-a";
            if(otherItem.id==ch){
                otherItem.classList.add('opacity-50', 'animate-bounce');
                otherItem.classList.toggle('locked');
                if(otherItem.classList.contains('draggable-image')){
                    otherItem.innerHTML="<span style=\"text-align:center;verticle-align:center;color:red\" >答對了~</div>";
                }
            }
        }

        window.updateBackground = function() {
            // *** PASTE YOUR FULL window.updateBackground FUNCTION BODY HERE ***
            const imageUrl = document.getElementById('Xurl').value;
            if (activeItem) {
                activeItem.style.backgroundImage = `url('${imageUrl}')`;
            }
        }


    window.flip=function(){
        //activeItem.style.transform='perspective: 1000px';
      //activeItem.style.transform='transform-style:preserve-3d';
     if(activeItem.style.transform=='rotateY(180deg)'){
       activeItem.style.transform='rotateY(0deg)';
     }else{
       activeItem.style.transform='rotateY(180deg)';
       popBox(activeItem.style.transform,'');
     }
       popBox(activeItem.style.transform,'');
    }

//========================================================全螢幕相關處理================[involves draw(e)]======================================
                //let isFullScreen =false;

 window.FullScreen=function(){
   isFullScreen = !isFullScreen;

   if(isFullScreen){
	let element = document.body; // Or any other element
	//let element = document.getElementById('screen'); // Or any other element main-toolbar

             element.requestFullscreen()

            .then(() => {
                   console.log('Fullscreen mode entered successfully.');
		if(!window.DesignMode){
		//document.getElementById('main-toolbar').classList.add('hidden');
		//document.getElementById('page-manager').classList.add('hidden');
		document.getElementById('main-toolbar').style.display='none';
		document.getElementById('page-manager').style.display='none';
		}
                 })
                  .catch((error) => {
                console.error('Error entering fullscreen mode:', error);
                 });

  }
  else
  {
	
	document.exitFullscreen()

                 .then(() => {
                        console.log('Fullscreen mode exited successfully.');
		         if(!window.DesignMode){
		          //document.getElementById('main-toolbar').classList.remove('hidden');
		          //document.getElementById('page-manager').classList.remove('hidden');
		         document.getElementById('main-toolbar').style.display='';
		         document.getElementById('page-manager').style.display='';
		         }
                                  })
                  .catch((error) => {
                       console.error('Error exiting fullscreen mode:', error);
                    });
    }

}




function panEditor(container, editor, deltaX, deltaY, zoomFactor) {
  // 1. Convert the pan amount (delta) from *screen pixels* to *editor-content pixels*.
  // The actual scroll distance needs to be adjusted by the inverse of the zoom factor.
  const scrollDeltaX = deltaX / zoomFactor;
  const scrollDeltaY = deltaY / zoomFactor;

  // 2. Apply the change to the container's scroll position.
  container.scrollLeft += scrollDeltaX;
  container.scrollTop += scrollDeltaY;

  // Optional: Add listeners for mouse-drag/touch events to calculate deltaX/Y
  // and call this function repeatedly for smooth panning.
}

function getUnscaledEditorCoordinates(editor, container, clientX, clientY, zoomFactor) {
  // 1. Get the bounding rectangle of the editor (gives position in viewport)
  const rect = editor.getBoundingClientRect();

  // 2. Calculate the position relative to the *top-left of the scaled editor*
  //    (This is the mouse position *inside* the scaled editor element)
  const editorX = clientX - rect.left;
  const editorY = clientY - rect.top;

  // 3. Convert the relative position back to *unscaled content coordinates*
  //    by dividing by the zoom factor.
  const unscaledX = editorX / zoomFactor;
  const unscaledY = editorY / zoomFactor;

  // 4. Factor in the container's scroll offset.
  //    The canvas position should be based on the unscaled coordinates,
  //    but the actual drawing should be positioned relative to the container's scroll
  //    *if* the canvas is absolutely positioned within the container.
  
  // NOTE: For overlay canvas, it is usually fixed to the viewport,
  // so you only need the unscaled position to calculate where to draw.

  // The *drawing coordinates* on the canvas will also need to be scaled
  // if the canvas itself is NOT scaled, but the editor IS.

  // The final, most useful value for plotting points on the unscaled editor content:
  return {
    x: unscaledX + container.scrollLeft,
    y: unscaledY + container.scrollTop
  };
}



/**
 * Toggles the pan mode on/off.
 */
window.togglePanMode = function() {
    isPanModeActive = !isPanModeActive;
    const btn = document.getElementById('pan-toggle-btn');
    
    if (isPanModeActive) {
        // Activate pan mode
        btn.textContent = '🤚: ON';
        btn.classList.replace('bg-blue-600', 'bg-red-600');
        
        // Add listeners only when pan mode is ON
        scrollContainer.addEventListener('mousedown', startPan);
        scrollContainer.addEventListener('mousemove', pan);
        scrollContainer.addEventListener('mouseup', stopPan);
        scrollContainer.addEventListener('mouseleave', stopPan);

        // Add touch support for touchpads/mobiles
        scrollContainer.addEventListener('touchstart', startPan);
        scrollContainer.addEventListener('touchmove', pan);
        scrollContainer.addEventListener('touchend', stopPan);
        
        // Change cursor to indicate drag-ability
        scrollContainer.style.cursor = 'grab';
        
    } else {
        // Deactivate pan mode
        btn.textContent = '🤚';
        btn.classList.replace('bg-red-600', 'bg-blue-600');
        
        // Remove listeners when pan mode is OFF
        scrollContainer.removeEventListener('mousedown', startPan);
        scrollContainer.removeEventListener('mousemove', pan);
        scrollContainer.removeEventListener('mouseup', stopPan);
        scrollContainer.removeEventListener('mouseleave', stopPan);

        scrollContainer.removeEventListener('touchstart', startPan);
        scrollContainer.removeEventListener('touchmove', pan);
        scrollContainer.removeEventListener('touchend', stopPan);

        scrollContainer.style.cursor = 'default';
        
        isDragging = false; // Ensure dragging is stopped
    }
};

/**
 * Starts the drag operation on mousedown or touchstart.
 */
function startPan(e) {
    if (!isPanModeActive) return;

    e.preventDefault(); // Prevent text selection/default scrolling
    isDragging = true;
    scrollContainer.style.cursor = 'grabbing';
    
    // Get initial cursor position, adjusting for touch events
    lastX = e.clientX || e.touches[0].clientX;
    lastY = e.clientY || e.touches[0].clientY;
}

/**
 * Handles the dragging and updates the scroll position.
 */
function pan(e) {
    if (!isDragging) return;

    // Get current cursor position, adjusting for touch events
    const currentX = e.clientX || e.touches[0].clientX;
    const currentY = e.clientY || e.touches[0].clientY;

    // Calculate the difference (delta) from the last position
    const deltaX = currentX - lastX;
    const deltaY = currentY - lastY;
    
    // Get the current zoom factor (e.g., 0.9, 1.0, 1.5)
    // We assume setZoom() is active and the body has a transform
    const transform = scrollContainer.style.transform;
    const match = transform.match(/scale\(([^)]+)\)/);
    const zoomFactor = match ? parseFloat(match[1]) : 1.0;

    // The scroll distance must be adjusted by the inverse of the zoom factor.
    // If zoomed in (zoomFactor > 1), moving the mouse 10px on screen 
    // corresponds to a smaller distance in the actual content size.
    const scrollDeltaX = deltaX / zoomFactor;
    const scrollDeltaY = deltaY / zoomFactor;

    // Apply the change to the scroll position
    scrollContainer.scrollLeft -= scrollDeltaX;
    scrollContainer.scrollTop -= scrollDeltaY;

    // Update last position for the next move event
    lastX = currentX;
    lastY = currentY;
}

/**
 * Stops the drag operation on mouseup, mouseleave, or touchend.
 */
function stopPan() {
    if (!isPanModeActive) return;
    
    isDragging = false;
    scrollContainer.style.cursor = 'grab'; // Restore grab cursor
}

// Add the original setZoom function here for context, 
// ensuring the body has `transform-origin: top left;` set.

/*
// Example of your setZoom function (ensure it's in the final script)
window.setZoom = function(zoomV = null) {
    // ... (rest of the setZoom logic from the previous answer)
    const bodyStyle = document.getElementById('main-container');
    bodyStyle.transform = `scale(${scaleFactor})`;
    bodyStyle.transformOrigin = 'top left'; 
    // ...
};
*/






       //############################## DRAWIMG  #########################################
        // --- Drawing Logic (Enhanced with Eraser) ---
         isDrawing = false;
        let lastX = 0;
        let lastY = 0;
         //let context = null;--- stated in global 
         let drawingCanvas = null;
        let penColor = '#FF0000'; // Default pen color (Red)
        let penSize = 5;      // Default pen size
        let drawingMode = 'none'; // 'pen' or 'erase'

  window.initDrawingCanvas=function(ele) {


         drawingCanvas = document.getElementById('drawingCanvas');


        // 2. Make the check simple: if it's null, something is fundamentally wrong
        if (!drawingCanvas) {
             showModal('Canvas element not found in DOM after creation.', 'Error');
            return;
        }

             context = drawingCanvas.getContext('2d'); 
         
             updateCanvasSize();

   if (drawingMode=='none') {
        // If a tool is active (currentTool is not null), the canvas receives events ('auto').
        // If selection mode is active (currentTool is null), clicks pass through ('none').
        drawingCanvas.style.pointerEvents = 'none';
    }

            // Event listeners for drawing (Mouse and Touch)

            drawingCanvas.addEventListener('mousedown', startDrawing);
            drawingCanvas.addEventListener('mousemove', draw);
            drawingCanvas.addEventListener('mouseup', stopDrawing);
            drawingCanvas.addEventListener('mouseout', stopDrawing);

            drawingCanvas.addEventListener('touchstart', (e) => {
                e.preventDefault(); 
                startDrawing(e.touches[0]);
            });
            drawingCanvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                draw(e.touches[0]);
            });
            drawingCanvas.addEventListener('touchend', stopDrawing);

            // Listeners for drawing controls
            document.getElementById('pen-color').addEventListener('change', (e) => {
                penColor = e.target.value;
                setDrawingMode('pen');
            });
            
            const penSizeInput = document.getElementById('pen-size');
            const sizeDisplay = document.getElementById('size-display');
            penSizeInput.addEventListener('input', (e) => {
                penSize = parseInt(e.target.value, 10);
                sizeDisplay.textContent = penSize;
            });
            
            document.getElementById('pen-tool').addEventListener('click', () => setDrawingMode('pen'));
            document.getElementById('eraser-tool').addEventListener('click', () => setDrawingMode('erase'));
            document.getElementById('clear-canvas-button').addEventListener('click', clearCanvas);

            window.addEventListener('resize', updateCanvasSize);
            
            // Set initial active tool state
            window.updateToolButtons();
        }

         window.setDrawingMode=function(mode) {
            drawingMode = mode;
                        //drawingCanvas.style.pointerEvents = drawingMode ? 'auto' : 'none';
            window.updateToolButtons();
            // Ensure the context is set correctly for the new mode before drawing
            if (context) {
                 if (drawingMode === 'erase') {
                    context.globalCompositeOperation = 'destination-out';
                     drawingCanvas.style.pointerEvents = 'auto';

                 } else if (drawingMode === 'none') {

                     drawingCanvas.style.pointerEvents = 'none';


                } else {
                    context.globalCompositeOperation = 'source-over';
                    drawingCanvas.style.pointerEvents = 'auto';

                }
            }
        }
        
       window.updateToolButtons=function() {
            const penBtn = document.getElementById('pen-tool');
            const eraseBtn = document.getElementById('eraser-tool');
            
            penBtn.classList.toggle('active-tool', drawingMode === 'pen');
            eraseBtn.classList.toggle('active-tool', drawingMode === 'erase');
            		
            // Highlight the color picker if in pen mode
            document.getElementById('pen-color').parentElement.classList.toggle('ring-2', drawingMode === 'pen');
            document.getElementById('pen-color').parentElement.classList.toggle('ring-gray-300', drawingMode === 'pen');
        }

        function clearCanvas() {
            if (!context) return;
            // Temporarily set composite operation to clear everything
            context.globalCompositeOperation = 'destination-out';
            context.fillRect(0, 0, drawingCanvas.width, drawingCanvas.height);
            
            // Restore drawing mode setting
            window.setDrawingMode(drawingMode);
            
            // Autosave the clear action (saves an empty drawing data string)
            //saveCurrentPage();
            //showMessageBox("Canvas cleared!", 'bg-blue-100 border-blue-400 text-blue-700');
        }
        
        function updateCanvasSize() {
             if (!drawingCanvas) return;
            const container = document.getElementById('editor');
            const rect = container.getBoundingClientRect();
 
            if (drawingCanvas) {
                // Set CSS dimensions for layout
                drawingCanvas.style.width = `${rect.width}px`;
                drawingCanvas.style.height = `${rect.height}px`;
                // Set canvas element dimensions for drawing resolution
                const wasDrawing = isDrawing;
                isDrawing = false; // Prevent drawing during resize/reload
                
                // IMPORTANT: Before setting new dimensions, save the current drawing data
                const imgData = drawingCanvas.toDataURL('image/png');
                
                drawingCanvas.width = rect.width;
                drawingCanvas.height = rect.height;
 
                // Redraw saved image data onto the newly sized canvas
                if (imgData) {
                    const img = new Image();
                    img.onload = () => {
                        context.drawImage(img, 0, 0, drawingCanvas.width, drawingCanvas.height);
                        // Ensure drawing mode is restored
                        window.setDrawingMode(drawingMode);
                        isDrawing = wasDrawing;
                    };
                    img.src = imgData;
                 
                }
                
                // If there's content loaded, ensure the Firestore listener handles the reload
                // if (currentPageId) {
                   //loadPageData(currentPageId); //loadPageContent(currentPageName); 
                // }
            }
        }
        
        function startDrawing(e) {
            isDrawing = true;
            const rect = drawingCanvas.getBoundingClientRect();
       //showModal(drawingMode,'drawingMode');
            [lastX, lastY] = [e.clientX - rect.left, e.clientY - rect.top];
            
            if (drawingMode === 'erase') {
                context.globalCompositeOperation = 'destination-out';
                context.strokeStyle = 'rgba(0,0,0,1)'; // Color doesn't matter for eraser
            } else {
                context.globalCompositeOperation = 'source-over';
                context.strokeStyle = penColor;
            }
            
            context.lineWidth = penSize;
            context.lineCap = 'round';
            
            context.beginPath();
            context.moveTo(lastX, lastY);
            // Draw a tiny dot for single clicks/taps
            context.lineTo(lastX + 0.1, lastY + 0.1); 
            context.stroke();
            
            [lastX, lastY] = [lastX + 0.1, lastY + 0.1]; 
        }

      function draw(e) {
            if (!isDrawing) return;
   
            const rect = drawingCanvas.getBoundingClientRect();
            let x = e.clientX - rect.left;
            let y = e.clientY - rect.top;

            context.beginPath();
            context.moveTo(lastX, lastY);
            context.lineTo(x, y);
            context.stroke();
            
         [lastX, lastY] = [x, y];


const editor = document.getElementById('main-container');
//const editor = document.getElementById('editor-wrapper');
    const container = editor.parentElement; // Assuming the editor is in a scrollable container

const transformMatch = editor.style.transform.match(/scale\(([^)]+)\)/);
    
    let zoomFactor = 1.0; // Default to 1.0 (no zoom)
    //const zoomFactor = parseFloat(editor.style.transform.match(/scale\(([^)]+)\)/)[1] || 1.0);

// 2. Safely extract the value if a match was found
    if (transformMatch && transformMatch[1]) {
        zoomFactor = parseFloat(transformMatch[1]);
    }


    const editorRect = editor.getBoundingClientRect();

    // 1. Get the unscaled position inside the editor content
    const unscaledX = (e.clientX - editorRect.left) / zoomFactor;
    const unscaledY = (e.clientY - editorRect.top) / zoomFactor;
    
    // 2. Adjust for scroll (this is the coordinate relative to the unscaled editor's top-left corner)
    const contentX = unscaledX + container.scrollLeft;
    const contentY = unscaledY + container.scrollTop;

    // 3. Convert content coordinates back to canvas/viewport coordinates for drawing
    const canvasDrawX = (contentX - container.scrollLeft) * zoomFactor + editorRect.left;
    const canvasDrawY = (contentY - container.scrollTop) * zoomFactor + editorRect.top;


   

// TEMPORARY TEST: Subtract the 80px offset
 
  let OFFSET = 0; 
    unscaledX = (e.clientX - editorRect.left - OFFSET) / zoomFactor; 
   unscaledY = (e.clientY - editorRect.top - OFFSET) / zoomFactor;
        }



function TEMPdraw(e) {
    if (!isDrawing) return;

    const editor = document.getElementById('editor');
    const drawingCanvas = document.getElementById('drawingCanvas');
    const context = drawingCanvas.getContext('2d');
    
    // --- Determine Scroll Container ---
    // If your editor is the only content and the entire page scrolls, 
    // the scroll parent is typically the document body/documentElement.
    // If the editor is inside a specific scrollable <div>, use its parent.
    const container = editor.parentElement; 
    
    // Get scroll values from the container
    const scrollLeft = container.scrollLeft || 0;
    const scrollTop = container.scrollTop || 0;
    
    // --- Get Zoom Factor ---
    const transformMatch = editor.style.transform.match(/scale\(([^)]+)\)/);
    // Default to 1.0 if not found, to prevent division by zero/NaN errors
    const zoomFactor = transformMatch ? parseFloat(transformMatch[1]) : 1.0; 
    
    // --- Get Editor Position ---
    const editorRect = editor.getBoundingClientRect(); 

    // 1. Calculate the distance from the mouse to the editor's top-left corner (in scaled screen pixels)
    const mouseToEditorX = e.clientX - editorRect.left;
    const mouseToEditorY = e.clientY - editorRect.top;

    // 2. Convert to unscaled content coordinates
    // This gives the exact coordinate inside the *unscaled* content div.
    const contentX = (mouseToEditorX / zoomFactor) + scrollLeft;
    const contentY = (mouseToEditorY / zoomFactor) + scrollTop;

    // 3. Convert back to Canvas/Viewport coordinates for drawing
    // This coordinate is where the point should be drawn on the unscaled canvas overlay.
    const canvasDrawX = (contentX - scrollLeft) * zoomFactor + editorRect.left;
    const canvasDrawY = (contentY - scrollTop) * zoomFactor + editorRect.top;

    // --- EXECUTE DRAWING ---
    
    // Use the calculated, correct coordinates
    let x = canvasDrawX;
    let y = canvasDrawY;
    
    context.beginPath();
    context.moveTo(lastX, lastY);
    context.lineTo(x, y);
    context.stroke();
    
    // Update lastX and lastY for the next segment
    [lastX, lastY] = [x, y];
}








        function stopDrawing() {
	
            isDrawing = false;

        }
        window.setPenColor=function(clr){
                penColor = clr;
                window.setDrawingMode('pen');
       }
        // Attach init functions to the window load event
        window.onload = function() {
            window.initDrawingCanvas();
            
        };
        
 

// (Include all other editor functions like handleStart, handleMove, initElement, etc., here)

// ====================================================================
// IV. APPLICATION ENTRY POINT (DOCUMENT READY)
// ====================================================================

document.addEventListener('DOMContentLoaded', () => {
      // 1. Load project data and render page list
            //loadProject();
            renderPageList();
            if(currentPageId) {
                loadPageData(currentPageId);
            }
       // 2. Initialize canvas
            //window.resizeCanvas();
            //ctx.strokeStyle = document.getElementById('penColor').value;
            //ctx.lineWidth = document.getElementById('lineWidth').value;
            //drawingCanvas.style.pointerEvents = 'none';
            // 初始狀態為 Select/Move 模式
            //setDrawingTool(null);
       // 3. Attach ALL event listeners
            // Element drag, drop, and resize listeners
            editor.addEventListener('mousedown', handleStart); editor.addEventListener('mousemove', handleMove);
            editor.addEventListener('mouseup', handleEnd); editor.addEventListener('mouseleave', handleEnd);
            editor.addEventListener('touchstart', handleStart, {passive: false}); editor.addEventListener('touchmove', handleMove, {passive: false});
            editor.addEventListener('touchend', handleEnd); editor.addEventListener('touchcancel', handleEnd);


            // NEW: 滑動手勢的觸發點
            editor.addEventListener('mousedown', handleGestureStart);
            editor.addEventListener('mousemove', handleGestureMove);
            editor.addEventListener('mouseup', handleGestureEnd);
            editor.addEventListener('mouseleave', handleGestureEnd);

            // NEW: 滑動手勢的觸控事件
            editor.addEventListener('touchstart', handleGestureStart, {passive: false});
            editor.addEventListener('touchmove', handleGestureMove, {passive: false});
            editor.addEventListener('touchend', handleGestureEnd);
            editor.addEventListener('touchcancel', handleGestureEnd);

            // Drawing listeners


            // Listeners for drawing controls
            document.getElementById('pen-color').addEventListener('change', (e) => {
                penColor = e.target.value;
                setDrawingMode('pen');
            });

            //drawingCanvas.addEventListener('mousedown', startDraw); drawingCanvas.addEventListener('mousemove', draw);
            //drawingCanvas.addEventListener('mouseup', stopDraw); drawingCanvas.addEventListener('mouseleave', stopDraw);
            //drawingCanvas.addEventListener('touchstart', startDraw, {passive: false}); drawingCanvas.addEventListener('touchmove', draw, {passive: false});
            //drawingCanvas.addEventListener('touchend', stopDraw);

            // Toolbar listeners
           // penColorInput.addEventListener('change', (e) => ctx.strokeStyle = e.target.value);
           // lineWidthInput.addEventListener('input', (e) => ctx.lineWidth = e.target.value);
            
            //toggleDrawingBtn.addEventListener('click', toggleDrawing);
            //document.getElementById('penColor').addEventListener('change', (e) => ctx.strokeStyle = e.target.value);
            //document.getElementById('lineWidth').addEventListener('input', (e) => ctx.lineWidth = e.target.value);

            //window.addEventListener('resize', resizeCanvas);

            // Auto-save project every 5 seconds
            setInterval(saveCurrentPageData, 5000);
            window.addEventListener('beforeunload', () => {
                saveCurrentPageData();
                saveProject();
            });

    
    // 5. Finalize tool state
    //window.setDrawingTool(null); // Initialize in selection mode
});



        // --- 6. INITIALIZATION ---
        
        document.addEventListener('DOMContentLoaded', () => {
           window.loadProjectFromLocalStorage();
            
            window.updateTimerDisplay(GAME_DURATION_SECONDS);
        });




    </script>
<script>
 
    window.setZoom = function(zoomV = null) {
        let scaleFactor; // The unitless float (e.g., 0.9, 1.0)
        
        // 1. Determine the target zoom value
        if (zoomV !== null) {            
            scaleFactor = zoomV / 100; 
        } else {
            const rangeValue = parseFloat(document.getElementById('zoom').value);
            // Example: 10 * 10 = 100%. Scale factor = 1.0
            scaleFactor = rangeValue / 10; 

        }

        // 2. Apply the scaling and origin to the body
        const bodyStyle = document.getElementById('main-container').style;
         document.getElementById('panScale').innerText=scaleFactor;
        // Set the transform for scaling
                bodyStyle.transform = `scale(${scaleFactor})`;
         
        // Ensure scaling originates from the top left to align with scroll management
        bodyStyle.transformOrigin = 'top left'; 
        
        // Optional: Resetting the zoom property since we prefer transform: scale------------document.body.style.zoom = zoomV+"%";
       // bodyStyle.zoom = '100%'; 
            let rangeScale = parseFloat(document.getElementById('Scale').value);
          // bodyStyle.zoom = `${rangeScale}%`; 
            document.body.style.zoom = `${rangeScale}%`; 

const computedStyle = window.getComputedStyle(editor);
const transformValue = computedStyle.getPropertyValue('transform');


    };
</script>

  <script>
    document.addEventListener('DOMContentLoaded', function() {
      // 全域變數控制水果落下速度倍率 (速度慢時為2.0)
      let speedFactor = 1.0;
      
      // 遊戲規則：先拿到5分即獲勝
      const winningScore = 5;
      
      // 預設題目資料 (會被 questionBankInput 的內容覆蓋)
      let questionData = [];
      
      // 元素參考
      const questionDisplay = document.getElementById('question-display');
      const team1FruitContainer = document.getElementById('team1-fruit-container');
      const team2FruitContainer = document.getElementById('team2-fruit-container');
      const team1Score = document.getElementById('team1-score');
      const team2Score = document.getElementById('team2-score');
      const questionNumber = document.getElementById('question-number');
      const nextButton = document.getElementById('next-question');
      // resultMessage 以動態建立，正確答案時會移動到對方水果區中央
      const resultMessage = document.createElement('div'); 
      resultMessage.className = "result-container";
      const winnerScreen = document.getElementById('winner-screen');
      const winnerTeam = document.getElementById('winner-team');
      const restartButton = document.getElementById('restart-button');
      const questionBankPanel = document.getElementById('question-bank-panel');
 const questionBankInput = document.getElementById('question-bank-input');
const toggleQuizBtn = document.getElementById('toggleQuizBtn');
 
      //const questionBankInput = document.getElementById('quizData');
      const questionBankSubmit = document.getElementById('question-bank-submit');
      const correctSound = document.getElementById('correct-sound');
      const wrongSound = document.getElementById('wrong-sound');
      const sliceSound = document.getElementById('slice-sound');
      const bgm = document.getElementById('bgm');
      const volumeControl = document.getElementById('volume-control');
      const volumeOn = document.getElementById('volume-on');
      const volumeOff = document.getElementById('volume-off');
      const toggleFontButton = document.getElementById('toggle-font');
      const speedToggleButton = document.getElementById('speed-toggle');
      const fruitTypes = ['watermelon', 'orange', 'strawberry', 'blueberry', 'pineapple'];
      
      let currentQuestionIndex = 0;
      let team1Points = 0;
      let team2Points = 0;
      let questionAnswered = false;
      let confetti;
      let fruitIntervals = [];
      let team1ActiveFruits = [];
      let team2ActiveFruits = [];
      
      const bgmList = [
        "https://taira-komori.jpn.org/sound_os2/nature01/summer_hill2.mp3",
        "https://taira-komori.jpn.org/sound_os2/nature01/mountain_stream.mp3",
        "https://taira-komori.jpn.org/sound_os2/nature01/brook1a.mp3",
        "https://taira-komori.jpn.org/sound_os2/nature01/mountain_children.mp3"
      ];
      
      function selectRandomBGM() {
        const randomIndex = Math.floor(Math.random() * bgmList.length);
        bgm.src = bgmList[randomIndex];
        bgm.volume = 0.3;
        bgm.play().catch(e => {
          console.log("自動播放被阻擋，請用戶點擊畫面後再播放", e);
        });
      }
      
      // 控制背景音效靜音
      volumeControl.addEventListener('click', function() {
        bgm.muted = !bgm.muted;
        if (bgm.muted) {
          volumeOn.style.display = 'none';
          volumeOff.style.display = 'block';
        } else {
          volumeOn.style.display = 'block';
          volumeOff.style.display = 'none';
        }
      });
      
      // 速度切換：若切換為慢速，speedFactor 變為 2.0
      speedToggleButton.addEventListener('click', function() {
        if (speedFactor === 1.0) {
          speedFactor = 2.0;
          speedToggleButton.textContent = "速度慢";
        } else {
          speedFactor = 1.0;
          speedToggleButton.textContent = "速度快";
        }
      });
      
      toggleFontButton.addEventListener('click', function() {
        if (!document.body.classList.contains('zhuyin-font')) {
          document.body.classList.add('zhuyin-font');
          toggleFontButton.classList.add('active');
          toggleFontButton.textContent = '返回一般字體';
        } else {
          document.body.classList.remove('zhuyin-font');
          toggleFontButton.classList.remove('active');
          toggleFontButton.textContent = '切換注音字體';
        }
      });
      
      document.body.addEventListener('click', function() {
        if (bgm.paused) {
          bgm.play().catch(e => {
            console.log("播放失敗", e);
          });
        }
      }, { once: true });
      
      selectRandomBGM();
      
      // Ctrl+I：切換題庫輸入面板
      document.addEventListener('keydown', function(e) {
        if (e.ctrlKey && e.key.toLowerCase() === 'i') {
          e.preventDefault();
          questionBankPanel.style.display = (questionBankPanel.style.display === "block") ? "none" : "block";
        }
      });
      
      questionBankSubmit.addEventListener('click', function() {
        const text = questionBankInput.value;
        loadQuestionBankFromText(text);
        questionBankPanel.style.display = "none";
      });
      
      // 遊戲開始時，自動載入 textarea 中的預設題庫
      if (questionBankInput.value.trim() !== "") {
        loadQuestionBankFromText(questionBankInput.value);
      } else {
        initGame(); // 如果 textarea 為空，則初始化空遊戲
      }
      //----------const toggleQuizBtn = document.getElementById('toggleQuizBtn');
      toggleQuizBtn.addEventListener('click', function() {
           //alert('I got you--------------------------');
        const text = document.getElementById('quizData').innerHTML;
        let cleanText = text.replace(/<br\s*\/?>/gi, '\n'); 
        loadQuestionBankFromText(cleanText);
        //questionBankPanel.style.display = "none";
      });
               


      // *** 修改後的題庫解析函數toggleQuizBtn ***
      function loadQuestionBankFromText(text) {
//alert('---'+document.getElementById('quizData').innerText);

let cleanText = text.replace(/<br\s*\/?>/gi, '\n'); 
        
        // Step 2: 使用標準換行符號分割行
        const lines = cleanText.split(/\r?\n/);


 
        const newData = [];
        lines.forEach(line => {
          line = line.trim();
          if (line === "") return;
          
          // 替換所有 tab 符號為 |，然後使用 | 分割。
          // 移除行首的數字編號（如果有的話，如 '1 |'）
          const parts = line.replace(/\t/g, '|').replace(/^\d+\s*\|\s*/, '').split('|').map(p => p.trim());
          
          // 檢查是否有足夠的欄位 (題目, 答案索引, 選項1, 選項2, 選項3, 選項4 = 6個欄位)
          if (parts.length < 6) return;
          
          const [q, answerStr, opt1, opt2, opt3, opt4] = parts;
          
          let correctOptionIndex = -1;
          const ansLower = answerStr.toLowerCase();
          
          // 將答案的 1, 2, 3, 4 轉換為 0, 1, 2, 3
          const answerNumber = parseInt(ansLower);
          if (!isNaN(answerNumber) && answerNumber >= 1 && answerNumber <= 4) {
            correctOptionIndex = answerNumber - 1; 
          } else if (ansLower === "a") {
            correctOptionIndex = 0;
          } else if (ansLower === "b") {
            correctOptionIndex = 1;
          } else if (ansLower === "c") {
            correctOptionIndex = 2;
          } else if (ansLower === "d") {
            correctOptionIndex = 3;
          }
          
          if (correctOptionIndex !== -1) {
            newData.push({
              question: q,
              correctOptionIndex: correctOptionIndex,
              options: [opt1, opt2, opt3, opt4]
            });
          }
        });
        
        if (newData.length > 0) {
          questionData = newData;
          initGame();
        } else {
           console.warn("載入題庫失敗，請檢查格式是否為：題目 | 答案(1-4) | 選項1 | 選項2 | 選項3 | 選項4");
           questionData = []; // 清空題目，等待用戶重新輸入或重啟
        }
      }
      // *** 結束修改後的題庫解析函數 ***

      function initGame() {
        fruitIntervals.forEach(interval => clearInterval(interval));
        fruitIntervals = [];
        team1FruitContainer.innerHTML = '';
        team2FruitContainer.innerHTML = '';
        team1ActiveFruits = [];
        team2ActiveFruits = [];
        team1Points = 0;
        team2Points = 0;
        currentQuestionIndex = 0;
        team1Score.textContent = '0';
        team2Score.textContent = '0';
        winnerScreen.classList.remove('show');
        // 若同路徑下有 bg1.png ~ bg5.png，隨機載入背景圖片到左右區塊
        const leftTeam = document.querySelector('.left-team');
        const rightTeam = document.querySelector('.right-team');
        var randomLeft = Math.floor(Math.random() * 5) + 1;
        var randomRight = Math.floor(Math.random() * 5) + 1;
        leftTeam.style.backgroundImage = `url(bg${randomLeft}.png)`;
        leftTeam.style.backgroundSize = "cover";
        leftTeam.style.backgroundRepeat = "no-repeat";
        leftTeam.style.backgroundPosition = "center";
        leftTeam.style.backgroundBlendMode = "multiply";
        rightTeam.style.backgroundImage = `url(bg${randomRight}.png)`;
        rightTeam.style.backgroundSize = "cover";
        rightTeam.style.backgroundRepeat = "no-repeat";
        rightTeam.style.backgroundPosition = "center";
        rightTeam.style.backgroundBlendMode = "multiply";
        shuffleArray(questionData);
        loadQuestion();
        updateQuestionNumber();
      }
      
      function loadQuestion() {
        if(resultMessage.parentNode) {
          resultMessage.parentNode.removeChild(resultMessage);
        }
        questionDisplay.textContent = '';
        const authorSign = document.createElement('div');
        authorSign.className = "author-sign";
        authorSign.textContent = "Made by 阿剛老師";
        questionDisplay.appendChild(authorSign);
        if (currentQuestionIndex >= questionData.length) {
          showWinner();
          return;
        }
        questionAnswered = false;
        team1FruitContainer.innerHTML = '';
        team2FruitContainer.innerHTML = '';
        team1ActiveFruits = [];
        team2ActiveFruits = [];
        fruitIntervals.forEach(interval => clearInterval(interval));
        fruitIntervals = [];
        const question = questionData[currentQuestionIndex];
        questionDisplay.insertAdjacentText("afterbegin", question.question);
        startThrowingFruits(question.options, question.correctOptionIndex);
        updateQuestionNumber();
      }
      
      function startThrowingFruits(options, correctIndex) {
        const team1Delay = 600;
        const team2Delay = 400;
        options.forEach((text, index) => {
          const isCorrect = index === correctIndex;
          setTimeout(() => {
            throwFruit(team1FruitContainer, text, index, isCorrect, 1);
          }, team1Delay * (index + 1));
        });
        const shuffledIndices = [0, 1, 2, 3];
        shuffleArray(shuffledIndices);
        shuffledIndices.forEach((originalIndex, i) => {
          const text = options[originalIndex];
          const isCorrect = originalIndex === correctIndex;
          setTimeout(() => {
            throwFruit(team2FruitContainer, text, originalIndex, isCorrect, 2);
          }, team2Delay * (i + 1));
        });
        const team1Interval = setInterval(() => {
          if (questionAnswered) {
            clearInterval(team1Interval);
            return;
          }
          const randomIndex = Math.floor(Math.random() * options.length);
          const text = options[randomIndex];
          const isCorrect = randomIndex === correctIndex;
          throwFruit(team1FruitContainer, text, randomIndex, isCorrect, 1);
        }, 1000 + Math.random() * 500);
        const team2Interval = setInterval(() => {
          if (questionAnswered) {
            clearInterval(team2Interval);
            return;
          }
          const randomIndex = Math.floor(Math.random() * options.length);
          const text = options[randomIndex];
          const isCorrect = randomIndex === correctIndex;
          throwFruit(team2FruitContainer, text, randomIndex, isCorrect, 2);
        }, 1000 + Math.random() * 500);
        fruitIntervals.push(team1Interval, team2Interval);
      }
      
      function throwFruit(container, text, optionIndex, isCorrect, teamNumber) {
        if (questionAnswered) return;
        const fruit = document.createElement('div');
        fruit.className = `fruit ${fruitTypes[optionIndex % fruitTypes.length]}`;
        fruit.textContent = text;
        fruit.dataset.correct = isCorrect;
        if (text.trim().length <= 3) {
          fruit.style.width = "80px";
          fruit.style.height = "80px";
          fruit.style.borderRadius = "50%";
        } else {
          fruit.style.height = "50px";
          fruit.style.padding = "0 10px";
          fruit.style.width = "auto";
          fruit.style.borderRadius = "5px";
        }
        const startX = Math.random() * (container.offsetWidth - 100);
        fruit.style.left = `${startX}px`;
        fruit.style.bottom = `-50px`;
        container.appendChild(fruit);
        if (teamNumber === 1) {
          team1ActiveFruits.push(fruit);
        } else {
          team2ActiveFruits.push(fruit);
        }
        const maxHeight = container.offsetHeight - 50;
        const horizontalMovement = (Math.random() - 0.5) * 150;
        const duration = (1.5 + Math.random() * 1) * speedFactor;
        let startTime = null;
        function animateFruit(timestamp) {
          if (!fruit.isConnected) return;
          if (!startTime) startTime = timestamp;
          const elapsed = timestamp - startTime;
          const progress = elapsed / (duration * 1000);
          if (progress < 1) {
            const verticalPosition = maxHeight * Math.sin(progress * Math.PI);
            const horizontalPosition = startX + horizontalMovement * progress;
            fruit.style.bottom = `${verticalPosition}px`;
            fruit.style.left = `${horizontalPosition}px`;
            requestAnimationFrame(animateFruit);
          } else {
            if (fruit.isConnected) container.removeChild(fruit);
            if (teamNumber === 1) {
              const index = team1ActiveFruits.indexOf(fruit);
              if (index > -1) team1ActiveFruits.splice(index, 1);
            } else {
              const index = team2ActiveFruits.indexOf(fruit);
              if (index > -1) team2ActiveFruits.splice(index, 1);
            }
          }
        }
        requestAnimationFrame(animateFruit);
        fruit.addEventListener('pointerdown', function(e) {
          if (questionAnswered) return;
          playSliceSound();
          createSwordSlash(e, container);
          const fruitRect = fruit.getBoundingClientRect();
          const fruitCenterX = fruitRect.left + fruitRect.width / 2;
          const fruitCenterY = fruitRect.top + fruitRect.height / 2;
          createFruitSlices(fruit, fruitCenterX, fruitCenterY);
          if (fruit.isConnected) container.removeChild(fruit);
          if (teamNumber === 1) {
            const index = team1ActiveFruits.indexOf(fruit);
            if (index > -1) team1ActiveFruits.splice(index, 1);
          } else {
            const index = team2ActiveFruits.indexOf(fruit);
            if (index > -1) team2ActiveFruits.splice(index, 1);
          }
          if (fruit.dataset.correct === "true") {
            questionAnswered = true;
            fruitIntervals.forEach(interval => clearInterval(interval));
            fruitIntervals = [];
            const allRemainingFruits = teamNumber === 1 
              ? [...team2ActiveFruits] 
              : [...team1ActiveFruits];
            allRemainingFruits.forEach(remainingFruit => {
              const cont = remainingFruit.parentElement;
              if (cont) {
                createFruitSlices(remainingFruit, 
                  remainingFruit.offsetLeft + remainingFruit.offsetWidth / 2, 
                  remainingFruit.offsetTop + remainingFruit.offsetHeight / 2);
                cont.removeChild(remainingFruit);
              }
            });
            team1ActiveFruits = [];
            team2ActiveFruits = [];
            if (teamNumber === 1) {
              team1Points++;
              team1Score.textContent = team1Points;
              resultMessage.textContent = "藍隊切對了！";
              resultMessage.style.backgroundColor = "#4285f4";
              positionResultMessage(team2FruitContainer);
            } else {
              team2Points++;
              team2Score.textContent = team2Points;
              resultMessage.textContent = "紅隊切對了！";
              resultMessage.style.backgroundColor = "#ea4335";
              positionResultMessage(team1FruitContainer);
            }
            playCorrectSound();
            setTimeout(() => {
              if(team1Points >= winningScore || team2Points >= winningScore){
                showWinner();
              } else {
                currentQuestionIndex++;
                loadQuestion();
              }
            }, 1500);
          } else {
            playWrongSound();
          }
        });
      }
      
      function positionResultMessage(opposingContainer) {
        resultMessage.style.position = "absolute";
        resultMessage.style.top = "50%";
        resultMessage.style.left = "50%";
        resultMessage.style.transform = "translate(-50%, -50%)";
        resultMessage.style.display = "block";
        opposingContainer.appendChild(resultMessage);
      }
      
      function createSwordSlash(event, container) {
        const slash = document.createElement('div');
        slash.className = 'sword-slash';
        const containerRect = container.getBoundingClientRect();
        const x = event.clientX - containerRect.left;
        const y = event.clientY - containerRect.top;
        slash.style.left = `${x}px`;
        slash.style.top = `${y}px`;
        const angle = Math.random() * 360;
        slash.style.transform = `rotate(${angle}deg)`;
        container.appendChild(slash);
        requestAnimationFrame(() => {
          slash.style.width = '150px';
          slash.style.opacity = '1';
          setTimeout(() => {
            slash.style.opacity = '0';
            setTimeout(() => {
              if (slash.isConnected) container.removeChild(slash);
            }, 300);
          }, 200);
        });
      }
      
      function createFruitSlices(fruit, centerX, centerY) {
        const container = fruit.parentElement;
        if (!container) return;
        const fruitClass = fruit.className;
        const fruitText = fruit.textContent;
        const topHalf = document.createElement('div');
        topHalf.className = `${fruitClass} sliced-top`;
        topHalf.textContent = fruitText;
        topHalf.style.width = fruit.offsetWidth + 'px';
        topHalf.style.height = fruit.offsetHeight + 'px';
        topHalf.style.left = fruit.offsetLeft + 'px';
        topHalf.style.top = fruit.offsetTop + 'px';
        container.appendChild(topHalf);
        const bottomHalf = document.createElement('div');
        bottomHalf.className = `${fruitClass} sliced-bottom`;
        bottomHalf.textContent = fruitText;
        bottomHalf.style.width = fruit.offsetWidth + 'px';
        bottomHalf.style.height = fruit.offsetHeight + 'px';
        bottomHalf.style.left = fruit.offsetLeft + 'px';
        bottomHalf.style.top = fruit.offsetTop + 'px';
        container.appendChild(bottomHalf);
        setTimeout(() => {
          if (topHalf.isConnected) container.removeChild(topHalf);
          if (bottomHalf.isConnected) container.removeChild(bottomHalf);
        }, 1000);
      }
      
      function updateQuestionNumber() {
        questionNumber.textContent = `第 ${currentQuestionIndex + 1} 題 / ${questionData.length} 題`;
      }
      
      function showWinner() {
        let winner;
        if (team1Points > team2Points) {
          winner = "藍隊勝利！";
          winnerTeam.style.color = "#4285f4";
        } else if (team2Points > team1Points) {
          winner = "紅隊勝利！";
          winnerTeam.style.color = "#ea4335";
        } else {
          winner = "平手！";
          winnerTeam.style.background = "linear-gradient(to right, #4285f4, #ea4335)";
        }
        winnerTeam.textContent = winner;
        winnerScreen.classList.add('show');
        if (!confetti) {
          confetti = new ConfettiGenerator({
            target: 'confetti-container',
            max: 200,
            size: 1.5,
            animate: true,
            props: ['circle', 'square', 'triangle', 'line'],
            colors: [[165,104,246], [230,61,135], [0,199,228], [253,214,126]],
            clock: 50
          });
        }
        confetti.render();
      }
      
      nextButton.addEventListener('click', function() {
        if (!questionAnswered && currentQuestionIndex < questionData.length) {
          questionAnswered = true;
          fruitIntervals.forEach(interval => clearInterval(interval));
          fruitIntervals = [];
          [...team1ActiveFruits, ...team2ActiveFruits].forEach(fruit => {
            const container = fruit.parentElement;
            if (container && fruit.isConnected) {
              container.removeChild(fruit);
            }
          });
          team1ActiveFruits = [];
          team2ActiveFruits = [];
          setTimeout(() => {
            currentQuestionIndex++;
            loadQuestion();
          }, 500);
        } else if (questionAnswered) {
          currentQuestionIndex++;
          loadQuestion();
        }
      });
      
      restartButton.addEventListener('click', function() {
        if (confetti) {
          confetti.clear();
        }
        selectRandomBGM();
        initGame();
      });
      
      function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [array[i], array[j]] = [array[j], array[i]];
        }
      }
      
      function playCorrectSound() {
        correctSound.currentTime = 0;
        correctSound.play().catch(error => {
          console.error('無法播放正確音效:', error);
        });
      }
      
      function playWrongSound() {
        wrongSound.currentTime = 0;
        wrongSound.play().catch(error => {
          console.error('無法播放錯誤音效:', error);
        });
      }
      
      function playSliceSound() {
        sliceSound.currentTime = 0;
        sliceSound.play().catch(error => {
          console.error('無法播放切割音效:', error);
        });
      }
    });
  </script>
</body>
</html>